### ⭕ 动态规划  

组合子问题的解，得到原问题的解  

特性：  
1、在第一次求解子问题的时候，会将 **子问题的解保存**  
后续需要用的时候直接 **查表获取**，保证每个独立子问题只被计算一次  
2、不断 **组合、选择** 子问题的最优解，最终得到原问题的最优解（前提是该问题的最优解可以由其子问题的最优解组合构成，称为 **最优子结构**），设计状态转移方程  

#### 🔘 斐波那契数列

[0, 1, 1, 2, 3, 5, 8, ...] 当前数等于前两个数之和

不涉及特性 2，因为不需要选择最优组合

``` python
# 暴力递归求第 n 个斐波那契数
def fibonacci(n):
    if n == 0: return 0 # 返回 f(0)
    if n == 1: return 1 # 返回 f(1)
    return fibonacci(n - 1) + fibonacci(n - 2) # 分解为两个子问题求解
# 过程中，子问题出现了重复计算的现象，时间复杂度很高
```

``` python
# 记忆化递归
def fibonacci(n, dp):
    if n == 0: return 0           # 返回 f(0)
    if n == 1: return 1           # 返回 f(1)
    if dp[n] != 0: return dp[n]   # 若 f(n) 以前已经计算过，则直接返回记录的解
    dp[n] = fibonacci(n - 1, dp) + fibonacci(n - 2, dp) # 将 f(n) 则记录至 dp
    return dp[n]

# 求第 n 个斐波那契数
def fibonacci_memorized(n):
    dp = [0] * (n + 1) # 用于保存 f(0) 至 f(n) 问题的解
    return fibonacci(n, dp)
# 应用记忆化递归方法后，递归树中绝大部分节点被剪枝
# 降低了时间复杂度
```

递归本质上是基于分治思想的 **从顶至底** 的解法  

借助记忆化递归思想，可应用动态规划 **从底至顶** 求取 f(n)  

``` python
def fibonacci(n):
    if n == 0: return 0       # 若求 f(0) 则直接返回 0
    dp = [0] * (n + 1)        # 初始化 dp 列表
    dp[0], dp[1] = 0, 1       # 初始化 f(0), f(1)
    for i in range(2, n + 1): # 状态转移求取 f(2), f(3), ..., f(n) 
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]              # 返回 f(n)

# 优化空间复杂度
def fibonacci(n):
    if n == 0: return 0       # 若求 f(0) 则直接返回 0
    a, b = 0, 1               # 初始化 f(0), f(1)
    for i in range(2, n + 1): # 状态转移求取 f(2), f(3), ..., f(n) 
        a, b = b, a + b
    return b                  # 返回 f(n)
```

子问题包含更小的子问题；具有最优子结构。满足这两点就可以考虑使用动态规划  

求解步骤：  
1、定义问题的状态：一维 dp 列表，设第 i 个斐波那契数为 dp[i] ；  
2、确定初始状态，即已知解：已知第 0 , 1 个斐波那契数分别为 dp[0]=0 , dp[1]=1 ；  
3、确定原问题和子问题之间的关系，列出转移方程：后一个数字等于前两个数字之和，即 dp[i]=dp[i−1]+dp[i−2]  
4、确定何处停止迭代并返回值：需求取的第 n 个斐波那契数 dp[n] ；  









