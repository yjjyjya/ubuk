### 其他

---

### **sql 执行过程**

查询语句的执行流程如下：检查权限、查询缓存、分析器、优化器、权限校验、执行器、引擎  
假设有查询语句如下：  
`SELECT * FROM user WHERE id > 1 AND name = 'myMySQL';`  
首先检查权限，没有权限则返回错误；  
先查询缓存，缓存命中则直接返回，没有则执行下一步；  
词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；  
两种执行方案，先查 id > 1 还是 name = 'myMySQL'，优化器根据自己的优化算法选择执行效率最好的方案；  
校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。  


### 模糊查询与通配符

- like  
    一般配合通配符使用  
    可以匹配字符型或数值型  

- %  
    匹配任意0或者以上个字符  

- _  
    匹配任意1个字符  


### in 和 exists 的区别

exists 能使用索引，且其结果集不重要，重要的是是否有记录


### **int(10)、char(10)、varchar(10)**

https://blog.csdn.net/weixin_49263647/article/details/123180332  
int(10) 中的 10 表示的是数据显示的长度，而非大小  
char(10) 中的 10 表示的是存储多少个字符，不足 10 个字符会用空格补齐  
varchar(10) 是可变的，相较于 char 来说更省空间  


### DELECT、TRUNCATE、DROP

https://www.php.cn/mysql-tutorials-68773.html  
DELECT、TRUNCATE 只是清空表格内的数据，但是表结构还在，运行 DESC 语句应该还有结果；而 DROP 则是删除表及索引等  

| \ | DELECT | TRUNCATE |
| --- | --- | --- |
| 是否可以搭配 WHERE 条件 | 是 | 否 |
| 删除效率 | 较低 | 较高 |
| 是否有返回值 | 是 | 否 |
| 是否可以回滚 | 是 | 否 |

还有，使用 TRUNCATE 删除数据，若表中含有自增长列，重新插入数据后，自增长列的值重新从 1 开始；DELETE 则是从原来的位置继续  


### MySQL 的存储引擎

InnoDB，默认引擎，适合需要 **提交、回滚、崩溃恢复能力、能并发控制** 的情况  
MyISAM，适合数据表的操作主要是 **插入和查询** 的情况  
MEMORY，适合临时存放数据，可以作为 **临时表** 来存放查询的中间结果  
Archive，也是适合数据表的操作主要是 **插入和查询** 的情况  


### InnoDB 与 MyISAM

| \ | InnoDB | MyISAM |
| --- | --- | --- |
| 是否支持事务 | 是 | 否 |
| 是否支持外键 | 是 | 否 |
| 清空表的操作 | 一行一行的删除，效率非常慢 | 直接重建表 |
| 适合情况 | 频繁修改以及涉及到安全性较高的应用 | 查询以及插入为主的应用 |


### 主键与索引的区别

主键∈索引  
通过定义 PRIMARY KEY 约束来创建主键，要求 PRIMARY KEY 唯一且非空  


### 数据库索引类型

按照逻辑分类：  
主键索引，每张表的主键索引只能有一个，要求键值唯一非空  
唯一索引，每张表可有多个唯一索引，要求键值唯一可为空  
组合索引，对表中的多个字段组合创建索引，遵循最左前缀原则  
普通索引，每张表可有多个普通索引，键值可重复可为空  
全文索引  

按照物理分类：  
聚集索引，每张表的聚集索引只能有一个，数据在物理存储中的顺序与索引的逻辑顺序相同  
非聚集索引  


### 数据库创建索引的优缺点

优点：  
大大提高系统的性能  
创建唯一索引，可以保证每一行数据的唯一性  
大大加快数据的检索速度  
加速表与表之间的连接  
加速分组和排序子句的数据索引速度  

缺点：  
创建和维护索引要耗费时间，时间随着数据量的增加而增加  
索引要占据物理空间  
对数据进行增删改的时候，对应的索引也需要动态维护，这就降低了数据的维护速度  

- 何时使用索引  
    适合在  
    经常需要 **搜索** 的列上  
    作为 **主键** 的列上  
    经常需要与其他表 **连接** 的列上  
    经常需要 **排序** 的列上  

    不适合在  
    **更新频繁** 的列上  
    数据 **取值较少** 的列上，例如性别  


### 怎么建立和删除索引

- 建立索引
    - alter
        - 在 mytable 表中给 col 列添加主键  
            `ALTER TABLE mytable ADD PRIMARY KEY (col)`  
        - 在 mytable 表中给 col 列添加普通索引  
            `ALTER TABLE mytable ADD INDEX (col)`  
        - 在 mytable 表中给 col 列添加唯一索引  
            `ALTER TABLE mytable ADD UNIQUE (col)`  
    - create
        - 在 mytable 表中给 col 列添加普通索引 myindex  
            `CREATE INDEX myindex ON mytable (col)`  
        - 在 mytable 表中给 col 列添加唯一索引 myindex  
            `CREATE UNIQUE myindex ON mytable (col)`  

- 删除索引
    - alter
        - 删除 mytable 表中的普通索引 myindex  
            `ALTER TABLE mytable DROP INDEX myindex`  
        - 删除 mytable 表中的主键索引  
            `ALTER TABLE mytable DROP PRIMARY KEY`  
    - drop
        - 删除 mytable 表中的普通索引 myindex  
            `DROP INDEX myindex ON TABLE mytable`  

### 事务 ACID

- A（atom），原子性  
    事务是整体，要么全部做，要么都不做  

- C（consistency），一致性  
    事务执行前后，数据应该保持一致状态，例如银行转账前后的两个账户总额  

- I（isolation），隔离性  
    多个事务同时执行时，它们之间不会互相影响  

- D（durability），持久性  
    事务一旦做了之后，对数据库的改变是永久的  


### 事务的并发问题

假设有两个事务 T1 和 T2  
并发就是同时运行 T1、T2  
当这些事务要去处理同个数据时，就会引发各种问题：  

- 脏读  
    T2 对某个列（也叫字段）col 进行了更新变成 col1，但是注意 **T2 还未提交**，同时 T1 去读取了该列 col。设想当 T2  回滚（类似于撤销操作），T1 读取的还是 T2 更新后的列 col1 吗？应该还是，不过是 **临时且无效** 的  

- 不可重复读（值不同=>锁行）  
    T1 首先读取了某个列（也叫字段），此时 T2 对该列进行了更新且 **提交** 了，之后 T1 再去读取同一列，值就不同了  

- 幻读（行数不同=>锁表）  
    T1 首先读取了某个表，此时 T2 向表中插入了几行，之后 T1 再去读取该表，就会多出几行  

为了避免以上问题，需要制定好数据库的隔离级别


### 事务隔离级别

共 4 级：

| 隔离级别 | 描述 | 脏读是否出现 | 不可重复读是否出现 | 幻读是否出现 |
| --- | --- | --- | --- | --- |
| READ UNCOMMITTED | 读取未提交的数据 | ✔ | ✔ | ✔ |
| READ COMMITTED | 读取已提交的数据 | × | ✔ | ✔ |
| REPEATABLE READ | 可重复读 | × | × | ✔ |
| SERIALIZABLE | 串行化 | × | × | × |


### 数据库索引结构

- 二叉树  
    进行查找的时候，若目标元素值小于当前节点，则移动到左侧子节点进行比较，反之若大于则移动到右侧子节点比较  
    但是大部分情况下，是用一个 **自增的整型字段** 作为索引的列，这会导致索引总是添加到右侧，这与没有建立索引的清况是一样的  

- 红黑树  
    也叫二叉平衡树，解决了上面二叉树出现的自增整型索引的问题  
    红黑树会 **左旋和右旋**，对结构进行调整  
    不过数据量大的时候，树的深度也很深，因为每个节点只能存在两个子节点  

- B树  
    在红黑树的基础上，**适当地** 增加每个树节点能存储的 **数据个数**，解决了数据量大的时候树很深的问题  
    左右子树深度相同，每个节点包含了 **索引值和表记录**（即key:value的形式）的信息  
    查询单条数据很快，但若是范围查询，每次都需要从 **根节点** 进行查询，效率会降低  
    相对于 B 树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使树变得更矮、深度更小，减少了查询时磁盘的 IO 次数，提高查询效率  

- B+树  
    只有 **叶子节点存储数据**，**非叶子节点存放索引信息**，这增大了节点的度值，提高查询命中目标元素值的几率  
    叶子节点之间行程单链表，适合进行区间查找  
    MySQL 将叶子节点和非叶子节点保存在不同的段上，段又分区，区又分块  


### 锁的种类

- 按照类型分
    - 乐观锁：假设了数据一般情况下不会发生冲突，在数据提交更新时才会检测数据是否发生冲突
    - 悲观锁：假设了数据并发操作下必定发生冲突，在数据开始读取前就把数据锁住

- 按照粒度分
    - 行级锁
    - 页级锁
    - 表级锁

- 按照作用分
    - 共享锁：读操作时创建
    - 排他锁：写操作时创建  
    假设一事务 T，对某个表进行查询，并对查询结果集申请排他锁，则其他线程对查询出的数据只能读，不能更改或者删除。直到事务 T 提交或者回滚为止  


### 水平切分、垂直切分

- 水平切分  
    比如一张表有100w条数据，我们将它切分为10个总和为100w条数据的表  
    可以通过地区、年份、索引取模来实现水平切分  

- 垂直切分  
    一张表的数据条数不多，但是列数很多，则可以按列拆分开来  

- 分表的原则  
    能不拆分就不拆分  
    列之间的业务耦合性低的可以使用垂直切分  
    百万级大表，进行插入和查询的时候耗时长，可以通过拆表提升数据库性能  


### 高并发的解决方案

分表分库，将表水平拆分  
增加缓存，将高频访问的数据写入缓存中  
增加数据库的索引  
主从读写分离，只在主服务器上写，从服务器上读  
负载均衡集群，通过集群或者分布式的方法解决并发压力  


### SQL 优化

数据量越大，提升 I/O 越重要，例如使用短索引等等  
优化索引、优化访问方式  
检查是否出现死锁  
优化查询语句  
升级硬件  
提高网速  
扩大服务器内存  


### 索引失效的情况

1. like查询是以%开头，索引会失效变成全表扫描
2. 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
3. 字符串不加单引号索引会失效
4. 若使用全表扫描要比使用索引快，则不会使用到索引
5. 使用is not null 或者 is null会导致无法使用索引
6. 在索引列上做任何操作，会导致索引失效而导致全表扫描
7. 对于多列索引，不是使用的第一部分(第一个)，则不会使用索引


### 分页读取数据的操作

假设有数据如下表

| ID | 姓名 | 年龄 | 爱好 |
| --- | --- | --- | --- |
| 001 | 金 | 24 | 下棋 |
| 002 | 木 | 18 | 看书 |
| 003 | 水 | 23 | 跑步 |
| 004 | 火 | 15 | 绘画 |
| 005 | 土 | 18 | 篮球 |

``` SQL
-- 输出前2条数据，001、002
LIMIT 2

-- 忽略前2行数据，输出3条数据，003、004、005
LIMIT 2, 3

-- 忽略前3行数据，输出2条数据，004、005
LIMIT 2 OFFSET 3
```

LIMIT 子句必须放在整个 SELECT 语句的最后


### 过滤条件放在 ON 和 WHERE 的区别

假设有筛选语句如下：  
``` SQL
SELECT ...
FROM ...
(INNER/LEFT/RIGHT) JOIN ... ON ...
WHERE ...
```

WHERE执行在JOIN之后，ON执行在JOIN之中  
！！！JOIN要求索引列保留  
所以如果过滤条件在ON之中，导致筛选条件只对非索引列起作用  
如果过滤条件在WHERE之中，则不会出现这种情况  


### 关系型数据库与非关系型数据库

关系型数据库：  
1、易于理解  
2、保持数据的一致性  
3、数据更新的开销较小  
4、支持while等语句的查询  

非关系型数据库：  
1、读写效率高  
2、基于键值对，数据扩展性好  
3、支持存储的数据类型更多  


### 数据库的范式

- 范式：
    - 第一范式（1NF）：一个关系模式 R 的所有属性都是不可分的基本数据项
    - 第二范式（2NF）：满足第一范式，然后消除部分依赖。确保表中的每一列都与主键相关
    - 第三范式（3NF）：满足第二范式，消除传递依赖

- 依赖：
    - 部分依赖  
        假设A、B是关系R的两个属性集合，->表示能得出  
        A中有真子集 x、y  
        若有A->B，且x->B，y->B，则说B部分依赖于A  
    - 完全依赖  
        假设同上，!->表示不能得出  
        若有A->B，且x!->B，y!->B，则说B完全依赖于A  
    - 传递依赖  
        假设A、B、C是关系R的三个属性集合  
        若有A->B，B!->A，B->C，C!->B，则说C传递依赖于A  


### 关于二叉树

N层满二叉树（完全二叉树）的节点个数  
$2^{0}+2^{1}+2^{2}+...+2^{N-1}=2^{N}-1$  
（$等比数列求和公式：S_{n}=\frac{a_{1}(1-q^{n})}{1-q}$）  

N个节点的完全二叉树深度  
$log_{2}{N}+1$  

二叉树节点N计算公式  
假设叶子节点数为 $n_{0}$ ，度为1节点数为 $n_{1}$，度为2节点数为 $n_{2}$  
$N=n_{0}+n_{1}+n_{2}$  
$N=n_{1}+2n_{2}+1$  
$n_{0}=n_{2}+1$  
例子：  
若总节点数为999这样的奇数，999/2 = 499.5 ，那么叶子节点就有500个，度为2的节点为499个，度为1的节点为0个  
若总节点数为1500这样的偶数，1500/2 = 750 ，那么叶子节点就有750个，度为2的节点就有749个，度为1的节点为1个  
综上，度为1的节点是少数？  


### 连接池

适用于复杂的数据库应用，**防止频繁地建立、关闭连接操作**，减少对系统性能的消耗  
连接池的基本原理是：在内部对象池中维护一定数量的数据库连接，对外暴露数据库连接的获取和返回方法  
作用是：资源重用；更快的系统响应速度；新的资源分配手段；避免常规数据库连接出现资源泄露的可能  