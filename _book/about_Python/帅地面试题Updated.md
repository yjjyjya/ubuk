- [*Python 简介*](#1)  
- [*赋值、浅拷贝、深拷贝*](#2)  
- [*Python 的作用域*](#3)  
- [*Python 自省*](#4)  
- [*Python 提升性能的手段*](#5)  
- [*字典的 items() 与 iteritems()*](#6)  
- [*os.path 和 sys.path*](#7)  
- [*字典与 JSON*](#8)  
- [*可变、不可变类型*](#9)  
- [*Python 的内存管理*](#10)  
- [*模块和包是什么？*](#11)  
- [*类方法、类实例方法、静态方法*](#12)  
- [*内存管理机制、调优手段*](#13)  
- [*内存泄漏*](#14)  
- [*函数调用时，参数传递的方式*](#15)  
- [*pass 语句*](#16)  
- [*super() 作用*](#17)  
- [*回调函数*](#18)  
- [*方法重载、方法重写*](#19)  
- [*函数装饰器的用途*](#20)  
- [*生成器、迭代器*](#21)  
- [*is 与 ==*](#22)  
- [*面向过程、面向对象*](#23)  
- [*GET 与 POST*](#24)  

<a id='1'></a>
### *Python 简介*

- 是一个编程语言
- 是解释型脚本语言，无需编译，只需要解释器，但是运行速度慢于编译型语言
- 动态类型语言，声明变量时无需说明类型
- 适合面向对象编程，支持通过组合与继承的方式定义类
- 强类型语言。不允许不同类型相加

> 解释型、编译型  
计算机不能直接理解高级语言，需要 **翻译成机器语言**  
解释型语言在 **运行程序** 时进行翻译  
编译型语言在执行之前需要一个专门的 **编译过程**，把程序编译成机器语言（可执行文件）  


<a id='2'></a>
### *赋值、浅拷贝、深拷贝*

- 赋值  
    Python 中的赋值是简单的 **对象引用**，不会创建新对象  
    若 `b = a`，则 `a` 和 `b` **指向同一片内存空间**，可以使用 `id()` 查看  
    若修改 `a`，则 `b` 也会跟着改变  

- 浅拷贝  
    三种形式：  
    - 切片操作：`b = a[:]` 或者 `b = [x for x in a]`  
    - 工厂函数：`b = list(a)`  
    - copy 函数：`b = copy.copy(a)`  
    
    以上操作都会创建新对象，通过 `id()` 查看 `b` 和 `a` 的内存空间是不同的  
    
    > 注意  
    若 `a` 里面有 **嵌套的列表**，它们指向的位置还是一样的。即对 `a` 中的列表进行修改，`b` 对应的也会改变  

- 深拷贝  
    `b = copy.deepcopy(a)`  
    `b` 是全新的对象，与 `a` **没有任何关联**  
    时间、空间开销更高  

> 注意  
数字、字符是 **非容器类型**，没有拷贝一说  


<a id='3'></a>
### *Python 的作用域*

搜索顺序：  
Local，本地作用域  
Enclosing Local，当前作用域被嵌入的本地作用域  
Global，全局作用域  
Built-in，内置作用域  


<a id='4'></a>
### *Python 自省*

即自我检查能力  
`dir()`，可以用来查看 **对象的属性名称**  
`type()`，查看对象的 **类型**  
`getattr()`，查看对象的 **属性**  
`hasattr()`，查看对象 **是否拥有某属性**  
`isinstance()`，判断某个对象 **是否是某个特定的类型**  


<a id='5'></a>
### *Python 提升性能的手段*

使用 **多进程**  
对性能影响较大的部分使用 c 或者 c++ 编写  
IO 阻塞采用 **IO 多路复用**  
尽量使用 Python 的 **内置函数**  
尽量使用 **局部变量**  


<a id='6'></a>
### *字典的 items() 与 iteritems()*

`items()`，返回值是 **列表** 存储的键值对，没有特殊的顺序  
`iteritems()`，类似，返回的是一个 **迭代器**  

> 注意  
存入字典中的数据没有顺序


<a id='7'></a>
### *os.path 和 sys.path*

`os.path` 是对系统路径文件的操作  
`sys.path` 是对 Python 解释器的系统 **环境参数的操作**  


<a id='8'></a>
### *字典与 JSON*

字典：数据结构，要求 **value 需要 hash**  
JSON：数据的表现形式，要求 **value 是字符串**，用双引号  


<a id='9'></a>
### *可变、不可变类型*

可变，内存中的值可以改变，例如：**列表、字典、集合**  
不可变，内存中的值不能改变，例如：数值、字符串、元组  
字典键要求是：不可变对象  


<a id='10'></a>
### *Python 的内存管理*

Python 私有 **堆空间**：存储对象和数据结构  
Python **内存管理器**：堆空间分配  
内置 **垃圾收集器**：回收未使用的内存，并使其可用于堆空间  


<a id='11'></a>
### *模块和包是什么？*

Python 中 **每个代码文件都是模块**，模块可以引用其他模块  
**包中含有多个代码文件**，里面可以包含模块和子文件夹  


<a id='12'></a>
### *类方法、类实例方法、静态方法*

类方法：类对象的方法，使用 "@classmethod" 来装饰，形参为 cls  
类实例方法：类实例化对象的方法，形参为 self，指代对象本身  
静态方法：使用 "@staticmethod" 来装饰  


<a id='13'></a>
### *内存管理机制、调优手段*

涉及到引用计数、垃圾回收、内存池

- 引用计数  
    高效，当一个对象被引用时，其引用计数增加 1，不再被引用就减 1，直到为 0 时对象被删除
    
    > 注意  
    若出现 **循环引用，则该机制不起效果**  

- 垃圾回收  
    涉及到引用计数、标记清除、分代回收  
    1、引用计数为 0 时，说明需要被当作垃圾回收了  
    2、标记清除用于 **摘掉循环引用**，得到真实的有效计数。例如两个对象的引用计数都为  1，但是仅存在它们之间的循环引用，说明二者都是需要被回收的  
    3、分代回收，当一个内存块中的垃圾 **回收次数多但是仍旧有垃圾**  存在时，可以考虑和其他的分开处理，**隔一段时间再去回收**，使得处理次数减少，提高效率  

- 内存池  
    1、Python 内存机制呈现金字塔形状，第 -1、-2 层主要由 **操作系统** 来操作  
    2、第 0 层是 C 语言中的 **malloc 和 free** 等内存申请、释放函数来操作  
    3、第 3 层是最上层，Python 对象直接操作  
    由于 Python 在运行期间会 **频繁的执行 malloc 和 free** 操作，这会影响执行效率，所以引入内存池机制用来 **管理对小块内存的申请和释放**。这个小块内存的标准是 256 个字节，小于等于它则在内存池申请，大于它则需要调用 malloc 函数。当然可以通过修改源代码来更改 256 这个值  


<a id='14'></a>
### *内存泄漏*

指的是由于疏忽或错误造成的 **程序未能释放已经不再使用的内存** 的情况  
这会导致程序运行 **速度减慢，系统崩溃** 等  
如何防止：当一个对象不使用时，通过 `del object` 来删除它的 **引用计数**  
获取对象的引用计数：`sys.getrefcount(object)` 并根据返回值来判断内存是否泄漏  


<a id='15'></a>
### *函数调用时，参数传递的方式*

- 参数是 **不可变** 类型时：值传递  
    只能通过 **拷贝** 来进行传递，因为原处不可修改  

- 参数是 **可变** 类型时：引用传递  


<a id='16'></a>
### *pass 语句*

编写代码时只写框架思路，先用 pass 占位，程序不会报错


<a id='17'></a>
### *super() 作用*

`super()` 是用来解决 **多重继承** 问题的  
单继承的情况下，直接用 **类名调用父类**（Base类）的方法是没问题的  
多继承的情况下，会涉及到 **查找顺序（MRO）、重复调用（钻石继承）** 的问题  


<a id='18'></a>
### *回调函数*

把函数的指针作为参数传递给另一个函数  
简单讲就是一个函数作为另一个函数的参数被传入，那么这个函数叫做回调函数  


<a id='19'></a>
### *方法重载、方法重写*

重载：在同一个类里面，**方法名字相同，参数不同**。让类以统一的方式处理不同类型数据  
> 为了使得方法能够处理不同类型的数据  

重写：**子类继承父类的方法** 并进行一定的修改，又叫方法覆盖  
> 继承并进行一定的修改  


<a id='20'></a>
### *函数装饰器的用途*

装饰器本质上是一个 Python 函数，返回值也是 Python 对象  
作用是让其他函数在 **不需要做改动下增加额外的功能**，减少与函数功能本身无关的雷同代码  
用于有 **切面需求** 的场景：插入日志、性能测试、事务处理、缓存、权限校验等等  
要求函数可以当作参数传递  


<a id='21'></a>
### *生成器、迭代器*

Python 中的 list、dict、tuple 也被称为 **容器对象**  

- 迭代器  
    假设 for 循环遍历一个容器对象，for 语句对容器对象 **调用 `iter()`** 方法，这会返回一个 **定义了 `next()` 方法的迭代器对象**，这个迭代器对象逐个访问容器内的元素  

- 生成器  
    用于 **创建迭代器**。在需要 **返回数据** 的时候执行 `yield` 语句  

区别：生成器能实现迭代器的功能，简洁、高效、节省内存  


<a id='22'></a>
### *is 与 ==*

`a is b`，通过比较两个对象的内存地址（即使用id()函数返回的唯一标识）来判断它们是否引用同一个对象  
`a == b`，比较两个对象的值  

> 注意  
对于 **小整数和一些短字符串**，Python 会对它们进行缓存以提高性能，使得两个相同值的对象实际上是同一个对象，这种情况下使用is 运算符比较结果会是 True  
对于大整数或长字符串等，则不会进行缓存  


<a id='23'></a>
### *面向过程、面向对象*

二者是 **程序设计方法**，各有其适用的场景和优劣  
面向过程：基于功能分析，以算法为中心，**将问题分解为一系列的步骤和函数** 进行处理。它强调按照过程来组织和管理代码  
面向对象：基于结构分析，以数据为中心，**将问题看作一组对象及其相互作用**。它强调通过定义和操作对象来解决问题。其中，**类是面向对象的核心概念**，通过类可以创建具体的对象。面向对象编程具有封装、继承和多态这三个重要特性  

> 封装（Encapsulation）  
将数据和操作封装到一个对象中，对外界隐藏内部实现的细节，只提供有限的接口进行访问和操作  
继承（Inheritance）  
允许通过定义新类来继承和扩展现有类的属性和方法。继承可以创建类之间的父子关系，子类可以继承父类的属性和方法，并且可以根据需求进行修改和扩展  
多态（Polymorphism）  
允许将不同类型的对象当作相同类型的对象对待，通过多态性可以实现 **同一个接口实现不同的行为**。多态性提高了代码的灵活性和可扩展性  


<a id='24'></a>
### *GET 与 POST*

是 HTTP 协议中的两种常见的请求方法  
GET：用于从指定的资源请求（**获取**）数据  
POST：用于向指定的资源提交（**发送**）被处理的数据，例如 **提交表单** 数据或发送包含敏感信息的数据  
相对于 GET 方法，POST 方法 **将数据放在请求的消息体中**，而不是显示在 URL 中，因此 POST 方法相对来说 **更具有隐蔽性**  

