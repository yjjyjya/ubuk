{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 做一些记录，方便回看或者分享点击左上角四条横杠后打开侧边栏，可以进行内容搜索部分文章前面有目录 添加了一些第三方插件 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-09 23:36:18 "},"stipulation.html":{"url":"stipulation.html","title":"文档书写格式约定","keywords":"","body":"目录 - []() - []() - []() - []() - []() ...... &emsp; 可以实现两个空格的缩进 模板 ✨参考资料 ✨标题1 hello world 图片的插入 flexible-alerts 插件使用说明 > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 > [!NOTE|style:flat] > An alert of type 'note' using alert specific style 'flat' which overrides global style 'callout'. > [!TIP|style:flat|label:My own heading|iconVisibility:hidden] > An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. > **[!WARNING] For warning** > Use this for warning messages. > **[!DANGER] For danger** > Use this for danger messages. 例如 [!NOTE|style:flat] 每个大标题与前面的内容隔 2 行大标题之间用分割线隔开小标题如若再细分，则使用 bullet 的形式代码块前后空 1 行，并且尽量标注上所属语言：支持高亮的包括 html、css、js、batch、docker、git、json、yaml、matlab、sql、python 等表格的前后空 1 行中文和英文之间最好有空格隔开遇到需要对比的时候，可以考虑使用表格存在疑问的内容，可以询问 AI accordion 插件使用说明 %accordion% 模块标题 %accordion% - 内容部分第1行 - 内容部分第2行 - 内容部分第3行 - 内容部分第4行 - 内容部分第5行 %/accordion% 例如 %accordion% 点击展开 %accordion% 我是python代码： print('hello world') %/accordion% ⭕ 标题2 hello world 🔘 标题3 hello world .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-16 23:47:09 "},"about_History/":{"url":"about_History/","title":"历史小记","keywords":"","body":"About History 中国近代史简记 会议概念理清 世界战争简记 中东 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-03 22:34:36 "},"about_History/中国近代史.html":{"url":"about_History/中国近代史.html","title":"中国近代史简记","keywords":"","body":" ✨参考资料 https://www.gov.cn/guoqing/2020-10/29/content_5555766.htmhttps://www.iodraw.com/mindhttps://photokit.com/colors/color-wheel/?lang=zh ✨旧民主主义革命阶段 ⭕ 鸦片战争 原本中国是 独立自主的封建国家当时中国的自然经济处于统治地位，中英贸易中处于出超地位 [!NOTE|style:flat] 贸易出超：即贸易顺差，一定时间内出口额 > 进口额，收支盈余贸易入超：即贸易逆差，一定时间内出口额 英国不法商人使坏，向中国走私鸦片，给我国带来深重灾难林则徐（开眼看世界第一人）在广州发起禁烟运动，在虎门集中销毁鸦片英国于 1840 年发动鸦片战争，1842 年清政府被迫签订 《南京条约》，中国主权独立和领土完整开始遭到破坏 之后 1856~1860 年间，英法为了扩大侵略权益，发动第二次鸦片战争，美俄趁火打劫，期间又签订了一系列条约 ⭕ 太平天国运动 第一次鸦片战争激化了国内的阶级矛盾，出现农民起义1851 年 洪秀全 发动金田起义，建立太平天国政权，前期政权势力不断强大，沉痛打击了清王朝的封建统治但是后期内部矛盾显现，经 天京事变 后，太平天国元气大伤1864 年，太平天国运动在中外势力的绞杀下失败 ⭕ 阶级的产生 19 世纪 40 年代，无产阶级产生，其具有最坚决、最彻底的革命性 19 世纪 60~70 年代，民族资产阶级 产生 一些领导人主张学习西方资本主义，探索发展中国的道路19 世纪 60~90 年代，洋务运动，口号：自强、求富。魏源在《海国图志》中提出 “师夷长技以制夷”这场运动客观上刺激中国的资本主义发展，促进近代化历程 ⭕ 民族危机加深 1894 年，甲午中日战争 爆发，中日签订 《马关条约》，给人民带来沉重负担，大大加深中国的半殖民地化之后帝国主义列强掀起瓜分中国的浪潮 ⭕ 戊戌变法、义和团运动 随着危机加深，民族资产阶级作为新的政治力量登上历史舞台以康有为、梁启超为首的 资产阶级维新派 发起爱国的 戊戌变法（或叫维新变法）运动，后面由于慈禧太后为首的封建守旧势力的政变而以失败告终这场资产阶级改良运动，在社会上起到 思想启蒙 的作用 1900 年夏，八国联军侵华义和团运动 是一场反帝爱国的农民运动，口号：扶清灭洋虽然最终运动失败，但是粉碎了帝国主义列强企图瓜分中国的狂妄计划，也一定程度上加速了清政府的灭亡之后与十一个国家签订了丧权辱国的 《辛丑条约》，标志着 中国半殖民地半封建社会的形成 ⭕ 辛亥革命 1894 年，孙中山 创立兴中会 —— 中国第一个资产阶级革命团体1905 年，中国同盟会成立，标志着中国 资产阶级民主革命 进入一个新的阶段1911 年 10 月，武昌起义 成功 1912 年元旦，孙中山在南京就任临时大总统，宣告 中华民国 成立，颁布了《中华民国临时约法》，这意味着中国两千多年的封建专制主义的君主制度被推翻了！资产阶级民主共和国之下，人民拥有了一些自由和民主的权利，打击了列强在中国的殖民统治但是，由于中国资产阶级的软弱和局限性，他们 不愿意同帝国主义完全裂决，也无法依靠、发动人民进行彻底的社会革命，所以这场运动并没有完全完成反帝反封建 ⭕ 北洋军阀 1912 年，袁世凯 篡夺了辛亥革命的果实，就任临时大总统，并将临时政府迁往北京。以袁世凯为首的北洋军阀政权 产生袁世凯对内镇压国民党，对外出卖国家主权。在孙中山号召下，“二次革命”开始，但是不久便失败之后袁世凯开始 复辟封建帝制，1915 年的 护国运动 爆发后才得以取消袁世凯死后，出现了 军阀割据 的局面 [!NOTE|style:flat] 当时正处于一战时期，帝国主义忙于战争，中国的民族企业得到短暂的发展 ✨新民主主义革命阶段 ⭕ 五四运动 新文化运动 产生的背景：资本主义经济进一步发展，资产阶级要求在中国实行 资产阶级民主政治，反对封建军阀统治兴起的标志：1915 年，陈独秀 在上海创办《新青年》口号：民主、科学 俄国 十月革命 胜利，李大钊 在国内宣传十月革命，中国第一次举起社会主义大旗，新文化运动有了新的发展 1919 年，北京，五四运动 爆发导火索：巴黎和会上拒绝了中国代表的正义要求，把战败国在中国山东的权益转让给了日本，人民义愤填膺意义：中国新民主主义革命的开端 ⭕ 中国共产党成立 五四运动后，马克思主义 在中国传开，马克思主义和 工人运动 初步结合首先在 1920 年共产党小组相继成立，终于，在 1921 年 中共一大 召开，中国共产党正式成立 ⭕ 第一次国共合作、北伐战争 1923 年，二七惨案，军阀 吴佩孚 武力镇压罢工的工人，造成震惊中外的流血事件中国共产党意识到，仅靠工人阶级的力量是不够的1924 年 1 月，国民党“一大” 召开，标志着 国共两党合作的实现、革命统一战线的正式建立之后 国民大革命，反帝爱国运动接连不断，影响最大的有：五卅运动、省港大罢工等等 1925 年 7 月，国民政府在广州成立，所属军队编为 国民革命军1926 年 7 月，国民政府誓师北伐，北伐战争 最后取得胜利 1925 年 3 月孙中山逝世，国民党右派 加速争夺革命领导权，1927 年后一再发动反革命政变1927 年 5 月，汪精卫 在武汉发动 七一五政变，标志着第一次国共合作破裂 ⭕ 国共十年对峙 国民政府形式上统一了中国，但是 新军阀的混战 却给人民带来了极大的灾难凭借政权迅速聚敛巨额财富，成为了 官僚买办资产阶级 的代表 1927 年，中国共产党召开 八七会议，纠正右倾投降主义错误并接连发动了南昌起义、秋收起义、广州起义，创建了 红军，开辟了 农村根据地，进行了 土地改革，创建了 中国苏维埃政权开辟 农村包围城市，武装夺取政权的道路 1930 年~1933 年，蒋介石对革命根据地发动了四次围剿，红军取得了四次反围剿的胜利！第五次围剿时，王明左倾错误，红军反围剿失利，被迫 长征长征期间，举行了 遵义会议，毛泽东 带领红军取得长征的胜利 1932 年 12 月 12 日，西安事变，中国共产党最终决定和平解决西安事变，这开启了国共两党合作的第二次可能，也标志着抗日民族统一战线的初步形成 ⭕ 抗日战争 1931 年，日本在 沈阳 发动 九一八事变，挑起侵华战争。但是当时国民党政府奉行 不抵抗政策不到半年的时间，东北三省全部沦陷，国内必然掀起抗日救亡的怒潮 1935 年，日本在华北蓄意制造了一系列事端，威逼平津1935 年 12 月，中共中央在 瓦窑堡 召开会议，制定 抗日民族统一战线 的方针 1937 年 7 月 7 日，日军制造 卢沟桥事变，全国抗日战争爆发抗战期间，八路军、新四军深入敌后，开辟敌后战场，开展游击战，与国民党军队的正面战场相互配合 1941 年 12 月，太平洋战争 爆发，中国抗日战争成为世界反法西斯战争的重要组成部分1945 年 8 月 15 日，日本政府宣布无条件投降，9 月 2 日在美国战列舰上签订无条件投降书14 年艰苦奋战，最终取得伟大胜利 ⭕ 解放战争 抗日战争胜利后，为了国内和平，1945 年毛主席赴 重庆谈判，10 月 10 日国共签订《双十协定》1946 年 1 月，重庆，政治协商会议 召开 1946 年夏，全面内战 爆发，国民党军队在美国的支持下向解放区发起进攻1948 年~1949 年，辽沈、淮海、平津三大战役，基本消灭了国民党军队的主力1949 年 4 月，渡江战役 解放了南京，推翻了国民党的统治 1949 年 9 月，第一届全国人民政治协商会议 在北平召开会议选举毛泽东作为中央人民政府主席北平作为首都，更名北京 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-27 21:17:10 "},"about_History/会议概念理清.html":{"url":"about_History/会议概念理清.html","title":"会议概念理清","keywords":"","body":" ✨参考资料 https://zhidao.baidu.com/question/127955246.html ✨常见名词 ⭕ 全国人民代表大会 简称：全国人大每年的第一季度 召开一次，每届 全国人大代表 任期 5 年（这意味着每一届全国人大代表将经历至少 5 次的全国人大） 形如：第几届全国人民代表大会第几次会议例如：第一届全国人民代表大会第五次会议 [!NOTE|style:flat] 全国人民代表大会是 我国最高 的权力机关 ⭕ 党的全国代表大会 简称：党代会一般每 5 年召开一次 形如：中共几大 / 党的几大例如：中共二十大 / 党的二十大 [!NOTE|style:flat] 党的全国代表大会是 党的最高 权力机关 主要内容：选举产生新一届的 中央委员会（第几次党代会选出来的就叫几届中央委员会），探讨政治经济问题，总书记作政治报告 ⭕ 党的中央委员会议 简称：中央全会一般 每年 召开一次 形如：几中全会例如：三中全会 [!NOTE|style:flat] 几届几中全会其中的 几届 是指当时的中央委员会的届数几中 是指第几次全会（一般一届中央委员会能开 5~6 次全会） 主要内容：选举产生新一届的 中央领导班子，探讨当时的重要问题 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-27 21:45:01 "},"about_History/世界战争简记.html":{"url":"about_History/世界战争简记.html","title":"世界战争简记","keywords":"","body":" ✨参考资料 https://zhuanlan.zhihu.com/p/472849185https://zhuanlan.zhihu.com/p/469785892 https://news.ifeng.com/history/special/zhongdongzhanzheng/https://zhuanlan.zhihu.com/p/386130854https://zhuanlan.zhihu.com/p/355752880 ✨近代一些战役 ⭕ 第二次世界大战 时间段在 1939 ~ 1945 年大约有 7000 万人遇难，其中包括士兵、平民、大屠杀（假设 1 平方米的面积可以站 4 个人，那么三个半足球场可以站 10 万人，7000 万人需要 2450 个足球场） 两大阵营 法西斯轴心国 德、意、日等 仆从国有：保加利亚、匈牙利、罗马尼亚等 反法西斯同盟国 美、苏、英、法、中华民国等 各国的指挥官： 美 苏 英 法 中 德 意 日 罗斯福 斯大林 丘吉尔 戴高乐等人 蒋介石 希特勒 墨索里尼 裕仁天皇、东条英机 开始标志：德国闪击波兰 转折点：斯大林格勒保卫战，中途岛战役 最终，反法西斯同盟国和世界人民一起赢得了胜利 ⭕ 中东战争 中东连接着欧亚非三个大陆板块，是人类古老文明的摇篮一百多年前的中东是一个大一统帝国——奥斯曼帝国，后来由于一战爆发，作为盟约国的奥斯曼帝国输了，被瓜分肢解，仅剩土耳其一隅。故中东陆续独立出来如今的诸国，由于当时各国的分界线是一战战胜国英法私下谈判的，这为后来中东多国的宗教、种族之间的冲突埋下了隐患 总共 5 次 第一次：巴以冲突1948 ~ 1949 年公元前13世纪，犹太人迁入耶路撒冷定居 公元66年，罗马帝国统治后，将耶路撒冷所在行省改为巴勒斯坦，并驱逐了部分的犹太人 公元7世纪，阿拉伯人占领巴勒斯坦 1914年一战爆发后，巴勒斯坦的统治者奥斯曼帝国和德意志联盟开始驱逐犹太人。犹太人转而帮助英国，英国政府承若战后会帮助犹太人独立，但是之后并没有履行承诺 1945年二战结束后，欧洲各地的集中营放出大量的犹太难民，西方各国不愿接受难民，英国苦于移民控制的压力，将巴勒斯坦的控制问题交给联合国 1947年，联合国同意阿拉伯人和犹太人在巴勒斯坦上各自建立国家。但是阿拉伯人不接受这个决议，因为由于犹太人一直购买土地，所以阿拉伯人人多且土地少，犹太人人少且沿海肥沃土地多 1948年，犹太人单方面宣布成立犹太国，定名为以色列。但是就在第二天，周围的阿拉伯联盟国家：埃及、伊拉克、黎巴嫩、叙利亚、约旦的军队就向以色列宣战，巴以冲突爆发 但是之后世界各地的犹太人集结以色列，美国的犹太财团筹集资金购买军事装备，短短几周内以色列就诞生了正规的国防军 此时美英站巴勒斯坦，苏联站以色列这边，提供军火，帮助训练军队 由于阿拉伯联盟国家内部矛盾，加上以色列犹太人的经济实力，巴勒斯坦的阿拉伯人势力范围逐渐缩小 第二次：两伊战争伊拉克挑事袭击伊朗，伊朗反击 伊拉克掌权人萨达姆抓住伊朗内部政权不稳定，闹革命，想要挑事主要有三个目的：1、想要获取两伊交界地带的阿拉伯河的出海段2、防止伊朗输出革命，伊朗的伊斯兰教中的“什叶派”革命成功，伊拉克担心自己被渗透3、伊朗的波斯人，伊拉克的阿拉伯人，各自国家的人民在对方国家内部被欺凌 持续8年的两伊战争，双方损失惨重，民不聊生，最终局面没有什么变化 第三次：海湾战争两伊战争中，伊拉克因为战争欠了很多外债。故想要减少石油产量，使得石油价格上涨，赚钱还债；而邻国的科威特（依赖美国）反其道而行之萨达姆将自己展示为一个敢于反抗以色列和美国的政治家，趁着国际局势动荡，打算占领吞并科威特萨达姆认为美国不会轻易出手，因为朝鲜战争和越南战争的原因，美国国内反战情绪严重迫于压力，美国同意通过谈判解决问题，但是萨达姆的态度却更加强硬，这一举动使得美国民意反弹，美国直接对伊拉克进行军事行动这一战，美国展现了强大的实力，是一场现代高科技战争。死亡人数比例为 286:100000 此战之后，中国裁军近100万，省下的钱用于高科技武器研制的投入，并进行军事武器、思想、理论的改革 第四次：阿富汗战争美国反恐战争 2001年9月11日，美国纽约世界贸易中心两栋大楼被恐怖分子袭击 美国对阿富汗基地组织和塔利班进行报复战争，目的是逮捕本拉登和基地组织的成员 塔利班建立的初心是为了抵御当时苏联红军的入侵，苏军退兵后，转而将目标定为美国和伊斯兰世界的腐败组织 阿富汗战争持续十余年，在2011年，美军在巴基斯坦将本拉登击毙 第五次：伊拉克战争2003年，美国单方面对伊拉克实施军事打击 原因是称伊拉克藏有大规模杀伤性生化武器 但直到伊拉克战争结束，都没有找到一方面是萨达姆的行为太过猖狂，不断和美国叫嚣；另一方面美国可以震慑中东的其他国家 ⭕ 朝鲜战争 ⭕ 越南战争 ⭕ 中印边境战争 ⭕ 中越边境战争 ⭕ 东欧剧变 ⭕ 海湾战争 ⭕ 前南斯拉夫解体、苏联解体 ⭕ 科索沃战争 ⭕ 阿富汗战争 ⭕ 伊拉克战争 ⭕ 俄罗斯-格鲁吉亚战争 ⭕ 利比亚战争 ⭕ 叙利亚内战 ⭕ 俄乌冲突 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-27 21:48:10 "},"about_History/中东.html":{"url":"about_History/中东.html","title":"中东","keywords":"","body":"巴以的局面很明显的发生反转 以色列宣布建国的第二天，周围的阿拉伯国家就向其宣战 苏联和美国站在以色列这一边 当时以色列军人的装备还很落后 埃及 参考资料 https://zhuanlan.zhihu.com/p/386130854 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-10-16 22:54:21 "},"about_Python/":{"url":"about_Python/","title":"Python 整理","keywords":"","body":"About Python 学习1 学习2 常见问题 Django框架 机器学习 深度学习 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-17 18:16:26 "},"about_Python/python_tutorial1.html":{"url":"about_Python/python_tutorial1.html","title":"学习1","keywords":"","body":" ✨参考资料 黑马 Python 教程：https://github.com/cess-100/python-study ✨基础知识 ⭕ hello world print(\"hello world\") ⭕ 注释 # 单行注释 ''' 多行注释 第一行注释 第二行注释 第三行注释 ''' 选中代码后，可以使用快捷键 ctrl + / 进行注释 ⭕ 数据类型 🔘 常见数据类型 # int 整型 a = 1 print(type(a)) # float 浮点型 b = 1.1 print(type(b)) # bool 布尔型 c = True print(type(c)) # str 字符串 d = '12345' print(type(d)) # list 列表 e = [10, 20, 30] print(type(e)) # tuple 元组 f = (10, 20, 30) print(type(f)) # set 集合 h = {10, 20, 30} print(type(h)) # dict 字典 j = {\"name\": \"TOM\", \"age\": 18} print(type(j)) 🔘 类型转换 # 转换成浮点型 num1 = 1 str1 = '10' print(type(float(num1))) # float print(float(num1)) # 1.0 print(float(str1)) # 10.0 # 整型转换成字符串类型 print(type(str(num1))) # str # 序列转换成元组 list1 = [10, 20, 30] print(tuple(list1)) # (10, 20, 30) # 序列转换成列表 t1 = (100, 200, 300) print(list(t1)) # [100, 200, 300] # eval() 将字符串中的数据转换成 Python 表达式原本类型 str2 = '1' str3 = '1.1' str4 = '(1000, 2000, 3000)' str5 = '[1000, 2000, 3000]' print(eval(str2)) # 1 print(eval(str3)) # 1.1 print(eval(str4)) # (1000, 2000, 3000) print(eval(str5)) # [1000, 2000, 3000] ⭕ 字符串 # 三对双引号定义的字符串支持回车换行 d = \"\"\"I am tom\"\"\" print(type(d)) print(d) f = 'I\\'m tom' # 注意转义字符 \\ print(type(f)) print(f) 🔘 字符串切片 tmp = 'abcdefg' print(tmp[:-2]) # 'abcde' # print(tmp[-4:-1:-1]) # 报错 print(tmp[-1:-4:-1]) # 'gfe' 上述报错的代码中，下标 -4 到 -1 选取是从左到右，而步长取 -1，表示从右向左，所以选不出数据 [!NOTE|style:flat] 选取方向与步长方向不一致就选不出来 🔘 字符串的其他操作 mystr = \"hello world and cess and success and Python\" # find() print(mystr.find('and')) # 12 print(mystr.find('and', 15, 30)) # 21 print(mystr.find('ands')) # 没找到，但是返回 -1 # index() print(mystr.index('and')) # 12 print(mystr.index('and', 15, 30)) # 21 # print(mystr.index('ands', 15, 30)) # 直接报错 # count() print(mystr.count('and')) # 3 print(mystr.count('and', 15, 30)) # 1 print(mystr.count('ands')) # 0 # rfind 和 rindex 同理，只是从右往左查询 # 列表也可以进行 index 和 count new_str = mystr.replace('and', 'he', 10) #只将前 10 个 and 替换成 he # 字符串是不可变数据类型，所以只能重新赋值给新的变量 list2 = mystr.split('and', 2) #只分割前 2 个 and print(mystr.capitalize()) # 首字母大写，其他都改小写 print(mystr.title()) # 每个单词首字母均大写 print(mystr.lower()) # 全部小写 print(mystr.upper()) # 全部大写 print(mystr.lstrip()) # 删除左侧空白 print(mystr.rstrip()) # 删除右侧空白 print(mystr.strip()) # 删除两侧空白 .startwith() #字符串以什么开头 .endwith() #字符串以什么结尾 .isalpha() #是否全为字母 .isdigit() #是否全为数字 .isalnum() #是否字母或数字 .isspace() #是否全为空格 mystr = 'hello' # ljust() 左对齐 print(mystr.ljust(10, '*')) # hello***** # rjust() 右对齐 print(mystr.rjust(10, '*')) # *****hello # center() 居中，偶数则左侧少点 print(mystr.center(20, '*')) # **hello*** a = ['172', '168', '1', '1'] b = ['2022', '01', '01'] c = 'Hello' d = 'World' e = [1,2,3] f = [4,5,6] '.'.join(a) # 172.168.1.1 '/'.join(b) # 2022/01/01 c+d # HelloWorld e+f # [1, 2, 3, 4, 5, 6] e.append(f) # [1, 2, 3, [4, 5, 6]] e.extend(f) # [1, 2, 3, 4, 5, 6] ⭕ 列表 列表是可变类型，可以修改其内部的元素 🔘 列表的增删元素 # append 添加元素 name_list = ['tom', 'lily'] name_list.append('big') print(name_list) # extend 追加元素 name_list = ['tom', 'lily'] name_list.extend('big') # 'big' 会被分成一个一个字符导入 print(name_list) name_list = ['tom', 'lily'] name_list.extend(['big']) # 注意传入的是列表 print(name_list) # insert 指定下标添加 name_list = ['tom', 'lily'] name_list.insert(1, 'big') print(name_list) # 删除元素 namelist = ['tom', 'lily', 'big'] del namelist[2] print(namelist) namelist = ['tom', 'lily', 'big'] namelist.pop(-1) #若不指定下标，则默认弹出最后一个元素 print(namelist) namelist = ['tom', 'lily', 'big'] namelist.remove('big') #删除指定元素 print(namelist) # 清空链表 namelist = ['tom', 'lily', 'big'] namelist.clear() print(namelist) # 删除链表 namelist = ['tom', 'lily', 'big'] del namelist # print(namelist) #name 'namelist' is not defined 🔘 列表的其他操作 # 判断某元素是否在列表内 'hello' in ['hello', 'world', '!!!'] # 逆序列表 .reverse() # 原地排序 .sort(key= , reverse=) [!NOTE|style:flat] 对于列表的遍历，优先选择 for 循环，而不是 while 循环 # 嵌套列表 name_list = [['小明', '小红', '小绿'], ['Tom', 'Lily', 'Rose'], ['张三', '李李四', '王五']] print(name_list[0]) # ['小明', '小红', '小绿'] print(name_list[1][1]) # Lily # numpy 数组切片 import numpy as np a = np.arange(9).reshape(3,3) a1 = a[:2, 1:] a2 = a[2] # 取出第 3 行 a3 = a[2, :] # 等价于 a2 a3 = a[[2], :] # 等价于 a2 # enumerate 函数 list1 = ['a', 'b', 'c', 'd', 'e'] for index, value in enumerate(list1, start=1): print(\"%d, %s\" % (index, value)) ⭕ 元组 元组是不可变类型 # 多个数据元组 t1 = (10, 20, 30) print(type(t1)) # # 单个数据元组 t2 = (10,) print(type(t2)) # t3 = (10) print(type(t3)) # [!NOTE|style:flat] 上述单个数据元组，若不加逗号，类型为 int 元组也有下标，也可以使用 index 和 count 方法不能直接对元组的元素进行修改，但是若元组中存放了列表，则可以对列表的内部元素进行修改 ⭕ 字典 # 定义字典的方法： # 1、花括号中存放键值对 {'': , '': , } # 2、将序列 zip 后，利用关键词 dict 转换成字典 dict(zip( , )) 🔘 字典常用操作 添加和删除元素 # 字典新增元素 dict1 = {'name': 'tom', 'age': 20, 'gender': '男'} dict1['id'] = 110 print(dict1) # 删除指定的键值对 del dict1['age'] print(dict1) # 同样可以像列表一样 clear 和删除 获取字典元素 # 可以直接通过中括号访问，但是若字典中找不到对应的 key 就会报错 print(dict1.get('id', '001')) # get 方法在找不到 key 的时候会返回指定的默认值 循环遍历字典 for key in dict1.keys(): for value in dict1.values(): for k, v in dict1.items(): # 创建字典的时候不用担心括号类型 a = [['hello', 3], ['world', 5]] b = [['hello', 3], ('world', 5)] c = (['hello', 3], ('world', 5)) d = (('hello', 3), ('world', 5)) print(dict(a)) print(dict(b)) print(dict(c)) print(dict(d)) 🔘 字典与 json 格式 import json # loads 方法可以理解为将字符串类型转换成字典 # 注意里面的键值用的是双引号 json_data = '{\"name\": \"Mike\", \"age\": \"30\"}' dict_data = json.loads(json_data) # dumps 方法将字典转换成字符串类型 dict_data = {\"name\": \"Mike\", \"age\": \"30\"} json_data = json.dumps(dict_data) ⭕ 集合 集合，没有顺序（意味着没有下标），不可切片自动去重 [!NOTE|style:flat] 注意：集合本身是可变对象，但是里面的元素是不可变对象 # 创建集合 set() # 注意： s = set('abcdefg') print(s) # {'e', 'c', 'f', 'd', 'g', 'a', 'b'} 🔘 set 集合常用操作 添加删除元素 s1 = {10, 20} s1.add(100) print(s1) # s1.add([11,22,33]) #会报错，若需要往集合中一次性追加多个元素，请使用 update s1.update([11,22,33,]) print(s1) # 删除集合中的元素，即使没有对应的元素也不会报错 s1.discard(33) 还有 pop、remove 方法 同样可以使用 in 或者 not in 判断数据是否在集合中列表、元组、集合可以通过关键字相互转换 list() tuple() set() [!NOTE|style:flat] 字符串、列表、元组都支持加号合并也都支持乘号翻倍字符串、列表、元组、集合、字典都支持通过 len() 求得长度 ⭕ 格式化输出 🔘 format 函数 print(\"Batch: {:010}, Loss: {:.2f}, Accuracy: {:.2%}\".format(123, 0.1234567, 0.89)) print(\"Batch: {:10}, Loss: {:.2f}, Accuracy: {:.2%}\".format(123, 0.1234567, 0.89)) :10 表示输出的字符串长度为 10，由于值为 123，所以前面加了 7 个空格。注意若是 :1 或者 :2，小于 3 的，不影响结果:.2f 表示保留两位小数，四舍五入:.2% 将数据转换成百分比的形式，并保留两位小数 ⭕ 输入 input 会阻塞以等待用户输入，输入完成之后程序才继续向下执行在 Python 中，input 会把接收到的任意用户输入的数据都当做 字符串 处理 练习示例： password = input('请输出您的密码：') print(f'您输入的密码是{password}') print(type(password)) # str ⭕ 常见运算符 加减乘除乘方开方等等 🔘 矩阵乘法 import numpy as np # 矩阵点乘，对应元素相乘 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) b = np.array([[1, 2, 3]]) result = a * b print(result) 🔘 逻辑运算 若 (lens & 1) == 0，意味着 lens 的二进制表示的最低位为 0，因此它对应的十进制数是偶数这是一种利用位运算来 判断一个数是否为偶数 的常用方法 ⭕ 三目运算符 a = 1 b = 2 c = a if a > b else b #如果a大于b，则将a赋值给c，否则将b赋值给c print(c) tmp = [66,9,31,2,3,34,13,4,78,8,55] # 递推表达式 # result = [1 for i in tmp if i>10] result = [1 if i>10 else 0 for i in tmp] print(result) # 此外还支持多重 for 循环的递推表达式 # 不只列表支持这个表达式，字典、集合也可以类似地这样写 ⭕ 条件语句 练习示例 import random # 玩家出拳 player = int(input('请出拳：0-石头，1-剪刀，2-布')) # 电脑出拳 computer = random.randint(0, 2) print(f'电脑出{computer}') # 判断输赢 if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0): print('玩家获胜') elif player == computer: print('平局') else: print('电脑获胜') # 此外，条件语句还可以嵌套 [!NOTE|style:flat] a = [1,2,3,4,5,6,7,11] if a.pop() ⭕ while 循环 练习示例 # 循环打印九九乘法表 i = 1 while i 🔘 while ... else ... while 条件: 条件成立时需要重复执行的代码 else: 循环【正常结束】之后要执行的代码 # 注意若 while 循环体中存在 break 或者 return，那么就不会执行 else 中的内容 # for ... else ... 也是同理 ⭕ 文件操作 文件的访问模式 只读 r rb r+ rb+ 不会新建 文件，没有对应文件就报错 写入 w wb w+ wb+ 会自动新建文件，但是会 先清空 再写入 追加 a ab a+ ab+ 会自动新建文件，末尾追加写入 凡是有 b 就是 二进制格式打开凡是有 + 就变为 可读可写若不指定的话，默认为 r 🔘 文件读取 with open('文件名', 'r') as f: f.read(10) # 10 表示读取【10 字节】的数据，若不指定，则读取全部数据 f.readline() # 只读取【一行】数据 f.readlines() # readlines 按照行的方式把整个文件中的内容进行一次性读取 # 并且返回的是个【列表】，其中每一行的数据为一个元素 f.tell() # 返回当前指针位置，还能控制指针的位置，感兴趣可以深入搜索 将数据写入文件 old_file = open('文件名', 'rb') # 二进制格式读取 new_file = open('文件名', 'wb') # 二进制格式重头写入 while True: content = old_file.read(1024) # 每次读取 1024 字节，即 1KB 的数据 if len(content) == 0: # 满足条件则说明读取完毕 break new_file.write(content) # 将数据写入新文件中 old_file.close() new_file.close() 🔘 os 模块常用文件（夹）操作 import os os.rename(目标文件名, 新文件名) # 文件重命名 os.remove(目标文件名) # 删除文件 os.mkdir(文件夹名字) # 创建文件夹，如果文件夹已存在，则会报错 os.rmdir(文件夹名字) # 删除文件夹，若目录不为空，则无法删除 os.getcwd() # 获取当前目录 os.chdir(目录) # 切换目录 os.listdir(目录) # 获取目录中的文件，返回文件名的列表 ⭕ 函数 函数是一个具有独立功能的代码块可以在需要的位置进行调用实现代码重用 在 Python 中，函数需要先定义后使用 内建函数 Python 提供了很多，比如 print() 自定义函数 1、def 关键字开头 2、传入参数和自变量放在圆括号中间 3、函数的第一行语句可以选择存放一些函数用法说明 4、记得 def 语句后面需要冒号，函数内容需要缩进 5、return 会将结果返回给调用该函数的地方，并且使得程序退出当前函数（层），并且后面的代码都不执行return 后面不加东西相当于返回 None def myfunc(a, b): \"\"\" 函数说明 :param a: 参数1 :param b: 参数2 :return: 返回值 \"\"\" pass help(myfunc) 函数嵌套：一个函数里面调用了另外一个函数 🔘 函数的返回值类型 def return_num2(): return 1, 2 #返回多个值时，默认元组类型，也可以是列表或者字典等等 result = return_num2() #也可以进行解包 print(result) 🔘 函数的参数问题 def user_info(name, age, grade=1): print(f'您的名字是{name}, 年龄{age}, 年级{grade}') # 该函数有三个参数，其中 grade 带了默认值 # 调用函数 user_info('amy', 18, 2) #全部使用【位置参数】进行调用 user_info(name='tom', age=19, grade=3) #全部使用【关键字参数】进行调用 user_info('rola', grade=3, age=18) #【混用】，注意位置参数需要在关键字参数前面 # user_info(name='bob', 18, grade=18) #报错 位置参数要求摆在关键字参数前面，否则会有以下的报错信息： SyntaxError: non-default argument follows default argument. 而关键字参数传入时是带有参数名的，所以前后顺序没有要求 可变参数：args、kwargs*args 和 **kwargs 被称为 匿名参数其中 *args 是 匿名位置参数，args 类型是 元组**kwargs 是 匿名关键字参数，kwargs 类型是 字典用于应对 输入的参数个数不固定 的情况 # 可选择传入或者不传入 def user_info(*args, **kwargs): # **args 收集所有位置参数，并作为一个元组 # **kwargs 收集关键字参数，并作为一个字典 print(args) print(kwargs) # 都是⼀个组包的过程 user_info('TOM', 18, id='001', grade=3) # ('TOM', 18) # {id:'001', grade:3} partial() 方法 在调用函数的时候，用于给参数设置固定的值 from functools import partial def test(a, b, c, d): print(a, b, c, d) # 一般实例化 s1 = test(1, 2, 3, 4) # 利用 partial() 固定参数 s2 = partial(test, a=1) #此时参数 a 被固定 s2(2, 3, 4) #只需要传入参数 b、c、d 有时可以让原本不兼容的代码一起工作 🔘 可变与不可变类型 可变（mutable）类型（记忆可变类型的即可） 列表 字典 集合 不可变（immutable）类型 整型 浮点型 字符串 元组 # 对于不可变类型的变量来说，变量只是指向了值所在的地址 a = 1 b = a print(b) print(id(a)) print(id(b)) # a 和 b 同时指向了值 1 的地址，所以 id 值相同 a = 2 print(b) # 这里的 b 没有随 a 改变，它还是指向原来 1 的地址 print(id(a)) print(id(b)) # 可变类型的变量 aa = [10, 20] bb = aa print(bb) print(id(aa)) print(id(bb)) aa.append(30) print(bb) #这里的 bb 会跟着 aa 改变，因为 aa 是在原地址上进行修改的 print(id(aa)) print(id(bb)) 需要小心注意，Python 中尽量不要将 可变类型 的变量作为参数传入在函数定义时，默认参数的值会保存在函数的定义中，并在每次 函数调用时重用。如果使用可变对象（如列表）作为默认值，可能会导致默认值在函数调用之间意外地被修改，导致程序出错 可变类型传参 例如 fun(list_a)，在函数 fun 内部将 list_a 修改后，函数外部的 list_a 也会受影响 不可变类型传参 例如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。在 fun(a) 内部修改 a 的值，只是修改另一个复制的对象，不会影响函数外部 a 对象本身 def test(a): print(a, id(a)) a += a print(a, id(a)) c = [11, 22] test(c) print(c, id(c)) #这里 c 的值发生了改变 [!NOTE|style:flat] 在 python 中，值是靠 引用 来传递的在函数 定义 中，* 表示 收集 任意多的位置参数在函数 调用 语法中，* 表示 展开 可迭代对象（例如列表、元组等） 🔘 函数递归 注意设置递归终止条件 # 计算 1 到 n 的数字累加和 def sum_numbers(n): if n == 1: return 1 else: return n + sum_numbers(n - 1) sum = sum_numbers(10) print(sum) 🔘 匿名或内联函数 目标：只是想实现一些简单的函数，或者简短的计算表达式lambda 表达式典型的使用场景是 排序或数据 reduce局限：只能指定单个表达式，不能包含其他操作，例如多个语句、条件表达式、迭代以及异常处理等等 fn2 = lambda: 200 print(fn2) print(fn2()) print((lambda a, b:a + b)(1, 2)) # 对英文名进行字典排序 names = ['David Beazley', 'Brian Jones', 'Raymond Hettinger', 'Ned Batchelder'] sorted(names, key=lambda name: name.split(' ')[0].lower()) #可以指定匿名函数中变量的值 x = 2 b = lambda y, x=x: x + y 递推表达式结合匿名函数 ``` pythonhttps://www.zhihu.com/question/56193983 import random a = [[100,200], [300,600], [10,20]] # 方法一 b = [lambda params=values: random.randint(*params) for values in a] # 方法二 b = [] for i in a: b.append( lambda x=i: random.randint(*x) ) b[1]() ``` 🔘 高阶函数 把函数作为参数传入高阶函数是函数式编程的体现 def add_num(a, b, f): return f(a) + f(b) # abs 是内置的求绝对值的函数 # 将其传入我们自定义的函数中来求两个数的绝对值之和 result2 = add_num(-1, 2, abs) print(result2) 部分内置高阶函数： import functools def func1(x): return x ** 2 # map(func, lst) # 将传入的函数变量 func 作用到 lst 变量的【每个元素】 # 如果要转换为列表，可以使用 list() 来转换 list1 = [1, 2, 3, 4, 5] result = map(func1, list1) print(result) print(list(result)) # [1, 4, 9, 16, 25] Python3 的 map 返回的是迭代器，Python2 则是返回列表 # reduce(func(x,y)，lst) # 其中 func 必须有两个参数 # 每次 func 计算的结果继续和序列的下一个元素做累计计算 def func2(a, b): return a + b list2 = [1, 2, 3, 4, 5] result = functools.reduce(func2, list2) #计算 list2 的累加和 print(result) # filter(func, lst) # 用于过滤序列, 过滤掉不符合条件的元素, 返回⼀个 filter 对象 def func3(x): return x % 2 == 0 #返回布尔值，为 True 即满足条件的 list3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] result = filter(func3, list3) print(result) print(list(result)) 函数名是一个特殊的变量，保存了函数的地址 def test(): print(\"哈哈，我是一个寂寞的test！\") test() ret = test #定义变量 ret 获取函数 test 的地址 print(ret) # 可以通过 ret 调用函数 ret() [!NOTE|style:flat] 默认参数的值应该是 不可变对象，比如 None、True、False、数字或字符串最好不要用空列表 [ ]，如需要，则先设默认值为 None，之后再通过 if 条件语句赋以 [ ] 🔘 函数和方法的异同点 1、本质上一样：函数和方法都是用于 完成特定功能的代码块2、调用方式不同：方法是通过 实例化后的对象 进行调用的，因此方法属于特定的实例对象，而不同的实例对象可以调用相同的方法。而函数可以 直接被调用，不需要特定的对象3、参数的不同：在方法定义时，首个参数通常命名为 self，它指向调用该方法的实例对象本身。通过 self 参数，方法可以访问和操作实例对象的属性和方法。而在函数定义时，不需要指定特定的参数，可以根据需要选择是否传入参数 ⭕ 类 自定义类1、类通过 class 关键字定义2、类名通用习惯为首字母大写，见名知意3、Python3 中类基本都会继承于 object 类，也可以不继承，两者区别不大，但后者使用 多继承 时可能会出现问题 内置 __init__() 函数始终在启动类时会自动调用可以使用 __init__() 函数将值赋给对象属性 self在 Python 的类定义中，self 是一个特殊的参数，用于表示实例化后的对象自身约定将 self 作为第一个参数传递给类方法或实例方法。虽然在Python 中，self 这个名称并不是关键字，可以选择其他名称，但是为了遵循约定和与其他 Python 开发者保持一致，一般而言习惯将该参数命名为 self相当于 C++ 里面的 self 指针，Java 里面的 this 关键字。它们都指代当前对象实例本身，并使得对象能够访问自己的属性和方法 🔘 类属性和实例属性 实例属性（对象属性）：不同的实例可以有不同的值 要求 每个对象 为其 单独 开辟一份内存空间来记录数据 属性相当于 class 中的变量，方法相当于函数，class 实例化后，可以进行调用 实例对象调用的本质： a = Student('小明', 95) a.get_score() # | # v # 解释器翻译结果： # Student.get_score(a) 类属性：是每个实例的共有属性 类属性为 全类所共有，仅占用一份内存，更加节省内存空间 要修改类属性，需要通过 类名.类属性 = ... 进行修改 [!NOTE|style:flat] 当要记录某项数据，且该数据始终保持一致时，则可以考虑将其定义为类属性类属性只能通过类对象修改，不能通过实例对象修改 常用的属性 __doc__，类的说明 __dict__，返回对象或者类的信息 Test().__doc__ Test().__dict__ Test().__getattribute__('public') 🔘 类方法 需要用装饰器 @classmethod 来标识其为类方法对于类方法，第一个参数必须是类对象，一般以 cls 作为第一个参数当方法中 需要使用类对象（如访问私有类属性等）时，则考虑定义类方法 class Dog(object): __tooth = 10 #类属性 @classmethod def get_tooth(cls): #类方法一般和类属性配合使用 return cls.__tooth 🔘 静态方法 需要通过装饰器 @staticmethod 来进行修饰静态方法既不需要传递类对象也不需要传递实例对象（不需要形参 cls/self）静态方法能够通过 类对象 和 实例对象 去访问 class Dog(object): @staticmethod def info_print(): print('这是一个Dog类，用于创建Dog实例....') wangcai = Dog() Dog.info_print() # 静态方法能够通过类对象访问 wangcai.info_print() # 静态方法能够通过实例对象访问 ⭕ 面向对象 面向对象的特性 封装 将属性和方法写到类的里面 封装可以为属性和方法添加私有权限 继承 子类默认继承父类的所有属性和方法 子类可以重写父类属性和方法 多态 传入不同的对象，产生不同的结果 class Washer: def __init__(self, width, height): # 添加实例属性 self.width = width self.height = height def __str__(self): # 使用print输出对象，默认打印对象的内存地址 # 如果类定义了__str__ 方法，就会打印从在这个方法中return 的数据 return '这是海尔洗衣机的说明书' def __del__(self): print('对象已被删除') def wash(self): print('洗衣机洗衣服') def print_info(self): print('洗衣机的宽度是%d, 高度是%d' % (self.width, self.height)) # 创建Washer类对象 haier1 = Washer(10, 20) # 不传参数会报错 # 使用对象带有的方法 haier1.wash() # 添加属性 haier1.price = 3000 名字两侧带有双下划线的函数叫做魔法方法，指的是具有 特殊功能 的函数，例如：__init__() 在创建⼀个对象时默认被调用，不需要手动调用__init__(self) 中的 self 参数，python 解释器会自动把 当前的对象引用 传递过去删除对象时，python 解释器会默认调用 __del__() 方法 经典类 没有显式地继承自任何类 默认继承自一个名为 object 的基类 方法解析顺序是按照 深度优先搜索 的方式进行的 class 类名: pass 新式类 显式地继承自 object 的类 方法解析顺序是按照 广度优先搜索 的方式进行的 class 类名(object): pass 🔘 类的继承问题 # 父类A class A(object): def __init__(self): self.num = 1 def info_print(self): print(self.num) # 子类B 继承父类A class B(A): pass result = B() result.info_print() # 子类默认继承父类的所有属性和方法，而所有类默认继承object类 # object类是顶级类或基类；其他子类叫做派生类 [!NOTE|style:flat] .__mro__ 方法用于查看继承顺序 多继承的情况（注意和 多层继承 进行区别）： class c1(object): class c2(object): class c3(object): class myc(c3, c2, c1): 这里可以重新定义与父类同名的方法/属性，也叫重写方法/属性 print(myc.__mro__) # (, , , , ) # 当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法 子类调用父类方法： # 师傅类 class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print('使用%s制作煎饼果子' % self.kongfu) # 学校类 class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print('使用%s制作煎饼果子' % self.kongfu) # 徒弟类 class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): # 加初始化，是防止上次调用的init方法不是自己的，从而kongfu属性值不是自己的 self.__init__() print('使用%s制作煎饼果子' % self.kongfu) # 子类调用父类的同名方法 def make_master_cake(self): # 父类类名.函数() # 再次调用初始化方法的原因：这里想要调用父类的同名方法和属性， # 属性在init初始化位置，所以需要再次调用 Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) daqiu = Prentice() print(daqiu.kongfu) # [独创煎饼果子配方] daqiu.make_cake() daqiu.make_master_cake() daqiu.make_school_cake() daqiu.make_cake() 父类的初始化： # 方法一：代码冗余，如果父类类名变化，这里代码需要频繁修改 Master.__init__(self) Master.make_cake(self) School.__init__(self) School.make_cake(self) # 方法二：super() # 1、super(当前类名, self).函数() super(Prentice, self).__init__() super(Prentice, self).make_cake() # 2、 super().函数() super().__init__() super().make_cake() super() 可以自动查找父类。调用顺序遵循 __mro__ 类属性的顺序，比较适合 单继承 使用 🔘 私有属性 它们除了非特殊手段，只能 在类里面访问和修改一般定义 get_xx 用来获取私有属性定义 set_xx 用来修改私有属性值 class myc(object): def __init__(self, name, age): self.name = name self.__age = age #私有属性 def get_age(self): return self.__age #获取私有属性 🔘 私有方法 通过 _类名__方法名 访问注意，直接 __方法名 是无法访问的 class myc(object): def __init__(self, length, width): self.length = length self.width = width def __cal_area(self): #定义私有方法 return self.length*self.width tmp = myc(length=2, width=3) tmp.__cal_area() #报错，在类的内部可以通过self.__cal_area() 来调用私有方法，但是在类的外部是无法直接调用私有方法的 tmp._myc__cal_area() #正常返回值，但是这样做，一定程度会破坏类的封装性 多态有点像高阶函数，类里面的函数调用不同的类，会有不同的输出 ⭕ 异常处理 异常传递 try: 。。。 try: 。。。 except: 。。。 else: 。。。 finally: 。。。 except: 。。。 若没有出现问题则 except 不会执行，那么将会执行 else 中的内容。总之 exception 和 else 二选一注意若 try 的异常 没有通过 exception 指出，系统 还是会报错 Traceback，且终止程序。但是此时若有 finally 语句，则系统在报错之前还会执行 finally 中的内容一般 finally 中会时 释放文件句柄、内存空间 等操作 使用 raise 关键字可以显式地抛出异常，提供更多的异常信息和上下文，帮助调试和定位问题，而不使用 raise 则会隐式地抛出异常 🔘 自定义异常 # 通过继承 Exception 来自定义 class myError(Exception): def __init__(self, ): pass def __str__(self): #抛出异常时会打印的内容 return 。。。 try: 。。。 if 。。。: raise myError() #抛出自定义异常，raise 异常类对象 except Exception as e: print(e) else: 。。。 ⭕ 模块 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和 Python 语句模块能定义函数，类和变量，模块里也能包含可执行的代码 import math print(math.sqrt(9)) ############################ from math import sqrt # 或者 from math import * print(sqrt(9)) # 为模块定义别名 import matplotlib.pyplot as plt # 同理，模块中的函数也可以定义别名 if __name__ == '__main__': 其中的 __name__ 是系统变量，模块标识符自身模块运行时，__name__ 为 __main__ ，否则是 当前模块的名字 当导入一个模块，Python 解析器对模块位置的搜索顺序是：1、当前目录2、如果不在当前目录，Python 则搜索在 PYTHONPATH 下的每个目录3、如果都找不到，Python 会察看默认路径。UNIX 下，默认路径一般为 /usr/local/lib/python/以上模块搜索路径都存储在 system 模块的 sys.path 变量中 [!NOTE|style:flat] 自定义文件名不要和已有模块名重复，否则导致模块功能无法使用 import time print(time) # time = 1 #不会报错，可以直接覆盖 # mymodule.py __all__ = ['testA'] #当外部利用 from mymodule import * 导入当前模块的时候，仅有 testA 方法会被导入 def testA(): print('test-A') def testB(): print('test-B') # 假设文件目录结构： # - mypackage # - __init__.py # - mymodule1.py # - mymodule2.py # 导入方法： # 1、 import mypackage.mymodule1 mypackage.mymodule1.某方法() # 2、 from mypackage import * mymodule1.某方法() # 此方式需要在包中的 __init__.py 文件添加 __all__ = [允许导入的模块] __dict__ 查看对象所有的属性或者方法 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-08 17:51:53 "},"about_Python/python_tutorial2.html":{"url":"about_Python/python_tutorial2.html","title":"学习2","keywords":"","body":" ✨参考资料 黑马 Python 教程：https://github.com/cess-100/python-study2 ✨获取系统监控信息 # 导入模块 import psutil ⭕ 关于 CPU # 核心数 psutil.cpu_count(logical=False) # 若参数 logical=False 则只会返回物理内核 # 使用率 psutil.cpu_percent(interval=0.5) # 若加上参数 percpu=True 则会返回一个列表，包含各个核心的使用率 ⭕ 关于内存 # 内存信息，包括：总容量、可用空间及占比等 psutil.virtual_memory() # 可以通过点号访问具体的属性，例如 psutil.virtual_memory().total ⭕ 关于磁盘 # 磁盘分区信息，包括：总容量、可用空间及占比等 psutil.disk_partitions() # 指定目录的磁盘信息 psuntil.disk_usage('/') ⭕ 关于网络 # 可以获取到收、发数据包的数量 。。。。。。 ⭕ 关于用户 # 活动用户信息 psutil.users() ⭕ 保存到日志 示例： import psutil import datetime import unicodedata def align_string(text, width, alignmethod): \"\"\" 处理中英文混合字符串的对齐问题 \"\"\" text_width = sum(2 if unicodedata.east_asian_width(c) in ('F', 'W') else 1 for c in text) if alignmethod == 'ljust': tmp = text.ljust(width - text_width) elif alignmethod == 'rjust': tmp = text.rjust(width - text_width) elif alignmethod == 'center': tmp = text.center(width - text_width) return tmp cpu_per = psutil.cpu_percent(interval=0.5) memory_info = psutil.virtual_memory() disk_info = psutil.disk_usage(\"/\") net_info = psutil.net_io_counters() current_time = datetime.datetime.now().strftime(\"%F %T\") log_template = f\"\"\" |{align_string('监控时间', 19, 'center')}|{align_string('CPU使用率', 19, 'center')}|{align_string('内存使用率', 19, 'center')}|{align_string('硬盘使用率', 19, 'center')}|{align_string('网络收发量', 28, 'center')}| |{align_string('', 19, 'ljust')}|{align_string(f'(共{psutil.cpu_count(logical=False):.2f}核CPU)', 19, 'center')}|{align_string(f'(总计{memory_info.total/1024/1024/1024:.2f}G内存)', 19, 'center')}|{align_string(f'(总计{disk_info.total/1024/1024/1024:.2f}G硬盘)', 19, 'center')}|{align_string('', 28, 'ljust')}| |{'-' * 19}|{'-' * 19}|{'-' * 19}|{'-' * 19}|{'-' * 28}| |{align_string(current_time, 19, 'ljust')}|{align_string(f'{cpu_per}%', 19, 'ljust')}|{align_string(f'{memory_info.percent}%', 19, 'ljust')}|{align_string(f'{disk_info.percent}%', 19, 'ljust')}|{align_string(f'收:{net_info.bytes_recv}/发:{net_info.bytes_sent}', 28, 'ljust')}| |{'-' * 19}|{'-' * 19}|{'-' * 19}|{'-' * 19}|{'-' * 28}| \"\"\" print(log_template) with open('log.txt', 'a') as f: f.write(log_template + '\\n\\n') 若需要持续写入日志文件，可以利用 while 循环每隔一段时间去重新计算需要的指标即可 ✨发送邮件 # 导入模块 import yagmail # 先创建对象 ya_obj = yagmail.SMTP( user = \"发件人邮箱\", password = \"授权码（非密码，在邮箱设置）\", host = \"网易邮箱服务器smtp.163.com\" ) # 配置邮件内容 content = '。。。' # 发送邮件 ya_obj.send('收件人邮箱', '邮件主题', content) ⭕ 实际应用 可以结合上面的监控信息判断当 CPU 使用率超过 80%，内存使用率超过 90% 的时候，发送邮件给指定收件人 if cpu_per>80 or memory_info.percent>90: # 发送邮件。。。 ✨套接字编程 # 导入模块 import socket ⭕ 创建套接字 socket.socket(参数一:协议类型, 参数二:传输方式) # IPv4 UDP 的方式 mysocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM(UDP)) # IPv6 TCP 的方式 mysocket = socket.socket(socket.AF_INET6, socket.SOCK_STREAM(TCP)) # 关闭套接字 mysocket.close() ⭕ UDP 连接收、发数据 # 发送数据 .sendto(参数一:待发送数据的二进制格式, 参数二:发送方的IP和端口号) # 示例 mysocket.sendto( 'hello!'.encode(), ('192.168.166.166', 8080) ) # 接收数据 .recvfrom(参数:数据大小，单位字节) # 示例 mysocket.recvfrom(1024) # 表示从套接字中接受 1024 个字节的数据 # recvfrom 方法会造成程序的阻塞，一直等待直到收到数据 # 收到的数据为元组：(内容的二进制形式, (发送方的 IP, 发送方的端口号)) ⭕ 内容解码 # 指定 UTF-8 的解码格式，且解码失败时忽略错误 recv_data = mysocket.recvfrom(1024) recv_text = recv_data[0].decode(encoding='UTF-8', errors='ignore') ⭕ 绑定端口 收、发端的绑定方法差不多 mysocket.bind((参数一:字符串形式的IP, 参数二:整数端口号)) 接收端的参数一 IP 为空字符串时，若计算机有多个网卡，则不同网卡的数据都能被接收为什么需要绑定端口号？？？ ⭕ 设置广播 # 默认不允许发送广播，需要开启相关权限 .setsocketopt(参数一:套接字, 参数二:广播, 参数三:广播属性布尔值) # 示例 mysocket.setsocketopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True) ⭕ TCP 客户端 类似 UDP 传输 # 创建套接字 socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立连接 .connect(('IP地址', 端口号)) # 发送数据 .send('发送内容'.encode()) # 接收数据 .recv(1024) #二进制形式，还需要解码 .decode() # 关闭套接字 .close() ⭕ TCP 服务端 # 不是建立连接，而是绑定端口和 IP .bind(('', 端口号)) # 这里的 IP 放空，便于接收数据 # 开启监听，使得套接字不能主动发送数据 .listen(128) # 128 是允许的最大连接数 # 等待客户端连接 .accept() # 在连接之前，程序都处于阻塞状态 # 客户端连接后，返回新的套接字对象和一个包含IP和端口号的元组 # 使用新的套接字进行收、发数据 # 操作同上 可以将 accept 和收发数据操作置于 while 循环中，模拟多个客户端前后接入的情况 ⭕ 文件下载器 客户端发送文件名给服务端，服务端循环读取对应的文件内容，然后发送给客户端客户端再接收数据，循环写入到本地的文件中收到的数据不用再解码，直接 file.write(recv_data) 将二进制数据写入 ⭕ 模拟浏览器 通过套接字与目标 IP 建立 TCP 连接再拼接出请求协议，包括：请求行、请求头、请求空行 request_line = 'GET / HTTP/1.1\\r\\n' request_header = 'Host:www.com\\r\\n' request_blank = '\\r\\n' request_data = request_line + request_header + request_blank \"\"\" GET / HTTP/1.1 Host:www.com \"\"\" 之后 send 请求协议，获取相应内容 ⭕ 模拟 Web 服务器 创建套接字后，设置 地址重用 tcp_server_socket.setsockopt( socket.SOL_SOCKET, socket.SO_REUSEADDR, True ) 然后绑定端口，设置监听之后在 while 循环中，accept 客户端的连接根据接收到的请求协议，判断request_data是否为空为空则直接关闭客户端的连接不为空则拼接响应报文，包括：响应行、响应头、响应空行、响应主体 response_line = 'HTTP/1.1 200 OK\\r\\n' response_header = 'Server:Python20WS/2.1\\r\\n' response_blank = '\\r\\n' response_body = 'Hello World!' response_data = response_line + response_header + response_blank + response_body \"\"\" HTTP/1.1 200 OK Server:Python20WS/2.1 Hello World! \"\"\" 向客户端发送响应报文，最后关闭连接 上述的响应主体可以根据客户端的请求协议 从指定文件中以二进制形式读取 后，与响应行等拼接后发送请求的资源在请求行中：GET / HTTP/1.1\\r\\n，这里是 /，则默认返回首页 /index.html只需要通过 request_data.decode().find('\\r\\n') 方法找到第一次出现 \\r\\n 的位置，然后将字符串拆分即可 其他响应行 \"\"\" HTTP/1.1 404 Not Found\\r\\n \"\"\" 若要进行面向对象封装：1、在 __init__ 方法中创建套接字，设置地址重用，绑定端口号，开启被动监听2、定义启动服务器的函数，接受客户端连接3、定义接收信息的函数 重要的是学习黑马教程是如何将上述问题解耦，以及模块调用的 ⭕ 使用命令行启动 import sys # 获取命令行传递到程序的参数 params_list = sys.argv # 可以通过 if 判断参数的格式，例如判断第二个参数是否是纯数字 # if not sys.argv[1].isdigit(): ✨线程 ⭕ 创建子线程 import threading # 创建子线程对象 thread_obj = threading.Thread(target=自定义的函数, args=(参数1, 参数2, ...)) # 启动子线程 thread_obj.start() 除了上述通过元组完成子线程传参，还有： # 字典传参 threading.Thread(target=自定义的函数, kwargs={'参数名1': 值1, '参数名2': 值2, ...}) # 混合使用 threading.Thread(target=自定义的函数, args=(参数1, 参数2, ...), kwargs={'参数名3': 值3, '参数名4': 值4, ...}) 其他操作： # 获取当前线程对象 threading.current_thread() # 获取正在活跃的线程列表 threading.enumerate() [!NOTE|style:flat] 多个子线程之间可以通过定义全局变量来共享变量但是需要注意防止线程之间资源竞争，导致变量计算结果有误 ⭕ 线程守护 线程守护即 子线程守护主线程 # 设置守护线程 t1_obj = threading.Thread(target=) t1_obj.setDaemon(True) #主线程结束后，子线程也结束 ⭕ 自定义线程类 # 继承 threading.Thread 类 # 重写 run 方法 class MyThread(threading.Thread): def __init__(self, num): # 需要先调用父类的init方法 super().__init__() self.num = num # 重写父类的run方法 def run(self): 。。。 mythread = MyThread(10) # 子类从父类继承了 start() 方法，可以直接使用 mythread.start() ⭕ 多线程 # 创建 2 个子线程 t1 = threading.Thread(target=work1) t2 = threading.Thread(target=work2) # 启动线程 t1.start() # 优先让 t1 线程优先执行，t1 执行完毕后，t2 才能执行 t1.join() t2.start() ⭕ 锁 为了防止多线程出现资源竞争的现象，我们需要对资源进行适时的锁定 🔘 互斥锁 # 创建互斥锁 lock = threading.Lock() # 上锁 lock.acquire() # 解锁 lock.release() 有了互斥锁之后，当两个线程访问同一资源时，即使没有使用 .join() 等待一方结束，也不会出现资源竞争的情况需要小心出现死锁 ✨进程 ⭕ 创建子进程 import multiprocessing def work1(): pass # 创建子进程对象，指定子进程名称为 p1 process_obj = multiprocessing.Process(target=work1, name='p1') # 启动子进程 process_obj.start() # 终止子进程 process_obj.terminate() exit() # 获取主进程的名称 multiprocessing.current_process() # 获取进程的编号 process id（pid） multiprocessing.current_process().pid() # 或者通过 os 模块获取 os.getpid() 传参方式与 threading 类似 ⭕ 进程守护 # 子进程守护主进程 p1_obj = multiprocessing.Process(target=) p1_obj.daemon = True ⭕ 队列 # 创建队列，设置长度为 5 queue = multiprocessing.Queue(5) # 值进队列 queue.put(值可以是int、str、list、tuple、dict) # 根据先进先出的原则，取出队列中的值 queue.get() 若队列已满，此时继续有值进队列，则队列会进入阻塞状态，默认会等待先取出值再放入新的值而使用 .put_nowait(值) 则会直接报错，不会阻塞 若队列为空，此时继续进行取值，也是默认阻塞而使用 .get_nowait(值) 则会直接报错，不会阻塞 # 判断队列是否已满 queue.full() # 队列里面值的个数 queue.qsize() # 判断队列是否为空 queue.empty() 队列判断可能有坑，具体的-->🔍 ⭕ 进程之间的通信 思路：创建两个进程和一个队列其中一个进程向队列中 put 元素；另一个进程读取队列中的元素注意需要使用 .join() 使前者先执行完，之后才让后者读取数据 ⭕ 进程池 # 创建一个大小为 2 的进程池 mypool = multiprocessing.Pool(2) # 异步对进程池中的内容执行某函数 pool.apply_async(某函数) # 进程池不再接收新任务 mypool.close() # 主进程等待进程池中的任务结束后再退出 mypool.join() 🔘 进程池中的进程如何通信？ # 类似的，在进程池中创建队列 queue = multiprocessing.Manager().Queue(5) result = pool.apply_async(write_queue, (queue,)) result.wait() pool.apply_async(read_queue, (queue,)) # 其中的write_queue和read_queue是函数 # 利用进程池中的进程来执行这些函数，注意需要等待写操作的进程结束后，才进行读操作 🔘 应用 # 文件夹拷贝 pool = multiprocessing.Pool(3) for filename in filelist: pool.apply_async(copy_work, (source_dir, dest_dir, filename)) pool.close() pool.join() # 上面的 copy_work 函数就是读取 source_dir 中的 filename 文件内容，然后写入到 dest_dir 文件夹中 ✨迭代器、生成器 ⭕ 可迭代对象 可遍历对象即可迭代对象例如：列表、元组、字符串、字典 检测一个对象是否可迭代 from collections import Iterable isinstance([1,2,3,4], Iterable) #返回布尔值 [!NOTE|style:flat] 若一个 自定义类 含有 __iter__() 方法，则它是一个可迭代对象；否则不是所以判断一个对象是否是可迭代对象，应该看其是否包含了 __iter__() 方法 ⭕ 迭代器 🔘 特点 记录遍历的位置提供下一个元素的值 [!NOTE|style:flat] for 循环的本质：先通过 iter(要遍历对象) 获取要遍历对象的迭代器再通过 next(迭代器) 获取下一元素此外 for 循环还自动帮我们捕获了 StopIteration 异常 mylist = [1, 3, 5] # 获取迭代器 my_iterator = iter(mylist) # 获取下一元素 value1 = next(my_iterator) value2 = next(my_iterator) value3 = next(my_iterator) value4 = next(my_iterator) #报错 StopIteration [!NOTE|style:flat] 若一个 自定义类 不仅有 __iter__() 方法，还有 __next__() 方法，则它是一个迭代器类 🔘 应用 自定义一个列表 # 目标： mylist = MyList() for value in mylist: print(value) 思路：先定义 MyList 类。它具有 __init__() 方法；__iter__() 方法，对外提供迭代器；addItem() 方法，用来添加数据再定义迭代器类 MyListIterator，应用于上述 MyList 类的 __iter__() 方法中。它具有 __init__() 方法；获取下一个元素值的方法 __next__() ⭕ 生成器 是特殊的迭代器，同样可以通过 next(生成器) 获取下一个值 🔘 创建方式 列表推导式 函数中使用了 yield 返回值 yield 会暂停程序，返回变量值，并且保存程序的运行状态，当执行 next 的时候就会继续从 yield 的位置向下执行 [!NOTE|style:flat] 生成器中可以使用 return 来结束 ⭕ 协程的实现 在 while 循环中，使用 yield 和 sleep 可以实现基本的协程 调用 gevent 模块实现协程gevent 能够自动识别程序中的耗时操作，在耗时的时候自动切换到其他的任务 from gevent import monkey # 破解所有 monkey.patch_all() #打补丁，让　gevent 识别 time.sleep() # 若不打补丁，则需要使用 gevent.sleep() import time import gevent # 指派任务 g1 = gevent.spawn(work1, 参数1, 参数2, ...) g2 = gevent.spawn(work2, 参数1, 参数2, ...) # 让主线程等待协程执行完毕再退出 g1.join() g2.join() # 或者 gevent.joinall([ gevent.spawn(work1, 参数1, 参数2, ...), gevent.spawn(work2, 参数1, 参数2, ...) ]) ✨re 模块 ⭕ match、search 方法 re.match(\"正则表达式\", \"要验证/检测的字符串\")从字符串的 开头位置 匹配，可以用于验证输入的内容是否满足某种格式 re.search(\"正则表达式\", \"要搜索的字符串\")从需要检测的 字符串中 搜索满足正则的内容 以上两个方法，如果匹配成功，返回 match object 对象如果匹配失败，返回 None可以通过 .group() 获取结果 ⭕ sub 方法 对 search 到的字符（串）进行替换 import re def add(temp): strNum = temp.group() num = int(strNum) + 1 return str(num) ret = re.sub(r\"\\d+\", add, \"hello python = 997\") #可以传入函数，对 search 到的内容进行更加多样化的替换修改 print(ret) ⭕ split 方法 根据正则表达式对字符串进行拆分 result = re.split(\":| \", \"info:hello@163.com zhangsan lisi\") #根据冒号或者空格拆分 # 相比于 str.split() 更加灵活 print(result) ⭕ 贪婪与非贪婪 正则表达式默认为贪婪模式，满足表达式的情况下，尽可能多地获取内容怎么转换成非贪婪模式，在 +*{} 等符号的后面添加 ? 符号即可 result = re.match(\"aaa(\\d+?)\", \"aaa123456\") #匹配到 1 就停止了 print(result.group()) ⭕ 其他 字符串前 r 的作用让正则中的 \\ 不再是转义的特殊含义 # result = re.match(\".*\", \"asdbj\") result = re.match(r\".*\", \"asdbj\") print(result.group()) ✨SQL 语句 ⭕ pymysql 的使用 import pymysql # 建立连接对象 conn = pymysql.connect(host='localhost', port=3306, user='root', password='123456') # 创建游标对象 cur = conn.cursor() # 使用游标对象执行 SQL 语句 sql = \"\"\" select * from students \"\"\" results = cur.execute(sql) # 提交 conn.commit() # 仅从查询的数据中取出一条数据 oneres = cur.fetchone() # 嵌套元组，每个元组是一条数据 res = cur.fetchall() # 关闭游标对象 cur.close() # 关闭连接对象 conn.close() ⭕ SQL 注入 sql = f\"\"\" select * from goods where name = {input_name} order by id desc \"\"\" # 当 input_name = ' or 1 or ' 时，执行 # select * from goods where name = '' or 1 or '' order by id desc # 会导致注入问题 # 防止注入的写法 sql = \"\"\" select * from goods where name = %s order by id desc \"\"\" result = cur.execute(sql, [input_name, ]) ✨闭包 结构：1、存在函数的嵌套关系2、内存可以使用外层的变量3、外层返回内层的引用 ⭕ 简单闭包 def func_out(num1): print(num1) def func_inner(num2): print(num1) print(num2) return func_inner ret = func_out(100) # 调用里层函数 ret(200) # 输出 # 100 # 100 # 200 [!NOTE|style:flat] 如果在内层函数定义和外层同名的变量，编译器会优先使用内层的变量而此时若又在内层对该同名变量定义为 nonlocal，这意味着该变量使用的是外层函数的，这样会导致错误 ⭕ 装饰器 假设现在有一个 login 函数 def login(username, uuuid): print(f'{username} 开始登录') return f'uuuid 为 {uuuid}' 请问如何在不修改源代码的情况下，为其增加登录前的验证功能？答案是使用装饰器 def function_out(func): def function_in(username, uuuid='001'): print(\"------开始验证-------, username =\", username) # 这里是验证操作... return func(username, uuuid) return function_in #外部函数返回内部函数的函数名 方法一： login2 = function_out(login) #往外部函数中传入 login 函数 res = login2(username='iron', uuuid='023') #相当于调用内部函数 print(res) 方法二： # @function_out 装饰 login() 函数，将上述步骤简化 @function_out def login(username, uuuid): print(f'{username} 开始登录') return f'uuuid 为 {uuuid}' # 通过闭包调用外层函数 res = login(username='iron') print(res) 若 login 函数需要传入位置参数和关键字参数也是同理 那么，使用装饰器的时候如何传入参数呢？这次我们不直接传入，而是在 function_out 外层再套一个函数，使用局部变量即可 def myverify(step): def function_out(func): def function_in(username, uuuid='001'): print(\"function_in step =\", step) print(\"------开始验证-------, username =\", username) # 这里是验证操作... return func(username, uuuid) return function_in #外部函数返回内部函数的函数名 # 返回装饰器的引用 return function_out @myverify(\"register 注册步骤\") def register(username, uuuid): print(f'{username} 开始注册') return f'uuuid 为 {uuuid}' @myverify(\"login 登录步骤\") def login(username, uuuid): print(f'{username} 开始登录') return f'uuuid 为 {uuuid}' print(register(username='iron')) print(login(username='iron')) @myverify(\"register 注册步骤\") 分解为 2 步1、执行 myverify(\"register 注册步骤\")，传入了参数，并且返回 function_out 引用，得到 @function_out2、之后就是同上，返回内部函数的引用 function_in 多重装饰器 # 定义一个让文字加粗的装饰器 def makeBold(func): def function_in(): return \"\" + func() + \"\" return function_in # 定义一个让文字倾斜的装饰器 def makeItalic(func): def function_in(): return \"\" + func() + \"\" return function_in @makeBold def test(): return \"hello world-1\" @makeItalic def test2(): return \"hello world-2\" @makeItalic @makeBold def test3(): return \"hello world-3\" print(test()) # hello world-1 print(test2()) # hello world-2 print(test3()) # hello world-3 装饰器类 class Test(object): def __init__(self): print(\"----初始化----\") def run(self): print(\"---正在运行---\") def __call__(self, *args, **kwargs): print(\"---call---\") # 创建类对象 test = Test() # 调用 run 方法 test.run() test() 当使用 对象名() 此时会去调用类中的 __call__() 方法若没有定义 __call__() 方法，则会报错 # 装饰器类 class Test(object): def __init__(self, func): self.func = func def _verify(self, *args, **kwargs): username = kwargs.get('username') print(\"------开始验证-------, username =\", username) def __call__(self, *args, **kwargs): # print(args, kwargs) return self.func(*args, **kwargs) @Test def login(username, uuuid): print(f'{username} 开始登录') return f'uuuid 为 {uuuid}' login._verify(username='iron') res = login('iron', uuuid='023') print(res) ✨其他 ⭕ 如何实现想要的功能？思路分析 列出需要的功能设计框架，功能对应需要通过哪些函数实现各个函数实现的具体步骤 ⭕ 继承问题 假设类 D 继承了类 B 和类 C，而类 B 和类 C 都继承了类 A当创建 D 的实例 d 时，会按照方法解析顺序（Method Resolution Order，MRO）来确定调用父类的顺序 在 Python 中，MRO 是通过 C3 线性化算法来确定的在这个算法中，首先会按照 广度优先搜索 的顺序来遍历继承关系图，然后保持子类在父类之前的顺序 在这个例子中，MRO 的顺序是 D -> B -> C -> A -> object因此，在调用 super().__init__() 时，会按照这个顺序 依次调用父类的 __init__ 方法 ⭕ @property 使得类中的方法可以作为属性调用 class Pager: def __init__(self, current_page): # 用户当前请求的页码（第一页、第二页...） self.current_page = current_page # 每页默认显示 10 条数据 self.per_items = 10 @property def start(self): val = (self.current_page - 1) * self.per_items + 1 return val @property def end(self): val = self.current_page * self.per_items return val p = Pager(2) print(p.start) # 就是起始值，即：11 print(p.end) # 就是结束值，即：20 class Goods: \"\"\" python3 中默认继承 object 类 python3 中才有 @xxx.setter @xxx.deleter \"\"\" @property def price(self): print('@property') @price.setter def price(self, value): print('@price.setter') @price.deleter def price(self): print('@price.deleter') obj = Goods() obj.price obj.price = 123 del obj.price 或者 class Goods: def get_price(self): print('price of goods') def set_price(self, value): print('set') def del_price(self): print('delete') goods = property(get_price, set_price, del_price, 'description...') obj = Goods() obj.goods obj.goods = '5元' del obj.goods ⭕ 上下文管理器实现文件操作 with open('') as f: 语句就是通过定义上下文方法来实现文件的操作下面我们尝试实现 MyFile() 类 class MyFile(object): def __init__(self, file_name, file_model): # 创建实例属性 self.file_name = file_name self.file_model = file_model # 上文方法（打开资源） def __enter__(self): # 打开文件，返回文件资源 self.file = open(self.file_name, self.file_model) return self.file # 下文方法（关闭资源） def __exit__(self, exc_type, exc_val, exc_tb): # 关闭文件资源 self.file.close() with Myfile('???.x=txt', 'r') as f: data = f.read() print(data) ⭕ 文件 I/O DataFrame 写入文件 df.to_excel('。。。.xlsx', index=False) df.to_csv('。。。.csv', index=False) 路径标准化 import os input_path = 'D:/jupyterproject/logo.jpg ' input_file = os.path.normpath(input_path.strip()) # normpath 统一为双反斜杠类型的 \\\\ 图片的读取 input_file = '???.jpg' from PIL import Image import numpy as np image = Image.open(input_file) # 用PIL中的Image.open打开图像 image = image.resize((512, 512), Image.LANCZOS) #修改图片大小 image = image.convert('RGB') #转换成RGB模式 raw_image = np.array(image) #转化成numpy数组 print(raw_image.size) image_PIL = Image.fromarray( np.uint8(raw_image).reshape((512, 512, 3)), mode=\"RGB\", #array转换成图片 ) .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-13 00:02:53 "},"about_Python/常见问题Updated.html":{"url":"about_Python/常见问题Updated.html","title":"常见问题","keywords":"","body":" 常见问题 虚拟环境管理 正则表达式 PyQt 打包 if __name__ == '__main__' 递归与回溯 打字效果 np.where() 函数 zip 函数 绘图相关 a.empty、a.all()、a.any() 海象操作符 排序，并且需要原数组的下标 局部变量 nonlocal、全局变量 global URL 的参数提取问题 swapaxes 函数 变量的下划线 关于 __call__() 求均值、最大、最小 input 内容的处理 NaN 值 subprocess 可交互 3D 图像示例 脚本的参数传入 DataFrame 中 drop 的用法，删除行或者列 生成独热编码的方式 奇异值分解和特征值分解 图像 color bar 设置 文件打包下载 mp4 转 gif 算法题中出现的缓存 zip(*nums) 实现对矩阵的逆时针旋转 关于 PYTHONPATH yield Python 的一些模式 语法糖 模块、包、库 utils 文件夹 网络编程 并发和并行 线程、进程 多线程、协程、异步 __str__ 和 __repr__ 帅地面试题 Python 简介 赋值、浅拷贝、深拷贝 Python 的作用域 Python 自省 Python 提升性能的手段 字典的 items() 与 iteritems() os.path 和 sys.path 字典与 JSON 可变、不可变类型 Python 的内存管理 模块和包是什么？ 类方法、类实例方法、静态方法 内存管理机制、调优手段 内存泄漏 函数调用时，参数传递的方式 pass 语句 super() 作用 回调函数 方法重载、方法重写 函数装饰器的用途 生成器、迭代器 is 与 == 面向过程、面向对象 GET 与 POST Python2 和 3 的区别 编码解码 ✨常见问题 ⭕ 虚拟环境管理 为了避免不同项目所需要的不同版本的第三方库之间的冲突，常常需要针对性地设置不同的 Python 虚拟环境，实现项目环境隔离假设虚拟环境名字为：myvirtest 方法一：venv 包 创建虚拟环境 python3 -m venv myvirtest 切换到目录 myvirtest\\Scripts 下，激活虚拟环境 activate.bat 或者 Activate.ps1 方法二：virtualenv 包 国内 pip 镜像下载：pip install virtualenv -i https://mirrors.aliyun.com/pypi/simple 新建虚拟环境 $ virtualenv -p python3 myvirtest 进入虚拟环境 $ source myvirtest/bin/activate 若需要指定 python 版本：$ virtualenv --python=python3.6 myvirtest [!NOTE|style:flat] 本机需要自带对应版本的 python 才可以指定虚拟环境 python 版本，例如这里本机需要有 python3.6 才行 ⭕ 正则表达式 在线测试 👈例子 👈 [!NOTE|style:flat] 不同的开发环境，正则表达式知识略有不同 作用 1、数据验证。例如查看字符串内是否为电话号码模式或信用卡号码模式等等 2、替换文本。识别文档中的特定文本，完全删除该文本或者用其他文本替换它 3、从字符串中提取子字符串 普通字符 [一些字符] 匹配方括号中的字符，凡是在里面的都给筛出来 [^一些字符] 同上，但是反向筛选 [A-Z] 给定一个区间，无需将 26 个字符都写出 . 表示任意字符，但是不包括换行和回车。等同于 [^\\n\\r] [\\w] 包括字母、数字、下划线。等同于 [A-Za-z0-9_] \\d 匹配一个数字字符。等同于 [0-9] \\D 匹配一个非数字字符。等同于 [^0-9] [\\s] 所有空白符（包括换行） [\\S] 所有非空白符 特殊字符 $ () 子表达式的开始和结束位置 * 前面的子表达式>=0，贪婪的 会尽可能多的匹配文字 + 前面的子表达式>=1，贪婪的 会尽可能多的匹配文字 ? 前面的子表达式 0/1 次，或者 非贪婪 限定符 . [ \\ ^ 输入字符串的开始位置，或者在方括号中表示反向筛选 { 标记限定符表达式的开始 | 两项之间的一个选择 一般在 * 和 + 的后面加上一个 ? 实现非贪婪或最小匹配 是贪婪匹配，从 为止，贪婪匹配会尽可能地返回 满足条件的最长的字符串 非贪婪或最小匹配，从 就停止 （若要匹配特殊字符地原本字符，则需要加 \\ 转义） 限定字符（指定出现多少次） * 前面的子表达式>=0 + 前面的子表达式>=1 ? 前面的子表达式=0/1 {n} 连续出现 n 次 {n,} {n,m} 注意逗号和两个数之间 不能有空格 定位字符（描述字符串或单词的边界） ^ 和 $ 分别指字符串的开始与结束 \\b 描述字与空格间的位置 \\B 表示非单词边界 不能将限定符与定位符一起使用 选择 exp1(?=exp2) 查找 exp2 前面的 exp1 (? 查找 exp2 后面的 exp1 exp1(?!exp2) 查找后面不是 exp2 的 exp1 (? 查找前面不是 exp2 的 exp1 %accordion% 应用（修改 GPU 的 Num），点击展开代码 %accordion% import re a = \"\"\" class ConversationBot: def __init__(self): print(\"Initializing VisualChatGPT\") self.llm = OpenAI(temperature=0) self.edit = ImageEditing(device=\"cuda:6\") self.i2t = ImageCaptioning(device=\"cuda:4\") self.t2i = T2I(device=\"cuda:1\") self.image2canny = image2canny() self.canny2image = canny2image(device=\"cuda:1\") self.image2line = image2line() self.line2image = line2image(device=\"cuda:1\") self.image2hed = image2hed() self.hed2image = hed2image(device=\"cuda:2\") self.image2scribble = image2scribble() self.scribble2image = scribble2image(device=\"cuda:3\") self.image2pose = image2pose() self.pose2image = pose2image(device=\"cuda:3\") self.BLIPVQA = BLIPVQA(device=\"cuda:4\") self.image2seg = image2seg() self.seg2image = seg2image(device=\"cuda:7\") self.image2depth = image2depth() self.depth2image = depth2image(device=\"cuda:7\") self.image2normal = image2normal() self.normal2image = normal2image(device=\"cuda:5\") self.pix2pix = Pix2Pix(device=\"cuda:3\") self.memory = ConversationBufferMemory(memory_key=\"chat_history\", output_key='output') \"\"\" pattern = re.compile('cuda:\\d') re.findall(pattern, a) # 替换成 cuda:0 result, number = re.subn('cuda:\\d', 'cuda:0', a) print(result, number) %/accordion% ⭕ PyQt 打包 参考这里的方法四：https://blog.csdn.net/qq_37354233/article/details/123731111以下方法适用于 Windows 系统先到官网 https://www.python.org/downloads/ 找到开发所用的 Python 版本，选择下载 embeddable 那个压缩包之后解压到自己想要的路径下，将写好的 Python 脚本也放在同一个目录下将运行所需要的第三方库都复制到路径 \\python-3.9.4-embed-amd64\\Lib\\site-packages\\ 下之后编写【启动.bat】文件，一般内容如下即可： @echo off setlocal enabledelayedexpansion chcp 65001 ::切换到该bat文件所在的目录下 cd %~dp0 cd 项目文件夹路径 ::设置 Qt 的临时环境变量 set QT_QPA_PLATFORM_PLUGIN_PATH=..\\python-3.9.4-embed-amd64\\Lib\\site-packages\\PySide6\\plugins\\platforms echo %QT_QPA_PLATFORM_PLUGIN_PATH% ..\\python-3.9.4-embed-amd64\\python.exe .\\main.py @pause 需要修改的地方就是上面第四行 python.exe 的位置和 Python 脚本 main.py 的位置之后双击 bat 文件，检查是否运行成功。若显示部分包缺失再手动安装 ⭕ if __name__ == '__main__' 每一个模块（.py 文件）都有 __name__ 当模块被 直接执行 时 此时 __name__=='__main__' 而作为外部模块 被其他模块导入 时 此时 __name__ 为 模块文件名，程序会执行被导入模块的 所有代码（所以需要将测试代码放在这个 if __name__ == '__main__' 的条件下） ⭕ 递归与回溯 我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是 递归 的过程。这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道有一个路口选错了，所以通过撤销或取消之前的决策，然后进行新的选择或路径，这就是 回溯 的思想 递归函数通常包括两个主要部分——基本情况（Base Case）和递归情况（Recursive Case）。基本情况是当问题被划分到最小规模时，可以直接解决的情况。递归情况是将问题分解为更小规模的子问题，并通过调用自身来解决这些子问题 在递归过程中，每个递归调用都会在内存中形成一个称为 调用栈 的数据结构。调用栈存储了每个递归函数的局部变量、返回地址和其他信息。递归调用会在调用栈中形成一个栈帧，当递归结束时，栈帧会从栈顶依次弹出，从而实现逐级返回 递归算法可能具有较高的时间和空间复杂度，需要考虑优化 %accordion% 树的路径问题 %accordion% class Solution: def binaryTreePaths(self, root): #二叉树路径 if not root: #若节点为空，则返回空列表 return [] if not root.left and not root.right: #若左右节点为空，则返回当前节点的值构成的列表 return [str(root.val)] paths = [] if root.left: for i in self.binaryTreePaths(root.left): #递归左节点 print(str(root.val), i) paths.append(str(root.val) + '->' + i) if root.right: for i in self.binaryTreePaths(root.right): #递归右节点 print(str(root.val), i) paths.append(str(root.val) + '->' + i) print(paths) return paths %/accordion% %accordion% 汉诺塔问题 %accordion% # 规则：每次移动柱子上的第一个盘，到另一个柱子上；大盘不能放在小盘上面 # 思路：将问题转换成子问题，要移动所有盘子到柱3上 # 首先将柱1最底下的大盘移动到3，前提是前(N − 1)个盘子已经按顺序摆在了柱2上 # 接下来就是一个子问题：将(N − 1)个盘从柱2移动到柱3，前提是前(N − 2)个盘子已经按顺序摆在了柱1上 # 。。。。。。 def TowersOfHanoi(numberOfDisks, startPeg=1, endPeg=3): #共三个柱子 \"\"\" numberOfDisks:当前盘子的号码 总共四个盘子 号码1~4对应盘子从小到大 startPeg:起始的柱子 endPeg:结束的柱子 \"\"\" if numberOfDisks > 0: TowersOfHanoi(numberOfDisks-1, startPeg, 6-startPeg-endPeg) # 1+2+3=6 print(f\"Move disk {numberOfDisks} from peg {startPeg} to peg {endPeg}\") #将几号盘子从几号柱子移到几号柱子 TowersOfHanoi(numberOfDisks-1, 6-startPeg-endPeg, endPeg) TowersOfHanoi(numberOfDisks=4) #指定4个盘子 %/accordion% %accordion% 八皇后问题 %accordion% # 规则：在8x8的棋盘上，摆上8个皇后，确保之间不会冲突（皇后的横、纵以及两个斜对角线上都不能放皇后） # 思路：类似于暴力搜索的问题 def is_conflict(solution, newpos): #用于判断新摆放的皇后是否与之前放好的冲突 # 冲突返回True # 不冲突返回False ''' 示例： solution = [(0,0), (1,2)] newpos = (2,3) ''' for pos in solution: # 同行，同列，对角线都算冲突 if pos[0] == newpos[0] or pos[1] == newpos[1] \\ or abs(pos[0] - newpos[0]) == abs(pos[1] - newpos[1]): return True return False def play(row=0, solution=[]): \"\"\" solution是一个列表，里面是皇后放置的坐标 \"\"\" checker = 8 # 从第一行开始放 if row == checker: #row等于8说明皇后摆放完毕 yield solution #返回结果 else: for i in range(checker): #否则遍历一到八列，看看能否放置皇后 newpos = (row, i) if not is_conflict(solution, newpos): #如果不冲突，则继续按照这条路放置下去 for sol in play(row+1, solution+[newpos]): #进行递归 # print(len(sol)) yield sol n = 0 for sol in play(): n += 1 print(sol) # 可视化棋盘 for chess in sol: start = chess[1] #摆放的列号 print(\"🔘\"*start, \"🔵\", \"🔘\"*(7-start), sep=\"\") print('~'*30) print(f'八皇后问题总共 {n} 种解法') %/accordion% ⭕ 打字效果 # print 的一些参数 print('hello', 'world', sep='555', flush='', end='') import time import random text = 'hello world' for ch in text: print('|', end='', flush=True) time.sleep(0.2) print('\\b', end='', flush=True) num = random.randrange(1, 30)/100 time.sleep(num) print(ch, end='', flush=True) ⭕ np.where() 函数 import numpy as np nums = np.arange(1, 11)[::-1] print(nums) #nums是多维数组也是可行的 index = np.where(nums>3) #返回满足条件的下标 index[0] #返回的index是一个元组，所以这里取[0] # 注意里面的值表示的是满足where条件的元素下标 ⭕ zip 函数 a = [1, 2, 3] b = ['hello', 'world'] c = [a, b] print('list(zip(c)):\\t\\t', list(zip(c))) print('list(zip(*c)):\\t\\t', list(zip(*c))) #结果等价于list(zip(a, b))，zip(*)相当于把c解压，ab不再是一个整体而是一一对应 ⭕ 绘图相关 不同库的多子图绘制方法 import matplotlib.pyplot as plt # 创建2x2的子图布局 fig, axes = plt.subplots(2, 2) # 在每个子图中绘制数据 axes[0, 0].plot(x1, y1) axes[0, 1].plot(x2, y2) axes[1, 0].plot(x3, y3) axes[1, 1].plot(x4, y4) plt.show() import seaborn as sns # 创建FacetGrid grid = sns.FacetGrid(data, col='category', row='subcategory') # 在每个子图中绘制数据 grid.map(plt.plot, 'x', 'y') plt.show() from plotly.subplots import make_subplots import plotly.graph_objects as go # 创建4个子图的图表 fig = make_subplots(rows=2, cols=2) # 在每个子图中添加图形 fig.add_trace(go.Scatter(x=x1, y=y1), row=1, col=1) fig.add_trace(go.Scatter(x=x2, y=y2), row=1, col=2) fig.add_trace(go.Scatter(x=x3, y=y3), row=2, col=1) fig.add_trace(go.Scatter(x=x4, y=y4), row=2, col=2) fig.show() 通过 ax 设置子图的参数 可以使用它来设置坐标轴、标签、标题、线条样式等 ⭕ a.empty、a.all()、a.any() import pandas as pd a = pd.Series([True, False, True]) print(a.empty) #判断是否为空，是返回True，否返回False print(a.all()) #判断是否全为True，是返回True，否返回False print(a.any()) #判断是否存在True，是返回True，否返回False ⭕ 海象操作符 Walrus operator，于 Python 3.8 版本引入海象操作符使用符号 :=，允许在表达式中 同时进行变量赋值和表达式求值 # 注意两边的圆括号不能少 >>> (a := 123) 123 >>> (a := [2,4,6]) [2,4,6] >>> (a := 'hello') 'hello' >>> (a := ' ^_^ ') ' ^_^ ' ⭕ 排序，并且需要原数组的下标 a = ['ab', 'abcde', 'abc', 'abcd', 'a',] temp = sorted(enumerate(a), key=lambda x:len(x[1]), reverse=True) #根据字符串的长度降序排列，注意使用 enumerate 函数 idx = [i[0] for i in temp] #原本字符串的位置下标 problem = [i[1] for i in temp] #排好序后的数组 a 若是 numpy 数组，则可以： import numpy as np a = np.array([4,2,1,100,-4]) b = a.argsort() #直接得到各元素排好序后对应的下标 a[b] #即排好序的数组 ⭕ 局部变量 nonlocal、全局变量 global 详见：https://blog.csdn.net/xCyansun/article/details/79672634 1、两者使用的范围不同 global 关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global 修饰后也可以直接使用 而 nonlocal 关键字只能用于 嵌套函数 中，并且要在外层函数中定义相应的局部变量，否则会发生错误 2、两者的功能不同 global 关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量 而 nonlocal 关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal 位置会发生错误（最上层的函数使用 nonlocal 修饰变量必定会报错） 注意减少 global 变量的使用，减少资源消耗 ⭕ URL 的参数提取问题 from urllib.parse import urlparse, parse_qs url = 'https://www.google.com/search?newwindow=1&biw=1091&bih=763' params = parse_qs(urlparse(url).query) print(params) print(params['newwindow']) print(params['biw']) 注意导入特定的函数会比导入整个模块更加高效因为导入整个模块会将整个模块的代码加载到内存中，而导入特定的函数或类 只会加载需要的部分，可以减少内存的使用量，并减少加载时间这对于大型项目或需要频繁导入的代码来说尤为重要 ⭕ swapaxes 函数 对于 numpy 数组来说，可以快速地交换两个 axis 的位置 import numpy as np arr = np.arange(24).reshape((2, 3, 4)) #假设一开始的 shape 是 (2, 3, 4) arr.swapaxes(0, 1) #交换第一个和第二个轴，变成 (3, 2, 4) arr.swapaxes(0, 2) #交换第一个和第三个轴，变成 (4, 3, 2) arr.swapaxes(1, 2) #交换第二个和第三个轴，变成 (2, 4, 3) ⭕ 变量的下划线 前置的单下划线：_something 约定用于 提示 其他程序员，此类一般 供内部使用 注意 通过通配符 * 导从模块中导入所有函数，Python 将不会导入前置单下划线的函数 后置的单下划线：something_ 防止自己定义的属性名与 Python 内置的关键字 重名，可以简单的加一个下划线 前置的双下划线：__something 遇到这类 Python 解释器会 重写属性名称，避免子类中命名冲突 前后置的双下划线：__something__ 一般不这样定义，因为双下划线常用于 __init__、__call__、__iter__、__next__ 这些方法 单独的下划线：_ 例如 for _ in range(n)，充当用不到的变量 ⭕ 关于 __call__() 调用函数时，若需要 额外运行某些内容，则可以重写 __call__() 函数，例如 class A: def __call__(self, name): print('我的名字是：{}'.format(name)) res = self.forward(name) #调用下面的 forward 函数 return res def forward(self, input_): print('forward 函数被调用了') print('传入参数类型是：{}'.format(type(input_))) return input_ >>> a = A() >>> input_param = a('python') 我的名字是：python forward 函数被调用了 传入参数类型是： ⭕ 求均值、最大、最小 import numpy as np arr = np.random.uniform(20, 40, size=(4, 5)) # 计算每行的均值，每列相加再除以列数 row_mean = arr.mean(axis=1) # 计算每列的均值，每行相加再除以行数 col_max = arr.max(axis=0) # 获取最小值的索引 index_min = arr.argmin() ⭕ input 内容的处理 a, b, c = map(int, input().split(',')) a, b, c ⭕ NaN 值 import numpy as np print(np.NaN is np.NaN) #True print(np.NaN == np.NaN) #False ⭕ subprocess # https://www.cnblogs.com/lgj8/p/12132829.html # 用subprocess这个模块来产生子进程，并连接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值 import subprocess # 例子 p = subprocess.Popen(\"df -h\", shell=True, stdout=subprocess.PIPE) #查看磁盘分区挂载情况 out = p.stdout.readlines() for line in out: print(line.strip()) p.communicate() # 使用 subprocess 模块的 Popen 调用外部程序，stdout 或 stderr 参数是 pipe # 推荐使用 Popen.communicate() # 因为当程序输出超过操作系统的 pipe size 时，如果使用 Popen.wait() 方式等待程序结束获取返回值，会导致死锁，程序卡在 wait() 调用上 ⭕ 可交互 3D 图像示例 import numpy as np import scipy.special as sc import matplotlib.pyplot as plt def drumhead_height(n, k, distance, angle, t): kth_zero = sc.jn_zeros(n, k)[-1] return np.cos(t) * np.cos(n*angle) * sc.jn(n, distance*kth_zero) # 弧度 theta = np.r_[0:2*np.pi:50j] radius = np.r_[0:1:50j] x = np.array([r * np.cos(theta) for r in radius]) y = np.array([r * np.sin(theta) for r in radius]) z = np.array([drumhead_height(1, 1, r, theta, 0.5) for r in radius]) # 交互图像绘制 from ipywidgets import interact, fixed # elev控制观察的角度，azim控制左右的旋转 def plot_3D(elev=20, azim=50, x=x, y=y, z=z): fig = plt.figure(figsize=(10, 8)) ax = plt.subplot(projection='3d') ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='RdBu_r', vmin=-0.5, vmax=0.5) ax.view_init(elev=elev, azim=azim); ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_xticks(np.arange(-1, 1.1, 0.5)) ax.set_yticks(np.arange(-1, 1.1, 0.5)) interact(plot_3D, elev=[20, 90], azim=(-180,180), x=fixed(x), y=fixed(y), z=fixed(z) ); ⭕ 脚本的参数传入 import os import argparse class Parser(): def __init__(self, description): self.parser = argparse.ArgumentParser(description=description) self.args = None self._parse() def _parse(self): \"\"\" 设置传参格式、类型、默认值、help内容 \"\"\" self.parser.add_argument( '--path', type=str, default=None, help='图片集合的路径') self.parser.add_argument( '--resize', type=str, default='512x512', help='修改图片大小为 512x512 (default: 512x12)') self.parser.add_argument( '--rename', type=str, default='no', help='整理修改文件名 (default: 不修改)') self.args = self.parser.parse_args() description = None print(Parser(description).args.path) print(Parser(description).args.resize) print(Parser(description).args.rename) ⭕ DataFrame 中 drop 的用法，删除行或者列 import pandas as pd df = { 'DataBase':['mysql','test','test','test','test'], 'table':['user','student','course','sc','book'] } df = pd.DataFrame(df) # 删除行 df.drop(index=(df.loc[df['table']=='sc'].index), inplace=False) # 删除列 df.drop(columns=['table']) ⭕ 生成独热编码的方式 # 方法一 sklearn 里面的 One-HotEncoder 方法 # 方法二 pd.get_dummies() ⭕ 奇异值分解和特征值分解 先由一个非对称的矩阵 A 得到对称矩阵 A1 和 A2然后对 A1 做特征值分解得到右奇异向量和奇异值 奇异值分解得到的奇异值 == 奇异矩阵特征值分解的特征值开根号 根据公式推出左奇异向量最后根据 USV.T 得到原矩阵的近似矩阵 # https://zhuanlan.zhihu.com/p/29846048 import numpy as np A = np.array([[0, 1], [1, 1], [1, 0]]) A1 = A.T @ A #右奇异矩阵，对称正交矩阵 A2 = A @ A.T #左奇异矩阵 u, s, vT = np.linalg.svd(A) #奇异值分解，适用于所有类型的矩阵，包括方阵或者非方阵。注意这里的s是一个向量，存放各个奇异值 eval1, evec1 = np.linalg.eig(A1) #得到右奇异向量 # eval2, evec2 = np.linalg.eig(A2) #注意不可以直接求解左奇异向量,存在正负号的问题 print(np.allclose(np.sqrt(eval1[0]), s[0])) smat = np.zeros([u.shape[1], vT.shape[0]]) #初始化一个方阵smat，其对角线元素是s smat[range(s.shape[0]), range(s.shape[0])] = s print(u @ smat @ vT) evec2 = A@evec1/np.sqrt(eval1) #根据US=AV推出左奇异向量u smat = np.zeros([evec2.shape[0], evec1.T.shape[0]]) smat[range(eval1.shape[0]), range(eval1.shape[0])] = np.sqrt(eval1) # 注意若 A 不是方阵，则这样推出的左奇异向量构成的矩阵会缺少几列向量，需要补零向量 evec2 = np.append(evec2, np.zeros([evec2.shape[0], smat.shape[0]-evec2.shape[1]]), axis=1) #右侧添零向量 print(evec2 @ smat @ evec1.T) #重构出的近似原矩阵 ⭕ 图像 color bar 设置 import numpy as np import matplotlib.pyplot as plt import seaborn as sns a = np.array([[1,2,3], [4,5,6], [7,8,9]]) fig, ax = plt.subplots(1,1, figsize=(10, 8)) ax = sns.heatmap(a, annot=True, annot_kws={'fontsize':20}, cbar=False) #取消热力图自带的cbar mycbar = ax.figure.colorbar(ax.collections[0]) mycbar.ax.tick_params(labelsize=15) plt.xticks(fontsize=18) plt.yticks(fontsize=18) plt.show() ⭕ 文件打包下载 !zip -q -r output.zip \"\\文件夹路径。。。\\*\" from IPython.display import FileLink FileLink('output.zip') ⭕ mp4 转 gif from moviepy.editor import * clip = (VideoFileClip(r\"。。。.mp4\").subclip(t_start=1, t_end=2).resize(0.5)) #resize中也可以直接传入元组设置画面大小 clip.write_gif(r\"。。。.gif\", fps=15) ⭕ 算法题中出现的缓存 from functools import lru_cache def test(a,b): print('开始计算a+b的值...') return a + b print('1+2等于:', test(1, 2)) print('1+2等于:', test(1, 2)) # 开始计算a+b的值... # 1+2等于: 3 # 开始计算a+b的值... # 1+2等于: 3 print('='*10) @lru_cache(maxsize=None) # 等价于@cache def test(a,b): print('开始计算a+b的值...') return a + b print('1+2等于:', test(1, 2)) print('1+2等于:', test(1, 2)) #这里会直接调用缓存中已存在的结果 # 开始计算a+b的值... # 1+2等于: 3 # 1+2等于: 3 ⭕ zip(*nums) 实现对矩阵的逆时针旋转 nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]] print(nums) print(list(zip(*nums))) ⭕ 关于 PYTHONPATH 设置 PYTHONPATH 环境变量的作用，https://github.com/ydf0509/pythonpathdemo pycharm 会自动把项目根目录加到了 PYTHONPATHcmd 中设置临时的环境变量：set PYTHONPATH=项目根目录 & python run.pywin10/11 的 powershell：$env:PYTHONPATH=\"项目根目录\" & python run.pylinux：export PYTHONPATH=项目根目录;python run.py 设置多个环境变量，linux是 : 隔开，win是 ; 隔开 export PYTHONPATH=/codes/proj1:/codes/proj2 手动硬编码 sys.path 的方法（即在脚本中添加搜索路径）不可取，因为这样需要对每个脚本进行修改，费时费力在控制台命令行部署运行任何项目，把PYTHONPATH设置为 项目根目录路径 是最合适的 运行任何python项目设置 PYTHONPATH 为当前项目根目录的 4 个好处：1、任意项目目录下的任意深层级文件夹下的多个脚本都可以轻松作为python运行起点2、不需要 sys.path.insert3、使用从项目根目录往下寻找模块，用绝对导入，写的脚本位置可以四处移动，代码非常牢固，可靠性高4、与 pycharm 的运行行为保持了一致 sys.path 越靠前的文件夹路径越优先被查找 ⭕ yield 每次碰到 yield，执行完后会停止，直到 next 操作时，再从停止的位置开始执行 # 例1 def foo(): print(\"starting...\") while True: res = yield 4 print(\"res:\",res) g = foo() print(next(g)) print(\"*\"*20) print(next(g)) 执行步骤：1、foo 函数中有 yield 关键字，所以 foo 函数并不会真的执行，而是先得到一个生成器 g（相当于一个对象）2、直到调用 next 方法，foo 函数正式开始执行。先执行 foo 函数中的 print 方法，然后进入 while 循环3、程序遇到 yield 关键字，把 yield 想像成 return，return 4 之后，程序停止，并没有执行赋值给 res 操作，此时 next(g) 语句执行完成4、程序执行 print(\"\"20)，输出 20 个 *5、再执行下面的 print(next(g))，这时和上面类似，不同的是需要从前面 next 程序停止的地方开始执行，也就是要执行 res 的赋值操作。这时候要注意，这个时候赋值操作的右边是没有值的，所以这个时候 res 的值是 None6、程序会继续在 while 里执行，若执行 next 操作，则又会碰到 yield，这个时候同样 return出 4 # 例2 def foo(): print(\"starting...\") while True: res = yield 4 print(\"res:\",res) g = foo() print(next(g)) print(\"*\"*20) print(g.send(7)) # 这里向 foo 发送了 7，故 res 为 7 # sent() 方法带有 next() 方法，故会继续执行直到再一次碰到 yield 通过将 yield 与生成器结合使用，可以 实现惰性计算，从而减少内存占用。生成器是一种特殊类型的迭代器，使用 yield 语句来生成值，每次生成一个值后就会暂停执行，并保持当前的状态，等待下一次调用时继续执行。相比于一次性生成所有值并存储在内存中，生成器每次只会生成一个值，因此可以显著减少内存使用量 ⭕ Python 的一些模式 抽象工厂模式 import random class PetShop: \"\"\" 一个宠物商店类 \"\"\" def __init__(self, animal_factory=None): self.pet_factory = animal_factory #抽象工厂 def show_pet(self): \"\"\" 使用抽象工厂创建并显示宠物 \"\"\" pet = self.pet_factory.get_pet() print(\"This is a lovely\", pet) print(\"It says\", pet.speak()) print(\"It eats\", self.pet_factory.get_food()) # 工厂生产的东西 class Dog: def speak(self): return \"woof\" def __str__(self): return \"Dog\" class Cat: def speak(self): return \"meow\" def __str__(self): return \"Cat\" # 工厂类别 class DogFactory: def get_pet(self): return Dog() def get_food(self): return \"dog food\" class CatFactory: def get_pet(self): return Cat() def get_food(self): return \"cat food\" # 创建合适的家族 def get_factory(): \"\"\" 动态随机选择宠物工厂 \"\"\" return random.choice([DogFactory, CatFactory])() # 展示各工厂的宠物 if __name__ == \"__main__\": shop = PetShop() #工厂animal_factory默认为None，所以这里可以不用传入 for i in range(3): shop.pet_factory = get_factory() #设置实例shop的属性 shop.show_pet() print(\"=\" * 20) # 实例化一次类，可以通过指定属性，达到使用多次的效果 通过使用抽象工厂和具体工厂类，客户端代码与具体宠物类的实现解耦，并且可以根据需要动态切换不同的工厂，从而创建不同的宠物 适配器模式 class Dog(object): def __init__(self): self.name = \"Dog\" def bark(self): return \"woof!\" class Cat(object): def __init__(self): self.name = \"Cat\" def meow(self): return \"meow!\" class Human(object): def __init__(self): self.name = \"Human\" def speak(self): return \"hello\" class Car(object): def __init__(self): self.name = \"Car\" def make_noise(self, octane_level): return f\"vroom{'!' * octane_level}\" class Adapter(object): \"\"\" 通过替换方法来改写对象 Usage: dog = Dog dog = Adapter(dog, dict(sound=dog.bark)) \"\"\" def __init__(self, obj, adapted_methods): \"\"\" 我们在对象的 dict 中设置了 adapted methods \"\"\" self.obj = obj self.__dict__.update(adapted_methods) def __getattr__(self, attr): \"\"\" 所有 non-adapted 的调用都传递给对象 \"\"\" return getattr(self.obj, attr) def main(): objects = [] dog = Dog() objects.append(Adapter(dog, dict(sound=dog.bark))) cat = Cat() objects.append(Adapter(cat, dict(sound=cat.meow))) human = Human() objects.append(Adapter(human, dict(sound=human.speak))) car = Car() car_noise = lambda: car.make_noise(5) objects.append(Adapter(car, dict(sound=car_noise))) for obj in objects: print(\"A\", obj.name, \"goes\", obj.sound()) if __name__ == \"__main__\": main() 在这段代码中，我们有几个类：Dog、Cat、Human和Car，它们分别拥有不同的行为和方法。然后通过Adapter类将这些类的方法统一适配器类在创建时会设置自己的 __dict__，以将适配后的方法添加到自身的属性中。此外，__getattr__ 方法用于将所有未适配的方法调用传递给原始对象通过适配器模式，我们可以 将不兼容的类的接口转换成统一的接口，从而使它们能够协同工作，并且客户端代码不需要关心不同对象的具体实现细节 ⭕ 语法糖 函数装饰器 比如：@classmethod，@staticmethod，@property，@xxx.setter，@wraps()，@func_name 装饰的对象是 函数或者方法 作用：改变被装饰函数或者方法的功能、性质 装饰器经常被用于有 切面需求 的场景，较为经典的有 插入日志、性能测试、事务处理 等 @funA def funB(): #... # 将 funB 作为参数传给 funA() 函数 # 将 funA() 函数执行完成的返回值反馈回 funB @funA @funB @funC def fun(): #... fun = funA( funB( funC(fun) ) ) 实例方法 即类里面定义的函数 一般通过 实例化后的类对象访问 若想要通过类名访问，必须传入实例对象名，也可以直接传入字母c？？？ 类方法 class ...: @classmethod def info(cls): print(\"正在调用类方法\", cls) 推荐 直接通过类名调用 注意 如果没有 ＠classmethod，则 Python 解释器会将 info() 方法认定为实例方法，而不是类方法 静态方法 静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中 类的静态方法中 无法调用任何类属性和类方法 class ...: @staticmethod def info(name, add): print(name, add) 也是推荐 直接通过类名调用 实用的方法 hasattr() 函数用来判断某个类实例对象是否包含指定名称的 属性或方法 getattr() 函数获取某个类实例对象中指定 属性 的值，若是方法则返回方法的状态 setattr() 它最基础的功能是 修改类实例对象中的属性值。其次，它还可以实现 为实例对象动态添加 属性或者方法 issubclass(cls, class_or_tuple) 检查 cls 是否为第二个参数中类的 子类 isinstance(obj, class_or_tuple) 检查 obj 是否为第二个参数中类的 实例 ⭕ 模块、包、库 模块 一个模块就是一个 .py 文件，里面定义了一些函数和变量，需要的时候就可以导入这些模块（.py文件），特点是规模较小 调用模块方式 1、from 模块名 import 函数名 2、import 模块名，然后可以使用 as 为模块或函数起一个别名 from 模块名 import *，这样可以直接把模块里的所有函数导入，但是不推荐，不同模块之间可能存在重名函数 用 import 语句导入模块，Python 会按照下列路径依次寻找目标模块： 1、当前的工作目录 2、PYTHONPATH（一个环境变量）中的所有目录 3、Python 默认的安装目录 包 多个模块放在一个文件夹，就是一个包 为了方便管理而将 .py 文件进行打包。包目录下第一个文件便是 __init__.py（特点），然后是一些模块文件和子目录等 其有下列性质 1、包本身也是一个模块 2、模块名不是 __init__，而是包的名字，也就是装着 __init__.py 文件的文件夹名 __init__.py 的作用是将一个文件夹变为一个 Python 模块它一般会包含一些 Python 初始化代码（例如批量导入需要的模块），在这个包被 import 的时候，这些代码会自动被执行。不过什么也不写也是可以的 调用方法，与调用模块类似 1、import 包名.模块名 2、import 包名.模块名 as 模块别名 库 具有相关功能模块的集合 这也是 Python 的一大特色之一，Python 具有强大的标准库、第三方库以及自定义模块 严格来说 Python 中是没有库（library）的概念，其实是借用其他编程语言的概念，库没有特别具体的定义，只是一个通俗的说法 所以平时说的库，既可以是一个模块，也可以是一个包 ⭕ utils 文件夹 通常用于存放项目中使用的 工具函数或辅助功能 的代码文件通过将这些功能封装成函数或类，可以在项目的不同部分进行 重复使用，提高代码的 可维护性和复用性。例如：1、数据处理函数：用于处理数据集、数据转换、数据清洗、特征提取等操作2、文件操作函数：用于读取和写入文件、创建目录、删除文件等操作3、日期时间处理函数：用于日期时间的格式化、计算、转换等操作4、字符串处理函数：用于字符串的拼接、分割、替换、编码解码等操作5、日志记录函数：用于记录程序运行过程中的日志信息，方便调试和错误追踪 ⭕ 网络编程 内置库 socket：提供了一组简单的套接字 API，可以用于客户端/服务器编程。涵盖了网络通信的很多细节，套接字、绑定地址、监听请求等等 SocketServer：简化网络服务器的开发，是对 socket 库的一个封装，实现了 多线程、多进程 等服务器，帮助你快速开发服务器端程序 httplib：提供了一组 API，可以用于发送 HTTP 请求和解析 HTTP 响应 urllib：提供了一组 API，可以用于打开和读取 URL 第三方库 BeautifulSoup：可以用于解析 HTML 和 XML 文档，方便爬虫编程 Scrapy：高级的爬虫框架 TCP 发送数据时，TCP 连接已建立好，所以不需要指定地址UDP 是面向无连接的，每次发送要先指定是发给谁服务端与客户端不能直接发送列表，元组，字典。需要字符串化 repr(data) 在通讯过程中，两端设备的信息传输方式 单工（单向通信）：只有一端设备可以发送信息，另一端只能接收信息，且发送和接收信息不能同时 半双工（半双向通信）：两端设备既可以发送，也可以接收信息，但两端 不能同时发送。两端 各自占有 通讯频道，在不同的时间段内 交替发送和接收信息 全双工（全双向通信）：两端设备既可以发送，也可以接收信息，并且两端 可以同时发送。两端设备可以 同时占有 通讯频道，并且 同时进行信息的传输 全双工实例 服务器端 import socket import threading server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定端口 server_socket.bind(('0.0.0.0', 8000)) # 监听 server_socket.listen() connection, address = server_socket.accept() print(f'Accepted connection from {address}') def receive_data(): while True: data = connection.recv(1024).decode() if not data: break print(f'Received data: {data}') def send_data(): while True: data = input('Enter message to send: ') connection.sendall(data.encode()) if data == 'quit': break receive_thread = threading.Thread(target=receive_data) send_thread = threading.Thread(target=send_data) receive_thread.start() send_thread.start() receive_thread.join() send_thread.join() connection.close() 客户端 import socket import threading client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect(('localhost', 8000)) # 此处的代码块同上服务端的 client_socket.close() 开启两个终端，先运行服务端，再运行客户端 ⭕ 并发和并行 并发（Concurrency） 是指 多个任务交替执行的能力 在并发中，多个任务在时间上交错执行，每个任务执行一小段时间，然后切换到下一个任务 这种交错执行的方式可以使得多个任务 看起来是同时进行的，虽然实际上每个任务 并不一定在同一时刻 执行。在单核处理器上实现，通过 时间片轮转 等技术进行任务切换 并行（Parallelism） 是指 多个任务同时执行的能力 在并行中，多个任务真正地在 同一时刻执行，每个任务使用不同的执行单元或处理器，从而显著提高了整体的执行速度 需要 多核处理器或者分布式系统 的支持 并发和并行都涉及多个任务同时执行的概念它们都旨在 提高程序执行效率和资源利用率 注意并发和并行并不是绝对的对立关系 ⭕ 线程、进程 程序 > 进程 > 线程一个程序里面至少有一个进程，一个进程里面至少有一个线程，线程之间资源是共享的。每个进程都有一个独立的内存空间，但这也使得 进程之间不能共享内存操作系统创建进程需要分配独立的内存空间，所以创建线程的代价也比较小 线程是操作系统能够进行 运算调度的最小单位，线程之间可以 并发进行，且共享一个进程的所有资源，这使得同一进程的线程之间容易实现通信（难点是处理好同步与互斥） 在 Python 解释器中，虽然可以创建多个线程，但只有一个线程能够在任意时刻执行 Python 字节码（通常指 CPython 解释器），其他线程处于等待状态（即 Python 的多线程不能真正的做到并行计算，可以考虑多进程）全局解释器锁（GIL）是 CPython 解释器的一个特性。它是一种限制机制，确保同一时间只有一个线程可以执行字节码。GIL 的存在是为了 保证 CPython 的内存管理能够安全运行，同时避免细粒度的数据同步问题在一个线程拿到 GIL 后，它可以执行一段时间，然后释放 GIL，让其他线程有机会执行，具体的执行过程如下：1、线程获取 GIL2、Python 解释器调度操作系统原生线程，并执行相关的计算任务3、执行时间片结束或因为 I/O 等原因需要释放 GIL，将 GIL 让给其他线程4、其他线程再次获取 GIL，继续执行自己的计算任务5、这个过程不断重复，每个线程轮流获取 GIL 并执行自己的任务，通过上下文切换（context switch）实现多线程并发执行 多进程适用于 CPU 密集型操作（例如多数位的 浮点运算）多线程适用于 IO 密集型操作（例如 数据读写 操作） 当一个线程遇到耗时操作并解开了 GIL 后，它会让其他线程先执行，但是 它自己并不会停止运行。解开 GIL 只是允许其他线程在 Python 解释器中执行，而不是让当前线程停止运行，这一点与串行运行不同 ⭕ 多线程、协程、异步 多线程（Multithreading） 程序可以同时执行多个线程，每个线程都是 独立执行 的，具有自己的 指令流和栈空间 多线程在 处理并行任务 时非常有用，可以提高程序的性能和响应能力，特别是在涉及 I/O 操作或需要同时处理多个任务的情况下 两类代码 I/O 密集型（文件处理、网络请求爬虫等涉及文件读写的操作） CPU 密集型（各种循环处理、计算等） 注意Python 的多线程不能真正做到并行处理（因为 GIL 锁）在 Python 中，对于 I/O 密集型任务，由于 线程在等待 I/O 完成时会释放 GIL，所以可以实现并发执行并提高性能；CPU 密集型的多线程会涉及 GIL 的释放与再竞争，而导致执行效率下降 threading 模块https://zhuanlan.zhihu.com/p/91601448https://www.cnblogs.com/luyuze95/p/11289143.html 锁，为了确定执行线程的先后顺序https://zhuanlan.zhihu.com/p/94344847 协程（Coroutines） 一种用户级线程，也称为轻量级线程或子程序。和多线程不同，协程在执行过程中可以 主动地暂停和恢复，并且可以在代码中进行 交互 协程通常用于 处理大量的并发任务，可以显著提高程序的效率和可伸缩性 asyncio 模块 异步编程（Asynchronous Programming） 使得程序能够以 非阻塞 的方式处理 并发任务，从而提高效率 通常使用异步函数、回调函数或协程等技术来实现 异步编程在处理 I/O 密集型任务 时尤为有效，可以最大限度地利用计算资源 asyncio、aiohttp、asyncpg、celery、funboost 等库 https://zhuanlan.zhihu.com/p/587412153 https://github.com/ydf0509/funboost https://funboost.readthedocs.io/zh/latest/index.html 都是可用于 处理并发任务 的编程模型，可以充分利用计算资源，提高程序的性能和响应能力它们都可以在执行任务时实现 非阻塞 的特性，从而避免资源的浪费和效率低下的问题 实例 异步网络请求：使用 aiohttp 库进行异步网络请求的练习。您可以编写一个程序，同时发送多个 HTTP 请求，而不会阻塞主线程。这可以用于实现高性能的网络爬虫或 API 请求 import aiohttp import asyncio async def fetch_url(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: return await response.text() async def main(): urls = [\"https://example.com\", \"https://example.org\", \"https://example.net\"] tasks = [fetch_url(url) for url in urls] responses = await asyncio.gather(*tasks) for response in responses: print(len(response)) if __name__ == \"__main__\": asyncio.run(main()) 异步文件操作：使用 aiofiles 库进行异步文件操作的练习。这允许您并发地读写文件，而不会阻塞程序 import aiofiles import asyncio async def write_to_file(filename, data): async with aiofiles.open(filename, 'w') as file: await file.write(data) async def read_from_file(filename): async with aiofiles.open(filename, 'r') as file: return await file.read() async def main(): await write_to_file('example.txt', 'Hello, async file I/O!') data = await read_from_file('example.txt') print(data) if __name__ == \"__main__\": asyncio.run(main()) ⭕ __str__ 和 __repr__ print 会优先调用 __str__，如若没有定义则会调用 __repr__ 方法__repr__ 主要用于调试和开发，输出的内容包括对象的类型、值等信息__str__ 的输出更加直观和易读 ✨帅地面试题 ⭕ Python 简介 是一个编程语言 是解释型脚本语言，无需编译，只需要解释器，但是运行速度慢于编译型语言 动态类型语言，声明变量时无需说明类型 适合面向对象编程，支持通过组合与继承的方式定义类 强类型语言。不允许不同类型相加 解释型、编译型计算机不能直接理解高级语言，需要 翻译成机器语言解释型语言在 运行程序 时进行翻译编译型语言在执行之前需要一个专门的 编译过程，把程序编译成机器语言（可执行文件） ⭕ 赋值、浅拷贝、深拷贝 赋值 Python 中的赋值是简单的 对象引用，不会创建新对象 若 b = a，则 a 和 b 指向同一片内存空间，可以使用 id() 查看 若修改 a，则 b 也会跟着改变 浅拷贝 三种形式： 切片操作：b = a[:] 或者 b = [x for x in a] 工厂函数：b = list(a) copy 函数：b = copy.copy(a) 以上操作都会创建新对象，通过 id() 查看 b 和 a 的内存空间是不同的 注意若 a 里面有 嵌套的列表，它们指向的位置还是一样的。即对 a 中的列表进行修改，b 对应的也会改变 深拷贝 b = copy.deepcopy(a) b 是全新的对象，与 a 没有任何关联 时间、空间开销更高 注意数字、字符是 非容器类型，没有拷贝一说 ⭕ Python 的作用域 搜索顺序：Local，本地作用域Enclosing Local，当前作用域被嵌入的本地作用域Global，全局作用域Built-in，内置作用域 ⭕ Python 自省 即自我检查能力dir()，可以用来查看 对象的属性名称type()，查看对象的 类型getattr()，查看对象的 属性hasattr()，查看对象 是否拥有某属性isinstance()，判断某个对象 是否是某个特定的类型 ⭕ Python 提升性能的手段 使用 多进程对性能影响较大的部分使用 c 或者 c++ 编写IO 阻塞采用 IO 多路复用尽量使用 Python 的 内置函数尽量使用 局部变量 ⭕ 字典的 items() 与 iteritems() items()，返回值是 列表 存储的键值对，没有特殊的顺序iteritems()，类似，返回的是一个 迭代器 注意存入字典中的数据没有顺序 ⭕ os.path 和 sys.path os.path 是对系统路径文件的操作sys.path 是对 Python 解释器的系统 环境参数的操作 ⭕ 字典与 JSON 字典：数据结构，要求 value 需要 hashJSON：数据的表现形式，要求 value 是字符串，用双引号 ⭕ 可变、不可变类型 可变，内存中的值可以改变，例如：列表、字典、集合不可变，内存中的值不能改变，例如：数值、字符串、元组字典键要求是：不可变对象 # 数值类型的变量是不可变的 a = 5 print(\"a =\", a, id(a)) # 若要修改变量值，则会重新开辟一块内存空间存放 a 的值 a = 5 + 1 print(\"a =\", a, id(a)) [!NOTE|style:flat] 对不可变类型做深浅拷贝都没用，还是指向同一个地址 ⭕ Python 的内存管理 Python 私有 堆空间：存储对象和数据结构Python 内存管理器：堆空间分配内置 垃圾收集器：回收未使用的内存，并使其可用于堆空间 ⭕ 模块和包是什么？ Python 中 每个代码文件都是模块，模块可以引用其他模块包中含有多个代码文件，里面可以包含模块和子文件夹 ⭕ 类方法、类实例方法、静态方法 类方法：类对象的方法，使用 \"@classmethod\" 来装饰，形参为 cls类实例方法：类实例化对象的方法，形参为 self，指代对象本身静态方法：使用 \"@staticmethod\" 来装饰 ⭕ 内存管理机制、调优手段 涉及到引用计数、垃圾回收、内存池 引用计数 高效，当一个对象被引用时，其引用计数增加 1，不再被引用就减 1，直到为 0 时对象被删除 注意 若出现 循环引用，则该机制不起效果 垃圾回收 涉及到引用计数、标记清除、分代回收 1、引用计数为 0 时，说明需要被当作垃圾回收了 2、标记清除用于 摘掉循环引用，得到真实的有效计数。例如两个对象的引用计数都为 1，但是仅存在它们之间的循环引用，说明二者都是需要被回收的 3、分代回收，当一个内存块中的垃圾 回收次数多但是仍旧有垃圾 存在时，可以考虑和其他的分开处理，隔一段时间再去回收，使得处理次数减少，提高效率 内存池 1、Python 内存机制呈现金字塔形状，第 -1、-2 层主要由 操作系统 来操作 2、第 0 层是 C 语言中的 malloc 和 free 等内存申请、释放函数来操作 3、第 3 层是最上层，Python 对象直接操作 由于 Python 在运行期间会 频繁的执行 malloc 和 free 操作，这会影响执行效率，所以引入内存池机制用来 管理对小块内存的申请和释放。这个小块内存的标准是 256 个字节，小于等于它则在内存池申请，大于它则需要调用 malloc 函数。当然可以通过修改源代码来更改 256 这个值 ⭕ 内存泄漏 指的是由于疏忽或错误造成的 程序未能释放已经不再使用的内存 的情况这会导致程序运行 速度减慢，系统崩溃 等如何防止：当一个对象不使用时，通过 del object 来删除它的 引用计数获取对象的引用计数：sys.getrefcount(object) 并根据返回值来判断内存是否泄漏 ⭕ 函数调用时，参数传递的方式 参数是 不可变 类型时：值传递 只能通过 拷贝 来进行传递，因为原处不可修改 参数是 可变 类型时：引用传递 ⭕ pass 语句 编写代码时只写框架思路，先用 pass 占位，程序不会报错 ⭕ super() 作用 super() 是用来解决 多重继承 问题的单继承的情况下，直接用 类名调用父类（Base类）的方法是没问题的多继承的情况下，会涉及到 查找顺序（MRO）、重复调用（钻石继承） 的问题 ⭕ 回调函数 把函数的指针作为参数传递给另一个函数简单讲就是一个函数作为另一个函数的参数被传入，那么这个函数叫做回调函数 ⭕ 方法重载、方法重写 重载：在同一个类里面，方法名字相同，参数不同。让类以统一的方式处理不同类型数据 为了使得方法能够处理不同类型的数据 重写：子类继承父类的方法 并进行一定的修改，又叫方法覆盖 继承并进行一定的修改 ⭕ 函数装饰器的用途 装饰器本质上是一个 Python 函数，返回值也是 Python 对象作用是让其他函数在 不需要做改动下增加额外的功能，减少与函数功能本身无关的雷同代码用于有 切面需求 的场景：插入日志、性能测试、事务处理、缓存、权限校验等等要求函数可以当作参数传递 ⭕ 生成器、迭代器 Python 中的 list、dict、tuple 也被称为 容器对象 迭代器 假设 for 循环遍历一个容器对象，for 语句对容器对象 调用 iter() 方法，这会返回一个 定义了 next() 方法的迭代器对象，这个迭代器对象逐个访问容器内的元素 生成器 用于 创建迭代器。在需要 返回数据 的时候执行 yield 语句 区别：生成器能实现迭代器的功能，简洁、高效、节省内存 ⭕ is 与 == a is b，通过比较两个对象的内存地址（即使用id()函数返回的唯一标识）来判断它们是否引用同一个对象a == b，比较两个对象的值 注意对于 小整数和一些短字符串，Python 会对它们进行缓存以提高性能，使得两个相同值的对象实际上是同一个对象，这种情况下使用is 运算符比较结果会是 True对于大整数或长字符串等，则不会进行缓存 ⭕ 面向过程、面向对象 二者是 程序设计方法，各有其适用的场景和优劣面向过程：基于功能分析，以算法为中心，将问题分解为一系列的步骤和函数 进行处理。它强调按照过程来组织和管理代码面向对象：基于结构分析，以数据为中心，将问题看作一组对象及其相互作用。它强调通过定义和操作对象来解决问题。其中，类是面向对象的核心概念，通过类可以创建具体的对象。面向对象编程具有封装、继承和多态这三个重要特性 封装（Encapsulation）将数据和操作封装到一个对象中，对外界隐藏内部实现的细节，只提供有限的接口进行访问和操作继承（Inheritance）允许通过定义新类来继承和扩展现有类的属性和方法。继承可以创建类之间的父子关系，子类可以继承父类的属性和方法，并且可以根据需求进行修改和扩展多态（Polymorphism）允许将不同类型的对象当作相同类型的对象对待，通过多态性可以实现 同一个接口实现不同的行为。多态性提高了代码的灵活性和可扩展性 ⭕ GET 与 POST 是 HTTP 协议中的两种常见的请求方法GET：用于从指定的资源请求（获取）数据POST：用于向指定的资源提交（发送）被处理的数据，例如 提交表单 数据或发送包含敏感信息的数据相对于 GET 方法，POST 方法 将数据放在请求的消息体中，而不是显示在 URL 中，因此 POST 方法相对来说 更具有隐蔽性 ⭕ Python2 和 3 的区别 https://www.cnblogs.com/hanggegege/p/5840005.html 黑马博客也有讲 1、print Python2 Python3 print 为 class print 为函数 不需要括号 需要括号 2、input() Python2 Python3 input 得到的是 int 型（用 row_input 才为 str） input 得到的是 str 型 3、除法 Python2 Python3 除数带有小数点，则 / 表示真除，否则为结果取整 / 表示真除 %表示取余 同 Python2 //表示地板除，即结果取整 同 Python2 4、xrange 模块 Python2 Python3 使用xrange创建迭代对象 使用range range(0, 4)返回的是列表[0,1,2,3] range(0, 4)返回的是迭代器，需要再通过list()转换成列表 ⭕ 编码解码 s = \"hello world\" b = s.encode( \"gbk\") # 字符串 s 编码为 gbk 格式的字节序列 s1 = b.decode(\"gbk\") # 将字节序列 b以gbk格式 解码为字符串 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-17 16:54:25 "},"about_Python/机器学习.html":{"url":"about_Python/机器学习.html","title":"机器学习","keywords":"","body":"参考资料 https://github.com/zhouzhongmi/ML_Notes/blob/master/README.md 如何将算法进行封装？ class algorithm_name(object): def __init__(self, 模型参数): self.bins = bins self.thresh = thresh self.thresh_value = None self.hist_bins = {} self.pca = None self.pca_mins = None def fit_transform(self, X): # 模型拟合并计算结果 return (hbos >= self.thresh_value).astype(int) def transform(self, X): # 仅计算结果，将模型应用到传入的参数 X 上 return (hbos >= self.thresh_value).astype(int) EM 算法 降维 奇异值分解 $A$ 是一个 $m \\times n$ 的实矩阵，它可以分解为三个实矩阵的乘积形式 \r A = U\\Sigma V^{T}\r 其中 \r UU^T=I, VV^T=I\\\\\r \\Sigma=diag(\\sigma_1,\\sigma_2,...,\\sigma_p)\r $\\sigma_1 \\geq \\sigma_2 \\geq \\cdots \\geq \\sigma_p \\geq 0$ 且 $p=min(m,n)$ 奇异值分解定理：任意 $m \\times n$ 的实矩阵都可以进行奇异值分解 求 $\\Sigma, V$ 由于 $A$ 是 $m \\times n$ 阶的矩阵，所以 $A^TA$ 是一个 $n \\times n$ 实对称矩阵，故可以对其做正交分解使得： \r V^T(A^TA)V = \\Lambda\r 其中，$V$ 为 n 阶正交实矩阵，$\\Lambda$ 为 $n$ 阶 对角阵，其对角线元素由 $A^TA$ 的特征值 构成，且这些 特征值非负 ![NOTE|style:flat] 假设 $\\lambda$ 是 $A^TA$ 的一个特征值，$x$ 是对应的特征向量，那么 \r > ||Ax||^2=x^TA^TAx=\\lambda x^Tx=\\lambda ||x||^2\r > 所以 \r > \\lambda=\\frac{||Ax||^2}{||x||^2}>0\r > 我们可以通过调整正交矩阵 $V$ 的排列顺序使得对应的特征值形成降序排列 \r \\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq \\lambda_p \\geq 0\r 接着计算奇异值 \r \\sigma_j = \\sqrt{\\lambda_j}, j=1,2,...,q\r 假设 $A$ 的秩为 $r$，则 $A^TA$ 的秩也为 $r$，所以有 \r \\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq \\lambda_r > 0, \\\\ \\lambda_{r+1}=\\lambda_{r+2}=\\cdots=\\lambda_p=0\r 相应的，我们令 \r V_1=[v_1,...,v_r], V_2=[v_{r+1},...,v_p]\r 则 \r V=[V_1\\ V_2]\r 同样地，我们令 \r \\Sigma_1=diag(\\sigma_1,...,\\sigma_r)\r 对其余部分填充 $0$，使得 \r \\Sigma = \\begin{bmatrix}\r \\Sigma_1 & 0 \\\\ \r 0 & 0\r \\end{bmatrix}\r 求 $U$ 构造 $m$ 阶正交实对称矩阵 $U$，我们令 \r u_j = \\frac{1}{\\sigma_j}A v_j, j=1,2,...,r\r 令 \r U_1 = [u_1,...,u_r]\r 则 \r AV_1 = U_1\\Sigma_1\r 接下来，再为 $U1$ 扩充 $m-r$ 个标准正交向量，令 $[u{r+1},...,u_m]$ 为 $N(A^T)$ 的一组正交基，并令 \r U_2 = [u_{r+1},...,u_m] \\\\\r U = [U_1\\ U_2]\r 所以 \r \\begin{align}\r U \\Sigma V^T = \\,& \\begin{bmatrix}\r U_1 & U_2\r \\end{bmatrix}\r \\begin{bmatrix}\r \\Sigma_1 & 0 \\\\\r 0 & 0\r \\end{bmatrix}\r \\begin{bmatrix}\r V_1^T \\\\ \r V_2^T \r \\end{bmatrix} \\\\\r = \\,& U_1 \\Sigma_1 V_1^T \\\\\r = \\,& AV_1V_1^T \\\\\r = \\,& A\r \\end{align}\r 但是 $r 代码示例： import numpy as np import matplotlib.pyplot as plt plt.figure(figsize=(18,4)) im = plt.imread('./.../...jpg') ks = [800,500,200,100,50,10] #分别截取不同的 k for idx, k in enumerate(ks): svd_image = [] for ch in range(3): #注意,有 RGB 三个维度,每个维度对应一个矩阵做 SVD 分解 im_ch = im[:,:, ch] U,D,VT = np.linalg.svd(im_ch) imx = np.matmul(np.matmul(U[:,:k], np.diag(D[:k])), VT[:k,:]) # 将像素值约束到合理范围 imx = np.where(imx255, 255, imx) svd_image.append(imx.astype('uint8')) img = np.stack((svd_image[0], svd_image[1], svd_image[2]), 2) #重构图片矩阵 plt.subplot(1, len(ks), idx+1) plt.imshow(img) plt.axis('off') plt.title(\"k=\"+str(k)) PCA 对原始坐标系进行变换使得原始数据在 新的坐标轴 上的第一个坐标轴上的投影 尽可能分散开，称为 第一主成分，第二个坐标轴次之，称为第二主成分 存在的问题： 如何计算投影坐标？ 将样本点 $x$ 看作一个向量，起点为原点，终点为样本点 $x$ 设一坐标轴的方向向量为 $w$，将其移动至与 $x$ 相同起点的位置，夹角为 $\\theta$ \r ||x|| \\cos\\theta = \\frac{||x||\\cdot||w|| \\cos\\theta}{||w||} = \\frac{x^{T}w}{||w||}\r 如何衡量分散程度？ 利用方差，方差越大，说明数据越分散 \r S(X,w) = \\sum_{i=1}^{m}(x_i^Tw-\\bar{x}^Tw)^2\r $\\bar{x}$ 为 $x_{i} \\in R^{n}$ 的均值 通常在此之前，我们会先进行去中心化操作 \r X = X - \\bar{X}\r 方差就可以简化为 \r \\begin{align}\r S(X,w) = \\,& \\sum_{i=1}^{m}(x_i^Tw)^2 \\\\\r = \\,& w^{T}X^{T}Xw\r \\end{align}\r 故欲求的最优$w^*$便是 \r w^* = arg\\max_{w}w^TX^TXw\r LDA Linear discriminant analysis，线性判别分析，是监督式的降维方法核心思想：找一条直线，使得类内距尽可能小，类间距尽可能大 二分类情况 两个类别对应的样本集合分别为 $X_0,X_1$，中心点分别为 $\\mu_0,\\mu_1$，投影坐标表示为 $w$，那么： （1）类间方差可以表示为 $\\left|\\left|w^T\\mu_0-w^T\\mu_1\\right|\\right|_2^2=w^T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^Tw$ 投影后，类中心点的方差 （2）类内方差可以表示为 $w^T(\\Sigma_0+\\Sigma_1)w$，这里： \r \\Sigma_0=\\sum_{x\\in X_0}(x-\\mu_0)(x-\\mu_0)^T \\\\\r \\Sigma_1=\\sum_{x\\in X_1}(x-\\mu_1)(x-\\mu_1)^T\r 为了方便表示，我们定义： \r S_b = (\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^T\\\\\r S_w = \\Sigma_0+\\Sigma_1\r 所以，我们的优化目标便有了： \r arg\\max_w \\frac{w^TS_bw}{w^TS_ww}\r 多分类情况 作为二分类的推广，对于有 $j=1,2,..,k$ 种类别，定义每种类别对应的样本集为 $X_j$，样本中心点为 $\\mu_j$，样本量为 $N_j$，整体中心点为 $\\mu$，我们可以定义 \r S_b=\\sum_{j=1}^kN_j(\\mu_j-\\mu)(\\mu_j-\\mu)^T\\\\\r S_w=\\sum_{j=1}^k\\sum_{x\\in X_j}(x-\\mu_j)(x-\\mu_j)^T\r 转换成了各类别与整个样本中心点的计算问题 MDS Multiple Dimensional Scaling，多维缩放算法基本思想：数据降维压缩后，不改变样本间彼此的欧氏距离 设原始空间样本集为 $X\\in R^{m\\times n}$样本张成的距离矩阵为 $D\\in R^{m\\times m}$，$D_{ij}$ 表示样本 $x_i$ 与样本 $x_j$ 之间的距离降维后的样本集为 $Z\\in R^{m\\times d}(d目标是让如下关系式成立： \r \\left|\\left| z_i-z_j \\right|\\right| = D_{ij}\r 为了方便处理，我们令 $B=Z^TZ$(即 $B_{ij}=z_i^Tz_j$)，那么上面的关系式可以等价为如下关系： \r \\begin{align}\r D_{ij}^2 = \\,& \\left|\\left|z_i\\right|\\right|^2+\\left|\\left|z_j\\right|\\right|^2-2z_i^Tz_j \\\\\r = \\,& B_{ii}+B_{jj}-2B_{ij}\r \\end{align}\r 所以，我们的目标便是由 $D$ 矩阵推导出 $B$ 矩阵，然后再对 $B$矩阵做正交分解得到 $Z$为了便于处理，我们假设 $Z$ 被去中心化了，即 $\\sum_{i=1}^mz_i=0$，那么有： \r \\sum_{i=1}^mB_{ij}=\\sum_{j=1}^mB_{ij}=0\r 进一步地，有如下关系成立： \r \\sum_{i=1}^mD_{ij}^2=tr(B)+mB_{jj}(关系1)\\\\\r \\sum_{j=1}^mD_{ij}^2=tr(B)+mB_{ii}(关系2)\\\\\r \\sum_{i=1}^m\\sum_{j=1}^mD_{ij}^2=2mtr(B)(关系3)\\\\\r 其中，$tr(B)=\\sum_{i=1}^mz_i^Tz_i$，通过关系1,2,3，我们可以得到$B$关于$D$表达式，为了进一步简化，我们可以令： \r D_{i\\cdot}^2=\\frac{1}{m}\\sum_{j=1}^mD_{ij}^2\\\\\r D_{\\cdot j}^2=\\frac{1}{m}\\sum_{i=1}^mD_{ij}^2\\\\\r D_{\\cdot \\cdot}^2=\\frac{1}{m^2}\\sum_{i=1}^m\\sum_{j=1}^mD_{ij}^2\r 最后： \r B_{ij}=-\\frac{1}{2}(D_{ij}^2-D_{i\\cdot}^2-D_{\\cdot j}^2+D_{\\cdot \\cdot}^2)\r 我们对 $B$ 做特征分解 $B=V\\Lambda V^T$，其中 $\\Lambda=diag(\\lambda_1,\\lambda_2,...,\\lambda_n),\\lambda_1\\geq\\lambda_2\\geq\\cdots\\geq\\lambda_n$，而： \r Z = V\\Lambda^{1/2}\r 与 PCA，LDA 类似地，我们通常只取 $\\Lambda$ 中特征值较大的前几个，对应的 $V$ 也只取前几列 流形学习 Isomap，等度量映射MDS 直接采用了 欧氏距离 构建了原始高维空间的距离，这在流形结构的数据中会出现问题 Isomap的操作： （1）对样本中的每个点，保留与它最近的 $k$ 个点（或者 $\\varepsilon$ 领域半径内的点）的欧氏距离，而其他点的距离设置为无穷大 （2）采用 Dijkstra 算法或者 Floyd 算法计算所有样本中 任意两点间的最短距离，并更新原始距离矩阵 $D$ 之后的操作同 MDS 一样 问题 Isomap 会受到最近邻 $k$ 或者近邻半径 $\\varepsilon$ 的影响 （1）过小，可能会存在“断路”的情况，图中某些区域可能与其他区域不存在连接，直观来看就是距离矩阵通过floyd算法更新后还存在np.inf （2）过大，则会存在“短路”的情况，使得距离失真，比如本节最上图中的黑线距离会取代红线距离 在实际使用时通过后续任务的表现（分类/回归/...任务的具体表现）来选取 LLE Locally Linear Embedding，局部线性嵌入Isomap 使用 floyd 算法求解任意两点之间的最短距离，这使得算法复杂度提升很多为了解决这个问题，LLE仅考虑近邻点之间的线性关系 首先确定近邻点的数量，类似于knn/kmeans中k的选择计算系数矩阵W，使得等式成立： \r x_i=w_{ij}x_j+w_{ik}x_k+w_{il}x_l\r 对于$W$的求解，等价于如下的优化问题 \r \\min_{w_1,w_2,...,w_m}\\sum_{i=1}^m\\left|\\left|x_i-\\sum_{j\\in Q_i}w_{ij}x_j\\right|\\right|_2^2\\\\\r s.t.\\left\\{\\begin{matrix}\r j\\in Q_i & w_{ij}\\geq0\\\\ \r j\\notin Q_i & w_{ij}=0\r \\end{matrix}\\right.\\\\\r \\sum_{j=1}^mw_{ij}=1\r 这是一个带约束的凸优化问题，我们可以通过KKT条件进行求解，令$C_{jk}^i=(x_i-x_j)^T(x_i-x_k)$，那么： \r w_{ij}=\\frac{\\sum_{k\\in Q_i}\\frac{1}{C_{jk}^i}}{\\sum_{l\\in Q_i}\\sum_{s\\in Q_i}\\frac{1}{C_{ls}^i}}\r 之后寻找x在低维空间的点z，使其也满足： \r z_i=w_{ij}z_j+w_{ik}z_k+w_{il}z_l\r 对于低维空间样本点的求解，可以转换为类似的优化问题（并希望各样本之间正交） \r \\min_{z_1,z_2,...,z_m}\\sum_{i=1}^m\\left|\\left|z_i-\\sum_{j\\in Q_i}w_{ij}z_j\\right|\\right|_2^2\\\\\r s.t.\\left\\{\\begin{matrix}\r z_i^Tz_j=1 & i=j\\\\ \r z_i^Tz_j=0 & i\\neq j\r \\end{matrix}\\right.\\\\\r 我们令$M=(I-W)^T(I-W)$，上式可以简化为 \r \\min_Z tr(ZMZ^T)\\\\\r s.t. ZZ^T=I\r 所以，我们只需要对$M$做特征分解，并去最小的$d$个特征值对应的特征向量组成的矩阵，即是$Z$ 异常检测 核心是找到 “不合群” 的点，将 “不合群” 转化为量化指标 HBOS 算法 Histogram-based Outlier Score，基于直方图的异常点检测算法 原理：将数据各维度的直方图概率相加，整体概率值越小的样本越有可能是异常点 衡量指标： \r HBOS(p) = \\sum_{i=1}^{d} log(\\frac{1}{\\text{hist}_{i}(p)})\r $\\text{hist}_{i}^{p}$ 表示样本 p 在第 i 维特征上的 直方图概率（怎么求？？？） 示例代码： # 计算 HBOS 异常值 hbos = np.zeros_like(hist_X[:,0]) for i in range(0, hist_X.shape[1]): hbos += np.log(1.0/(hist_X[:,i]+1e-7)) 如果存在高度相关的因子，HBOS 指标值无法去除相关性一个想法是先利用 PCA 处理数据，去除相关性 IForest 算法 Isolation Forest，孤立森林主要思想：对样本空间，每次随机选取某一维度，在该维度上根据最大最小值随机选择一个阈值对样本进行划分，重复上述操作，直到每个样本被单独分离出来。越早被分离出来的样本越有可能是异常点 KNN 检测 借助最近邻分类的思想，若某个样本与离它最近的k个样本距离之和越大，则它越有可能是异常点对于大量数据，KNN很吃力，平均时间复杂度过高 LOF 算法 Local Ourlier Factor，局部异常因子解决了 KNN 中基于绝对距离而忽略了特殊数据分布的问题局部可达密度局部异常因子 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-18 21:08:54 "},"about_Python/深度学习.html":{"url":"about_Python/深度学习.html","title":"深度学习","keywords":"","body":"关于 ChatGPT 1、应用 ChatGPT + 金融，可以为客户提供智能化的 投资建议和风险管理方案ChatGPT + 医疗，可以 辅助 医生进行 疾病诊断和药物研发ChatGPT + 零售领域，可以为消费者提供 个性化的购物建议和客户服务ChatGPT + 搜索引擎ChatGPT + 智慧办公ChatGPT + 教育ChatGPT + 游戏（策划、内容、制作、美工）ChatGPT + 音乐ChatGPT + 广告营销ChatGPT + 设计ChatGPT + 影视GPT4 可以做到视频剪辑、新闻播报 微软公司一直和 ChatGPT 的母公司 OpenAI 保持合作，他们将 ChatGPT 整合进自己的 bing 搜索引擎里面；谷歌推出类 ChatGPT 的 Bard；百度文心一言...... 2、模型基础 LM Language Model，语言模型，这是ChatGPT的基石的基石 通过已经有的词预测接下来的词 Greedy Search（中文叫贪心搜索），Beam Search（中文叫集束搜索） 简单模型就是把一句话切成一个个词，然后统计概率，这类模型叫做 N-gram 语言模型，是最简单的语言模型，这里的N表示每次用到的上下文长度 实际中我们往往不叫一个词为「词」，而是「Token」，你可以将其理解为一小块，可以是一个字，也可以是两个字的词，或三个字的词，取决于你怎么 Token 化 Transformer 包含 Encode、Decode、Multi-Head 多头自注意力机制 关注 Encoder 中 Token 的信息的机制就是 Attention（注意力机制） Encode 是知道数据的，所以建模时可以同时利用当前的 历史 Token 和未来（前面的）Token；但 Decode 时，因为是一个 Token 一个 Token 输出来的，所以只能根据历史 Token 以及 Encoder 的 Token 表示进行建模，而 不能利用未来的 Token Multi-Head 简单来说，就是把上面这种自注意机制重复 Multi 次（Multi 个 Head），每个注意到的信息不一样，这样就可以捕获到更多信息 GPT 生成式预训练 Transformer 从 GPT-1、GPT-2、GPT-3、GPT-3.5（ChatGPT）一直到现在的 GPT-4 模型参数不断扩大 预训练就是在大量语料上进行预先的训练 Zero-Shot：直接给模型任务输入让它输出任务结果 Few-Shot：给模型提供一些示例，然后再给出任务，让它给出输出结果 RLHF Reinforcement Learning from Human Feedback，从人类反馈中学习。有此利刃，ChatGPT 才是那个 ChatGPT，不然就只能是 GPT-3 3、展望 如今各大公司纷纷推出自己动辄便数千亿级参数量的模型，所用数据更是无法统计，尽管语言模型并非监督训练，但 数据过滤，人工反馈 等阶段还是需要高昂的人力成本；这样超大模型加海量数据的组合，每次训练都需要耗费 数百万美元，用 数千台 GPU 来完成，即使后续更新时并不需要从头训练，但花费依旧不菲，并不是一个可持续性的策略，没点财力的公司，是根本养不起的 当前对话模型更多关注在开放域场景，合理的回复往往不唯一，这意味着在训练阶段很难制作标签，同时在推理时模型也比较容易“放飞自我”，生成千奇百怪的回复结果，其中难免调用一些错误的知识。针对这种“一对多”的场景，很多研究致力于探索对话模型的 可控生成，通过添加一些控制因素，使生成文本满足一定的约束。提示学习（Prompt Learning）本身就是一种 在输入上加入可控因素 从而引导正确的生成，这已经成了最新流行的范式；另外在解码阶段，也可以适当调整策略 对生成的多条候选回复结果重新排序，尽可能选择出 包含目标词汇 的回复结果，控制生成内容 此前研究表明，文本的语言学知识多存储在 模型的低层网络，所以在微调更新时可以 冻结中低层的模型参数，从而加速学习 参考资料 https://github.com/datawhalechina/hugging-llm/blob/main/content/ 吴恩达和 openai 的 prompt 课程 1、模板 import os import openai openai.api_key = os.getenv('OPENAI_API_KEY') def get_completion(prompt, model='gpt-3.5-turbo'): messages = [ {'role': 'user', 'content': prompt}, ] response = openai.ChatCompletion.create( model = model, messages = messages, temperature = 0, ) return response.choices[0].message['content'] def get_completion_from_messages(messages, model='gpt-3.5-turbo', temperature=0): response = openai.ChatCompletion.create( model = model, messages = messages, temperature = temperature, ) return response.choices[0].message['content'] 2、指南 RLHF Reinforcement Learning from Human Feedback，从人类反馈中学习 提示词书写规范 用一些特定符号隔开，让模型知道需要处理的文本是哪部分，例如： \"\"\" 文本 \"\"\" ``` 文本 ``` --- 文本 --- 文本 指定输出格式 让 ChatGPT 用 JSON 或者 HTML 等格式输出，也可以自定义输出格式例如 1) 2) 3) from IPython.display import display, HTML 可以在 jupyter 中展示 HTML 给定少量的训练提示 在 prompt 中给定一个或多个 示例及回答，让 ChatGPT 模仿 多任务情况 分点列出 step，指定每一步要完成的内容 评判对错 在让 ChatGPT 判断某个事物对错之前，先让它自己进行逻辑推断得到结论，再通过对比判断对错 对于生成虚假的内容 为了减少 Hallucinations 幻觉，先让 ChatGPT 找到比较可靠的相关信息，再引用进行回答 3、迭代 不断改进提示词想法 → 实现 → 获得实验结果 → 误差分析 → 新的想法 → 实现 →... 优化 prompt 的步骤 清晰明确地写出 prompt 分析为什么没能得到想要的输出 改进想法和 prompt 重复上述过程 4、摘要 将 ChatGPT 用于长评论的总结可以控制 ChatGPT 回复的句子长度：通过限制句子个数、字数等等修改 prompt 使其适用于特定的业务、情景 5、推理 ChatGPT 可用于评论情感分析；商品评价；对新闻报刊的主题提取 零样本学习 没有提供带标签的训练样本，包括 Zero-Shot：直接给模型任务输入让它输出任务结果 Few-Shot：给模型提供一些示例，然后再给出任务，让它给出输出结果 6、转换 ChatGPT 用于文本翻译 文本格式转换 正式或者非正式场合 字典转 JSON 或者 HTML 等等 语气转换 例如给同事或者教授写邮件时，需要注意书写的语气 拼写、语法检查 from redlines import Redlines该库可以用于检查文本之间的差异 7、扩展 ChatGPT 用于文本扩写，例如可以生成个性化电子邮件参数 temperature 控制回答的随机性、多样性，越大越多样 8、聊天机器人 message = [ {\"role\": \"system\", \"content\": \"。。。\"}, {\"role\": \"user\", \"content\": \"。。。\"}, {\"role\": \"assistant\", \"content\": \"。。。\"}, ... ] system 作为高层指令，起到引导作用，设置 assistant 的行为，打造属于自己的聊天机器人要使得模型提取或者记住信息，需要用到上下文 context， 在 message 中提供或者存储在，message 列表中 import panel as pn可以生成 GUI 界面 神经网络 在达到相同感受野的情况下，卷积核越小，所需要的参数和计算量越小 卷积核大小必须大于1才有提升感受野的作用，1排除了而大小为偶数的卷积核即使对称地加padding也不能保证输入feature map尺寸和输出feature map尺寸不变（画个图算一下就可以发现），2排除了所以一般都用3作为卷积核大小 每一层卷积有多少channel数，以及一共有多少层卷积，这些暂时没有理论支撑，一般都是靠感觉去设置几组候选值，然后通过实验挑选出其中的最佳值 注意事项 1、刚开始, 直接奔着过拟合去. 没错, 就是训练过拟合网络 2、Loss设计要合理.一般来说分类就是Softmax, 回归就是L2的loss. 但是要注意loss的错误范围(主要是回归) 3、观察loss胜于观察准确率准确率虽然是评测指标, 但是训练过程中还是要注意loss的. 你会发现有些情况下, 准确率是突变的, 原来一直是0, 可能保持上千迭代, 然后突然变1. 要是因为这个你提前中断训练了, 只有老天替你惋惜了. 而loss是不会有这么诡异的情况发生的, 毕竟优化目标是loss. 4、确认分类网络学习充分分类网络就是学习类别之间的界限. 你会发现, 网络就是慢慢的从类别模糊到类别清晰的. 怎么发现? 看Softmax输出的概率的分布. 如果是二分类, 你会发现, 刚开始的网络预测都是在0.5上下, 很模糊. 随着学习过程, 网络预测会慢慢的移动到0,1这种极值附近. 所以, 如果你的网络预测分布靠中间, 再学习学习. 5、Learning Rate设置合理 6、对比训练集和验证集的loss 7、清楚receptive field的大小 其他问题 预处理，mean/std zero-center就够了, PCA, 白化什么的都用不上. 我个人观点, 反正CNN能学习encoder, PCA用不用其实关系不大 数据集记得打乱，shuffle, shuffle, shuffle. 网络原理的理解最重要, CNN的conv这块, 你得明白sobel算子的边界检测. Dropout, Dropout, Dropout(不仅仅可以防止过拟合, 其实这相当于做人力成本最低的Ensemble, 当然, 训练起来会比没有Dropout的要慢一点, 同时网络参数你最好相应加一点, 对, 这会再慢一点). CNN更加适合训练回答是否的问题, 如果任务比较复杂, 考虑先用分类任务训练一个模型再finetune. 无脑用ReLU(CV领域). 无脑用3x3. 无脑用xavier. LRN一类的, 其实可以不用. 不行可以再拿来试试看. filter数量2^n. 多尺度的图片输入(或者网络内部利用多尺度下的结果)有很好的提升效果. 第一层的filter, 数量不要太少. 否则根本学不出来(底层特征很重要). sgd adam 这些选择上, 看你个人选择. 一般对网络不是决定性的. 反正我无脑用sgd + momentum. batch normalization我一直没用, 虽然我知道这个很好, 我不用仅仅是因为我懒. 所以要鼓励使用batch normalization. 不要完全相信论文里面的东西. 结构什么的觉得可能有效果, 可以拿去试试. 你有95%概率不会使用超过40层的模型. shortcut的联接是有作用的. 暴力调参最可取, 毕竟, 自己的生命最重要. 你调完这个模型说不定过两天这模型就扔掉了. Google的inception论文, 结构要好好看看. 一些传统的方法, 要稍微了解了解. 我自己的程序就用过1x14的手写filter, 写过之后你看看inception里面的1x7, 7x1 就会会心一笑... 参考资料 卷积神经网络的卷积核大小、个数，卷积层数如何确定呢？ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-11-12 09:07:26 "},"about_MySQL/":{"url":"about_MySQL/","title":"MySQL 整理","keywords":"","body":"About MySQL 安装 常用函数和语句 练习 常见问题 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-23 22:37:44 "},"about_MySQL/安装过程-windows.html":{"url":"about_MySQL/安装过程-windows.html","title":"安装","keywords":"","body":" ✨参考资料 MySQL 5.7 安装教程 ✨下载安装 ⭕ 下载 下载地址：https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/在浏览器页面按下 Ctrl + F，寻找关键词“win”，下载后缀为 zip 的压缩包自行选择解压路径 ⭕ my.ini 文件 在解压路径下新建 my.ini 文件，内容如下 [mysql] # 设置 MySQL 客户端默认字符集 default-character-set=utf8 [mysqld] # 设置 3306 端口 port = 3306 # 设置 MySQL 的安装目录 basedir=$自己的解压路径$ # 设置 MySQL 数据库的数据的存放目录（MySQL8.0+ 不需要以下配置，系统自己生成即可，否则有可能报错） datadir=$自己的解压路径$\\data # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB ⭕ 设置密码 打开 CMD，输入 mysql -u root -p默认无密码，直接回车 -- 切换到 MySQL 数据库 use mysql; -- 设置 root 用户的密码为 123456 update user set authentication_string=password('123456') where user='root'; -- 刷新 MySQL 的系统权限相关表 flush privileges; ⭕ 设置远程连接 打开 CMD，输入 mysql -u root -p注意这次要输入新密码 -- 切换到 MySQL 数据库 use mysql; -- 设置 user 用户远程访问 GRANT ALL ON *.* TO user@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; -- 刷新 MySQL 的系统权限相关表 flush privileges; .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-21 12:02:12 "},"about_MySQL/一些函数和语句.html":{"url":"about_MySQL/一些函数和语句.html","title":"常用函数和语句","keywords":"","body":" ✨参考资料 鱼皮的 MySQL 学习网站：http://sqlmother.yupi.icu/ ✨常用函数 ⭕ 聚合函数 sum()、avg()、count()、max()、min() 一般可以配合 group by 使用分组 group by ..., ... 支持多字段 ⭕ 关于日期 date()、datetime()、time() -- 查看 Date1 与 Date2 相差的时间 datediff(Date1, Date2) 时间段数据 -- 注意时间要有引号 time >= '2020-01-01 00:00:00' AND time 等同于 time BETWEEN '2020-01-01 00:00:00' AND '2020-12-31 23:59:59' -- 将字符通过指定的格式转换成日期 str_to_date -- 将日期转换成字符 date_format ⭕ 排序 -- 先对某字段 a 升序排序，再对某字段 b 降序排序 select ... from ... order by a asc, b desc ⭕ 关于字符串 🔘 判断是否为空 -- 判断 a 是否为空 isnull(a) -- 若 a 不为 null，则返回 a，否则返回 b ifnull(a, b) 🔘 字符串转换、截取、拼接等处理 -- 将字符串转为大写 upper(...) -- 将字符串转为小写 lower(...) -- 截取从指定索引处指定字符长度的字符 substr(字符串,1,3) -- 拼接字符串 concat(a, b) -- 字符串长度 length() -- 去掉首尾字符 trim -- 返回子串第一次出现的索引，如果找不到返回 0 instr(字符串，字符) ✨一些语句 ⭕ case when select ..., case when ... then ... when ... then ... else ... end as ... from ... ⭕ 子查询 exists -- 通常嵌套的 select 语句 select var from ... where var in ( 又一个 select 语句 ) -- 用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据 select var from ... where exists( 又一个 select 语句 ) ⭕ 拼接表 -- 返回的数据已去重 查询语句1 union 查询语句2 -- 返回的数据中可能存在重复值 查询语句1 union all 查询语句2 ✨窗口函数 窗口函数是一种强大的查询工具它允许我们在查询中 对分组数据 进行计算，同时 保留原始行的详细信息窗口函数通过 指定的字段将数据分为几个窗口，再使用 聚合函数 进行分析 窗口函数有：rank、dense_rank、row_number，还有所有的聚合函数等等包括静态窗口、滑动窗口 ⭕ 特点 相较于 group by，窗口函数执行完后数据的 条数不变只能在 select 子句里面 ⭕ 示例 🔘 分组后组内求和 select ..., sum(计算字段名) over ( partition by 分组字段名 ) as ... from ... -- 上述的 sum 函数也可以替换成 avg 或者 min、max 等 上述的语句会发现结果字段是总和，若需要 同组内的累加和，则需要加上 order by select ..., sum(计算字段名) over ( partition by 分组字段名 + order by 根据某字段排序 ) as ... from ... 🔘 排序函数 rank() 会出现并列排名 select ..., rank() over ( partition by 分组字段 order by 排序字段 desc rows between ... and ... ) as ... from ... row_number() 唯一排名 select ..., row_number() over ( partition by 分组字段 order by 排序字段 desc rows between ... and ... ) as ... from ... 函数 作用 rank 排名，但是遇到并列的情况会跳过并列的名次 dense_rank 同上，但是不跳过并列的 row_number 连续序号，就像给每行一个序号 🔘 lag、lead 用于相邻行的比较 ⭕ 问题 MySQL 中，假设现在要给一个班级的语文成绩进行排序。但是会出现同分的现象，请你给出一些简单的示例并给予下面问题的解答1、重名次的跳过，例如有三个同学都是第 2 名，那么下一个名次为第 5 名2、重名次的不跳过，例如有三个同学都是第 2 名，那么下一个名次还为第 3 名解答：https://dbfiddle.uk/p9Owpwod .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-22 23:23:58 "},"about_MySQL/跟着练习.html":{"url":"about_MySQL/跟着练习.html","title":"练习","keywords":"","body":" ✨参考资料 在线练习：https://dbfiddle.uk黑马：https://github.com/cess-100/python-study2 ✨基本操作 windows 系统打开 CMD输入 mysql -u root -p 回车再输入密码 [!NOTE|style:flat] SQL 语句最后需要以分号 ; 结尾关键字使用大小写均可 显示数据库版本 versionselect version(); 显示时间select now(); 查看目前所有的数据库show databases; 查看当前使用的数据库select database(); 创建用于练习的数据库 mytest_school，并指定编码create database mytest_school charset=utf8; 切换到数据库 mytest_schooluse mytest_school; 删除数据库drop database if exists mytest_school; 退出exit 或者 quit ✨数据表的操作 查看当前数据库中所有的表show tables; 创建表先是字段名，再是指定类型，例如 int 或者 varchar 等等，再设置主键，再设置是否 not null，最后设置可选的 default 值int unsigned 无符号整形auto_increment 设置自增，一般用于主键not null 设置该字段不能为空primary key 设置主键default 设置默认值ENGINE=InnoDB 设置 MySQL 的存储引擎 -- 创建学生表 create table students( id int unsigned primary key auto_increment, name varchar(20) not null, age tinyint(1), high decimal(3,2), gender enum('男', '女', '保密'), cls_id int unsigned ); 查看表结构desc classes; ⭕ 增删改查（curd） 🔘 增 全列插入主键字段可以用 0、null、default 来占位 -- 向 students 表中插入数据 insert into students values (null, '小陆', 18, 1.78, '男', 1); 部分插入 -- 只向 id 和 name 字段插入值 insert into students(id, name) values (023, '小思'); 多行插入 -- 注意逗号 insert into students values (null, '小风', 18, 1.78, '男', 1), (null, '小晨', 19, 1.61, '女', 3), (null, '小展', 19, 1.75, '男', 2); [!NOTE|style:flat] insert into 插入数据时会检查主键，重复则会报错replace into 遇到重复的则是会进行 替换insert ignore 遇到重复的则是直接 忽略 🔘 删 物理删除 delete from students where id = 2; 逻辑删除用一个字段来标识这条信息是否还能再使用 -- 给 students 表添加一个 bit 类型的 is_delete 字段，默认为 0 alter table students add is_delete bit default 0; update students set is_delete = 1 where id = 3; -- id 为 3 的数据被标记为不可用 🔘 改 修改表 添加列ALTER TABLE 表名 ADD COLUMN 列名 类型 【first|after 字段名】; 修改列的类型或约束ALTER TABLE 表名 MODIFY COLUMN 列名 新类型 【新约束】; 修改列名ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 类型; 删除列ALTER TABLE 表名 DROP COLUMN 列名; 修改表名ALTER TABLE 表名 RENAME 【to】 新表名; 修改字段缺省值ALTER TABLE 表名 ALTER 列名 SET DEFAULT 1000; update students set high=1.56, gender='女' where name='小环'; 🔘 查 查询所有列 select * from students; 查询指定列 select id, name from students; 条件查询 select * from students where id=2; 使用 as 为列或表指定别名 select s.id as '编号', s.name as '姓名' from students as s; 🔘 其他 数据库备份与恢复【了解】 # 导出数据库为 python.sql mysqldump –u root –p 数据库名 > python.sql; # 导入数据库 mysql -u root –p 新数据库名 复制表 1、只复制结构 CREATE TABLE b LIKE a 复制一个结构与表 a 一样的表 b 2、复制结构及数据 CREATE TABLE b SELECT * FROM a 复制一个和表 a 一样的表 b 连接表 MySQL 不支持全连接，使用 JOIN 都需要搭配 ON。默认的 JOIN 是 INNER JOIN 如果想要连接两个 含有相同字段 的表格，那么可以选择 UNION 连接 区别是 UNION 合并两个表格时会进行 去重 UNION ALL 则是 直接合并 起来 条件语句 -- 满足条件 a 则是 b -- 不满足条件 a 则是 c IF(a, b, c) -- 例如 IF(x>5, '大', '小') 等同于 CASE WHEN ... THEN ... WHEN ... THEN ... ELSE ... END AS ... ✨完整练习 ⭕ 练习 1 创建并使用 python_test_1 数据库 create database python_test_1 charset = utf8; use python_test_1; 创建学生表 drop table students; create table students ( id int unsigned primary key auto_increment not null, name varchar(20) default '', age tinyint unsigned default 0, height decimal(5, 2), gender enum ('男', '女', '中性', '保密') default '保密', cls_id int unsigned default 0, is_delete bit default 0 ); 创建班级表 drop table classes; create table classes ( id int unsigned auto_increment primary key not null, name varchar(30) not null ); 插入数据 insert into students values (0, '小明', 18, 180.00, 2, 1, 0), (0, '小月', 18, 180.00, 2, 2, 1), (0, '小彭', 29, 185.00, 1, 1, 0), (0, '小刘', 59, 175.00, 1, 2, 1), (0, '小黄', 38, 160.00, 2, 1, 0), (0, '小凤', 28, 150.00, 4, 2, 1), (0, '小王', 18, 172.00, 2, 1, 1), (0, '小周', 36, NULL, 1, 1, 0), (0, '小程', 27, 181.00, 1, 2, 0), (0, '小菲', 25, 166.00, 2, 2, 0), (0, '小金', 33, 162.00, 3, 3, 1), (0, '小静', 12, 180.00, 2, 4, 0), (0, '小郭', 12, 170.00, 1, 4, 0), (0, '小杰', 34, 176.00, 2, 5, 0); insert into classes values (0, 'python_01期'), (0, 'python_02期'); 查询练习 select id as '编号', name as '姓名' from students; select s.id, s.name from students as s; -- distinct 关键字，去重查询 select distinct gender from students; -- 比较运算符和逻辑运算符查询 select * from students where age > 18 or height >= 180; -- 支持 >=、=18 and age 排序 -- order by 默认是从小到大的升序排列 asc -- 降序 desc -- 查询年龄在 18 到 34 岁之间的男性，身高从高到矮排序, 如果身高相同则按照年龄从小到大排序 select * from students where age between 18 and 34 and gender='男' order by height desc, age asc; 聚合函数 -- 查询总共有多少人 select count(*) as '总人数' from students; -- 查询女性最大年龄 select max(age) from students where gender='女'; -- 查询男性最矮身高 select min(height) from students where gender='男'; -- 年龄总和 select sum(age) from students; -- 平均年龄 select avg(age) from students; select sum(age)/count(*) from students; -- 四舍五入函数，保留 2 位小数 select round(avg(height), 2) from students; 分组 -- 计算各性别的人数 select gender, count(*) from students group by gender; -- 计算各性别中最高的身高 select gender, max(height) from students group by gender; -- 以下两个语句会报错 -- select * from students group by gender; -- select gender, name from students group by gender; -- group_concat ？？？ -- 查询相同性别中的姓名 -- select gender, group_concat(name) from students group by gender; -- 查询平均年龄超过 30 岁的性别 select gender, avg(age) as tmp from students group by gender having tmp > 30; -- 聚合函数在 having 前执行 要求 SELECT的列 只能在 用于分组的列 中选择例如可以： SELECT a,max(a),b FROM mytable GROUP BY a,b,c 不能这样： SELECT a,b,c FROM mytable GROUP BY a,b HAVING 语句 ``` SQL SELECT class FROM Courses GROUP BY class HAVING COUNT(class)>=5 -- 分组后聚合，找到 class 数量大于 5 的 ``` 等同于 ``` SQL SELECT class FROM( SELECT class, COUNT(student) AS a FROM Courses GROUP BY class ) AS t WHERE t.a>=5 ``` having ... 用于 分组聚合后 进行一些筛选操作，与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 分组之前 进行过滤，而 HAVING 子句用于在 分组之后 进行过滤 limit 限制 -- 限制查询出来的数据个数 -- 查询前 5 个数据 select * from students limit 0, 5; select * from students limit 5; -- 分页查询 -- 每页显示 b 个，显示第 a 页的信息 -- select * from students limit b*(a-1), b; -- 每页显示 2 个，第 1 个页面 select * from students limit 0, 2; -- 每页显示 2 个，显示第 6 页的信息 select * from students limit 10, 2; 表连接 -- 将学生表和班级表根据班级 id 连接起来 select * from students inner join classes on students.cls_id = classes.id; -- 给表指定别名 select s.name, c.name from students as s inner join classes as c on s.cls_id = c.id; -- 使用 where 语句是等价的 select s.name, c.name from students as s, classes as c where s.cls_id = c.id; -- 左连接 left join -- 右连接 right join -- 注意：表可以和自己连接 关联表格： cross join 两两结合，不需要条件 inner join 或者 join 满足对应的条件才可以组合在一起 left join、right join 属于 outer join 子查询 -- 标量子查询，返回结果为标量 -- 列子查询，返回结果为一列 -- 行子查询，返回结果为一行 -- 查出高于平均身高的数据 select * from students where height > ( select avg(height) from students ); -- 子查询语句不需要分号 ⭕ 练习2 创建并使用 JD 数据库 create database JD charset = utf8; use JD; 创建商品表 drop table goods; create table goods ( id int unsigned primary key auto_increment not null, name varchar(150) not null, cate_name varchar(40) not null, brand_name varchar(40) not null, price decimal(10, 3) not null default 0, is_show bit not null default 1, is_saleoff bit not null default 0 ); insert into goods values (0, 'r510vc 15.6英⼨笔记本', '笔记本', '华硕', '3399', default, default); (0, 'y400n 14.0英⼨笔记本电脑', '笔记本', '联想', '4999', default, default); (0, 'g150th 15.6英⼨游戏本', '游戏本', '雷神', '8499', default, default); (0, 'x550cc 15.6英⼨笔记本', '笔记本', '华硕', '2799', default, default); (0, 'x240 超极本', '超级本', '联想', '4880', default, default); (0, 'u330p 13.3英⼨超极本', '超级本', '联想', '4299', default, default); (0, 'svp13226scb 触控超极本', '超级本', '索尼', '7999', default, default); (0, 'ipad mini 7.9英⼨平板电脑', '平板电脑', '苹果', '1998', default, default); (0, 'ipad air 9.7英⼨平板电脑', '平板电脑', '苹果', '3388', default, default); (0, 'ipad mini 配备 retina 显示屏', '平板电脑', '苹果', '2788', default, default); (0, 'ideacentre c340 20英⼨⼀体电脑 ', '台式机', '联想', '3499', default, default); (0, 'vostro 3800-r1206 台式电脑', '台式机', '戴尔', '2899', default, default); (0, 'imac me086ch/a 21.5英⼨⼀体电脑', '台式机', '苹果', '9188', default, default); (0, 'at7-7414lp 台式电脑 linux ）', '台式机', '宏碁', '3699', default, default); (0, 'z220sff f4f06pa⼯作站', '服务器/⼯作站', '惠普', '4288', default, default); (0, 'poweredge ii服务器', '服务器/⼯作站', '戴尔', '5388', default, default); (0, 'mac pro专业级台式电脑', '服务器/⼯作站', '苹果', '28888', default, default); (0, 'hmz-t3w 头戴显示设备', '笔记本配件', '索尼', '6999', default, default); (0, '商务双肩背包', '笔记本配件', '索尼', '99', default, default); (0, 'x3250 m4机架式服务器', '服务器/⼯作站', 'ibm', '6888', default, default); (0, '商务双肩背包', '笔记本配件', '索尼', '99', default, default); 查询练习 -- 查询每种类型的商品中最贵 max 、最便宜 min 、平均价 avg 、数量 count select cate_name, max(price), min(price), avg(price), count(*) from goods group by cate_name; -- 查询每种类型中最贵的电脑的所有信息 select * from goods where price in ( select max(price) from goods group by cate_name ); -- 注意子查询里面不用分号 -- 每种类型中最贵的物品信息 select * from goods inner join ( select cate_name, max(price) as max_price from goods group by cate_name ) as max_price_goods on goods.cate_name = max_price_goods.cate_name and goods.price = max_price_goods.max_price; -- 或者 select cate_name, max(price), group_concat(name) from goods group by cate_name; 通过子查询插入数据到新的分类表中 insert into goods_cates(name) select cate_name from goods group by cate_name; 改 update 操作练习 -- 把商品表 goods 中的 cate_name 全部替换成商品分类表中的商品 id update goods inner join goods_cates on goods.cate_name = goods_cates.name set goods.cate_name = goods_cates.id; -- 修改表结构，把 cate_name 改成 cate_id int unsigned not null alter table goods change cate_name cate_id int unsigned not null; 添加外键作用：确保数据的完整性和一致性 -- alter table 表名 add foreign key (外键字段) references 表名(主键id) alter table goods add foreign key (cate_id) references goods_cates(id); -- 在 goods 表中添加一个外键 cate_id，该外键与 goods_cates 表的 id 字段相关联 -- 这意味着在向 goods 表中插入数据时，cate_id 字段的值必须存在于goods_cates 表的 id 字段中，否则将会引发外键约束错误 有时候执行上述语句会报错，原因是当前数据库就存在着一些不符合规则的数据，需要先删除那些数据，再重新添加外键 -- 创建表的同时可以设置外键 -- 注意 goods_cates 和 goods_brands 两个表必须事先存在 create table goods_test( id int primary key auto_increment, name varchar(150) not null, cate_id int unsigned not null, brand_id int unsigned not null, foreign key (cate_id) references goods_cates (id), foreign key (brand_id) references goods_brands (id) ); -- 查看外键名 show create table goods_test; -- 获取名称之后就可以根据名称来删除外键约束 alter table goods_test drop foreign key goods_test_ibfk_1; 什么是视图?通俗的讲，视图就是一条 select 语句执行后返回的结果集 视图的特点视图是对若干张基本表的引用，一张 虚表，查询语句执行的结果， 不存储具体的数据，基本表数据发生了改变，视图也会跟着改变 视图是存储在数据库中的查询的SQL语句，作用如下：1、视图可以 隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等2、使复杂的查询易于理解和使用 视图重要的意义程序对数据库操作，一旦数据库发生变化，程序就需要修改这时如果使用视图而非普通表格，就可以解决这个问题 -- 定义视图 -- 创建视图 v_goods_info，查出产品表中产品名称、分类名称以及对应品牌 create view v_goods_info as select goods.name gname, goods_cates.name gcname, goods_brands.name gbname from goods inner join goods_cates on goods.cate_id = goods_cates.id inner join goods_brands on goods.brand_id = goods_brands.id; -- show tables; 会显示表和视图 -- 当原表产品名称改变后，会影响视图（视图是虚拟表） update goods set name = 'xxx' where id = 24; -- 删除视图 drop view v_goods_info; 事务(ACID) 基本使用： 1、打开事务 begin 或 start transaction2、操作包括 insert、update、delete3、确认修改 commit4、反悔进行回滚 rollback; 回滚(rollback)操作第一步 打开终端 1 begin第二步 终端 1 执行 update 表名 set 字段=\"xxx\" where ...;第三步 再执行 rollback，数据返回最开始的原始值 show engines; 原子性 一致性第一步 打开终端 1 和终端 2第二步 终端 1 打开事务 begin，执行 update 表名 set 字段=\"xxx\" where ...;，再执行 select * from 表名; 发现数据改变第三步 终端 2 select * from 表名;，发现数据其实并没有改变（其实这个时候对数据的相关操作信息存在缓存中，当 commit 之后 ,这些操作才会一次性的完成）第四步 终端 1 commit，终端 2 select * from 表名，数据改变了 隔离性第一步 打开终端 1 和终端 2第二步 终端 1 打开事务 begin，执行 update 表名 set 字段=\"xxx\" where ...;第三步 终端 2 执行 update 表名 set 字段=\"yyy\" where ...;，发现处于 阻塞 状态第四步 终端 1 commit，终端 2 阻塞状态解除，数据修改成功 持久性一旦事务提交 commit，则其所做的修改会永久保存到数据库 [!NOTE|style:flat] innodb 能使用事务使用 python 和 终端 操作数据库(也就是mysql的客户端)的时候是 默认开启事务但是 python 对数据库进行增删改的时候 需要手动 commit而终端回车后会默认的 commit 事务重要的意义某些事情需要一次性完成 中途不允许出现中断例如银行取钱，事务可以解决这种问题 SQL 注入为了防止 SQL 注入攻击，应该使用参数化查询或者预编译语句，确保用户输入的数据被 正确地转义和处理，而不是直接拼接到 SQL 语句中 ⭕ 练习3 创建表格 DROP TABLE IF EXISTS `student`; CREATE TABLE student( SId VARCHAR(3) NOT NULL, Sname VARCHAR(4) NOT NULL, Sage DATE, Ssex VARCHAR(2) NOT NULL, PRIMARY KEY(SId) ); -- 创建表格student CREATE TABLE teacher( TId VARCHAR(3) NOT NULL, Tname VARCHAR(4) NOT NULL, PRIMARY KEY(TId) ); -- 创建表格teacher CREATE TABLE sc( SId VARCHAR(3) NOT NULL, CId VARCHAR(3) NOT NULL, score VARCHAR(3) NOT NULL ); -- 创建表格sc CREATE TABLE course( CId VARCHAR(3) NOT NULL, Cname VARCHAR(4) NOT NULL, TId VARCHAR(3) NOT NULL, PRIMARY KEY(CId) ); -- 创建表格course 向表格 student 插入数据 INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (10,'李四' ,'2017/12/25 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (11,'李四' ,'2012/6/6 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (13,'孙七' ,'2014/6/1 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (02,'钱电' ,'1990/12/21 0:00:00','男'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (03,'孙风' ,'1990/12/20 0:00:00','男'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (06,'吴兰' ,'1992/1/1 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (01,'赵雷' ,'1990/1/1 0:00:00','男'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (04,'李云' ,'1990/12/6 0:00:00','男'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (09,'张三' ,'2017/12/20 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (12,'赵六' ,'2013/6/13 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (07,'郑竹' ,'1989/1/1 0:00:00','女'); INSERT INTO student(SId,Sname,Sage,Ssex) VALUES (05,'周梅' ,'1991/12/1 0:00:00','女'); 向表格 teacher 插入数据 INSERT INTO teacher(TId,Tname) VALUES (01,'张三'); INSERT INTO teacher(TId,Tname) VALUES (02,'李四'); INSERT INTO teacher (TId,Tname) VALUES (03,'王五'); 向表格 sc 插入数据 INSERT INTO sc(SId,CId,score) VALUES (01,03,99); INSERT INTO sc(SId,CId,score) VALUES (02,03,80); INSERT INTO sc(SId,CId,score) VALUES (01,02,90); INSERT INTO sc(SId,CId,score) VALUES (07,02,89); INSERT INTO sc(SId,CId,score) VALUES (04,01,50); INSERT INTO sc(SId,CId,score) VALUES (04,02,30); INSERT INTO sc(SId,CId,score) VALUES (07,03,98); INSERT INTO sc(SId,CId,score) VALUES (05,02,87); INSERT INTO sc(SId,CId,score) VALUES (06,01,31); INSERT INTO sc(SId,CId,score) VALUES (06,03,34); INSERT INTO sc(SId,CId,score) VALUES (02,01,70); INSERT INTO sc(SId,CId,score) VALUES (03,01,80); INSERT INTO sc(SId,CId,score) VALUES (01,01,80); INSERT INTO sc(SId,CId,score) VALUES (03,02,80); INSERT INTO sc(SId,CId,score) VALUES (03,03,80); INSERT INTO sc(SId,CId,score) VALUES (02,02,60); INSERT INTO sc(SId,CId,score) VALUES (04,03,20); INSERT INTO sc(SId,CId,score) VALUES (05,01,76); 向表格 course 插入数据 INSERT INTO course(CId,Cname,TId) VALUES (03, '英语',03); INSERT INTO course(CId,Cname,TId) VALUES (02, '数学',01); INSERT INTO course(CId,Cname,TId) VALUES (01, '语文',02); 查看现在有哪些表格 SHOW TABLES; 查看表格 student 的结构 DESC student; 展示表格 student 的数据 SELECT * FROM student; 可以开始练习筛选等等语句 推荐网址：https://dbfiddle.uk/aTtDOcMu 里面有一些筛选问题 删除表格中的某些字段 ALTER TABLE student DROP COLUMN Sage, DROP COLUMN Ssex; 删除表格 DROP TABLE student; DROP TABLE teacher; DROP TABLE sc; DROP TABLE course; 删除数据库 DROP DATABASE mytest_school; SHOW DATABASES; .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-22 23:23:42 "},"about_MySQL/常见问题.html":{"url":"about_MySQL/常见问题.html","title":"常见问题","keywords":"","body":" ✨参考资料 https://blog.csdn.net/qq_47540091/article/details/121875715 ✨常见问题 ⭕ MySQL 的执行过程 查询语句的执行流程如下：检查权限、查询缓存、分析器、优化器、权限校验、执行器、引擎 假设有查询语句如下： select * from user where id>1 and name='myMySQL'; 1、检查 权限，有权限就调用数据库引擎接口，返回引擎的执行结果，没有权限则返回错误2、查询 缓存，缓存命中则直接返回，没有则执行下一步3、词法分析和语法分析。提取表名、查询条件，检查语法 是否有错误4、两种执行方案，先查 id > 1 还是 name = 'myMySQL'，优化器根据自己的优化算法选择 执行效率最好的方案 ⭕ 模糊查询与通配符 like 一般配合通配符使用 可以匹配字符型或数值型 % 匹配任意 0 或者以上个字符 _ 匹配任意 1 个字符 ⭕ in 和 exists 的区别 exists 能 使用索引，且其结果集不重要，重要的是有无记录 ⭕ int(10)、char(10)、varchar(10) https://blog.csdn.net/weixin_49263647/article/details/123180332int(10) 中的 10 表示的是数据显示的长度，而非大小char(10) 中的 10 表示的是存储多少个字符，不足 10 个字符会用空格补齐varchar(10) 是可变的，相较于 char 来说更省空间 ⭕ DELECT、TRUNCATE、DROP https://www.php.cn/mysql-tutorials-68773.htmlDELECT、TRUNCATE 只是 清空表格内的数据，但是表结构还在，运行 DESC 语句应该还有结果；而 DROP 则是 删除表及索引 等 \\ DELECT TRUNCATE 是否可以搭配 WHERE 条件 是 否 删除效率 较低 较高 是否有返回值 是 否 是否可以回滚 是 否 还有，使用 TRUNCATE 删除数据，若表中含有自增长列，重新插入数据后，自增长列的值重新从 1 开始；DELETE 则是从原来的位置继续 ⭕ MySQL 的存储引擎 InnoDB，默认引擎，适合需要 提交、回滚、崩溃恢复能力、能并发控制 的情况MyISAM，适合数据表的操作主要是 插入和查询 的情况MEMORY，适合临时存放数据，可以作为 临时表 来存放查询的中间结果Archive，也是适合数据表的操作主要是 插入和查询 的情况 ⭕ InnoDB 与 MyISAM \\ InnoDB MyISAM 是否支持事务 是 否 是否支持外键 是 否 清空表的操作 一行一行的删除，效率非常慢 直接重建表 适合情况 频繁修改以及涉及到安全性较高的应用 查询以及插入为主的应用 ⭕ 主键与索引的区别 主键∈索引通过定义 PRIMARY KEY 约束来创建主键，要求 PRIMARY KEY 唯一且非空 ⭕ 数据库索引类型 按照逻辑分类：主键索引，每张表的主键索引只能有一个，要求键值唯一非空唯一索引，每张表可有多个唯一索引，要求键值唯一可为空组合索引，对表中的多个字段组合创建索引，遵循最左前缀原则普通索引，每张表可有多个普通索引，键值可重复可为空全文索引 按照物理分类：聚集索引，每张表的聚集索引只能有一个，数据在物理存储中的顺序与索引的逻辑顺序相同非聚集索引 ⭕ 数据库创建索引的优缺点 优点：大大提高系统的性能创建唯一索引，可以保证每一行数据的唯一性大大加快数据的检索速度加速表与表之间的连接加速分组和排序子句的数据索引速度 缺点：创建和维护索引要耗费时间，时间随着数据量的增加而增加索引要占据物理空间对数据进行增删改的时候，对应的索引也需要动态维护，这就降低了数据的维护速度 何时使用索引 适合在 经常需要 搜索 的列上 作为 主键 的列上 经常需要与其他表 连接 的列上 经常需要 排序 的列上 不适合在 更新频繁 的列上 数据 取值较少 的列上，例如性别 ⭕ 怎么建立和删除索引 建立索引 alter 在 mytable 表中给 col 列添加主键 ALTER TABLE mytable ADD PRIMARY KEY (col) 在 mytable 表中给 col 列添加普通索引 ALTER TABLE mytable ADD INDEX (col) 在 mytable 表中给 col 列添加唯一索引 ALTER TABLE mytable ADD UNIQUE (col) create 在 mytable 表中给 col 列添加普通索引 myindex CREATE INDEX myindex ON mytable (col) 在 mytable 表中给 col 列添加唯一索引 myindex CREATE UNIQUE myindex ON mytable (col) 删除索引 alter 删除 mytable 表中的普通索引 myindex ALTER TABLE mytable DROP INDEX myindex 删除 mytable 表中的主键索引 ALTER TABLE mytable DROP PRIMARY KEY drop 删除 mytable 表中的普通索引 myindex DROP INDEX myindex ON TABLE mytable ⭕ 事务 ACID A（atom），原子性 事务是整体，要么全部做，要么都不做 C（consistency），一致性 事务执行前后，数据应该保持一致状态，例如银行转账前后的两个账户总额 I（isolation），隔离性 多个事务同时执行时，它们之间不会互相影响 D（durability），持久性 事务一旦做了之后，对数据库的改变是永久的 ⭕ 事务的并发问题 假设有两个事务 T1 和 T2并发就是同时运行 T1、T2当这些事务要去处理同个数据时，就会引发各种问题： 脏读 T2 对某个列（也叫字段）col 进行了更新变成 col1，但是注意 T2 还未提交，同时 T1 去读取了该列 col。设想当 T2 回滚（类似于撤销操作），T1 读取的还是 T2 更新后的列 col1 吗？应该还是，不过是 临时且无效 的 不可重复读（值不同=>锁行） T1 首先读取了某个列（也叫字段），此时 T2 对该列进行了更新且 提交 了，之后 T1 再去读取同一列，值就不同了 幻读（行数不同=>锁表） T1 首先读取了某个表，此时 T2 向表中插入了几行，之后 T1 再去读取该表，就会多出几行 为了避免以上问题，需要制定好数据库的隔离级别 ⭕ 事务隔离级别 共 4 级： 隔离级别 描述 脏读是否出现 不可重复读是否出现 幻读是否出现 READ UNCOMMITTED 读取未提交的数据 ✔ ✔ ✔ READ COMMITTED 读取已提交的数据 × ✔ ✔ REPEATABLE READ 可重复读 × × ✔ SERIALIZABLE 串行化 × × × ⭕ 数据库索引结构 二叉树 进行查找的时候，若目标元素值小于当前节点，则移动到左侧子节点进行比较，反之若大于则移动到右侧子节点比较 但是大部分情况下，是用一个 自增的整型字段 作为索引的列，这会导致索引总是添加到右侧，这与没有建立索引的清况是一样的 红黑树 也叫二叉平衡树，解决了上面二叉树出现的自增整型索引的问题 红黑树会 左旋和右旋，对结构进行调整 不过数据量大的时候，树的深度也很深，因为每个节点只能存在两个子节点 B树 在红黑树的基础上，适当地 增加每个树节点能存储的 数据个数，解决了数据量大的时候树很深的问题 左右子树深度相同，每个节点包含了 索引值和表记录（即key:value的形式）的信息 查询单条数据很快，但若是范围查询，每次都需要从 根节点 进行查询，效率会降低 相对于 B 树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使树变得更矮、深度更小，减少了查询时磁盘的 IO 次数，提高查询效率 B+树 只有 叶子节点存储数据，非叶子节点存放索引信息，这增大了节点的度值，提高查询命中目标元素值的几率 叶子节点之间行程单链表，适合进行区间查找 MySQL 将叶子节点和非叶子节点保存在不同的段上，段又分区，区又分块 ⭕ 锁的种类 按照类型分 乐观锁：假设了数据一般情况下不会发生冲突，在数据提交更新时才会检测数据是否发生冲突 悲观锁：假设了数据并发操作下必定发生冲突，在数据开始读取前就把数据锁住 按照粒度分 行级锁 页级锁 表级锁 按照作用分 共享锁：读操作时创建 排他锁：写操作时创建假设一事务 T，对某个表进行查询，并对查询结果集申请排他锁，则其他线程对查询出的数据只能读，不能更改或者删除。直到事务 T 提交或者回滚为止 ⭕ 水平切分、垂直切分 水平切分 比如一张表有100w条数据，我们将它切分为10个总和为100w条数据的表 可以通过地区、年份、索引取模来实现水平切分 垂直切分 一张表的数据条数不多，但是列数很多，则可以按列拆分开来 分表的原则 能不拆分就不拆分 列之间的业务耦合性低的可以使用垂直切分 百万级大表，进行插入和查询的时候耗时长，可以通过拆表提升数据库性能 ⭕ 高并发的解决方案 分表分库，将表水平拆分增加缓存，将高频访问的数据写入缓存中增加数据库的索引主从读写分离，只在主服务器上写，从服务器上读负载均衡集群，通过集群或者分布式的方法解决并发压力 ⭕ SQL 优化 数据量越大，提升 I/O 越重要，例如使用短索引等等优化索引、优化访问方式检查是否出现死锁优化查询语句升级硬件提高网速扩大服务器内存 ⭕ 索引失效的情况 like查询是以%开头，索引会失效变成全表扫描 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引 字符串不加单引号索引会失效 若使用全表扫描要比使用索引快，则不会使用到索引 使用is not null 或者 is null会导致无法使用索引 在索引列上做任何操作，会导致索引失效而导致全表扫描 对于多列索引，不是使用的第一部分(第一个)，则不会使用索引 ⭕ 分页读取数据的操作 假设有数据如下表 ID 姓名 年龄 爱好 001 金 24 下棋 002 木 18 看书 003 水 23 跑步 004 火 15 绘画 005 土 18 篮球 -- 输出前2条数据，001、002 LIMIT 2 -- 忽略前2行数据，输出3条数据，003、004、005 LIMIT 2, 3 -- 忽略前3行数据，输出2条数据，004、005 LIMIT 2 OFFSET 3 LIMIT 子句必须放在整个 SELECT 语句的最后 ⭕ 过滤条件放在 ON 和 WHERE 的区别 假设有筛选语句如下： SELECT ... FROM ... (INNER/LEFT/RIGHT) JOIN ... ON ... WHERE ... WHERE执行在JOIN之后，ON执行在JOIN之中！！！JOIN要求索引列保留所以如果过滤条件在ON之中，导致筛选条件只对非索引列起作用如果过滤条件在WHERE之中，则不会出现这种情况 ⭕ 关系型数据库与非关系型数据库 关系型数据库：1、易于理解2、保持数据的一致性3、数据更新的开销较小4、支持while等语句的查询 非关系型数据库：1、读写效率高2、基于键值对，数据扩展性好3、支持存储的数据类型更多 ⭕ 数据库的范式 范式： 第一范式（1NF）：一个关系模式 R 的所有属性都是不可分的基本数据项 第二范式（2NF）：满足第一范式，然后消除部分依赖。确保表中的每一列都与主键相关 第三范式（3NF）：满足第二范式，消除传递依赖 依赖： 部分依赖 假设A、B是关系R的两个属性集合，->表示能得出 A中有真子集 x、y 若有A->B，且x->B，y->B，则说B部分依赖于A 完全依赖 假设同上，!->表示不能得出 若有A->B，且x!->B，y!->B，则说B完全依赖于A 传递依赖 假设A、B、C是关系R的三个属性集合 若有A->B，B!->A，B->C，C!->B，则说C传递依赖于A ⭕ 关于二叉树 N层满二叉树（完全二叉树）的节点个数$2^{0}+2^{1}+2^{2}+...+2^{N-1}=2^{N}-1$（$等比数列求和公式：S{n}=\\frac{a{1}(1-q^{n})}{1-q}$） N个节点的完全二叉树深度$log_{2}{N}+1$ 二叉树节点N计算公式假设叶子节点数为 $n{0}$ ，度为1节点数为 $n{1}$，度为2节点数为 $n{2}$$N=n{0}+n{1}+n{2}$$N=n{1}+2n{2}+1$$n{0}=n{2}+1$例子：若总节点数为999这样的奇数，999/2 = 499.5 ，那么叶子节点就有500个，度为2的节点为499个，度为1的节点为0个若总节点数为1500这样的偶数，1500/2 = 750 ，那么叶子节点就有750个，度为2的节点就有749个，度为1的节点为1个综上，度为1的节点是少数？ ⭕ 连接池 适用于复杂的数据库应用，防止频繁地建立、关闭连接操作，减少对系统性能的消耗连接池的基本原理是：在内部对象池中维护一定数量的数据库连接，对外暴露数据库连接的获取和返回方法作用是：资源重用；更快的系统响应速度；新的资源分配手段；避免常规数据库连接出现资源泄露的可能 ⭕ SQLite 和 MySQL 两种常见的关系型数据库管理系统（RDBMS） 异同点 架构和部署方式 SQLite 是嵌入式数据库，以库的形式直接集成到应用程序中，不需要独立的服务器进程 MySQL 是基于客户端/服务器模型的数据库，需要独立的服务器进程，可以支持多用户并发访问 数据库类型 SQLite 是基于文件的数据库，将整个数据库存储在单个文件中 MySQL 是基于服务器的数据库，数据存储在服务器上，可以处理大量数据和复杂查询 扩展性和性能 SQLite 适用于小规模应用，对于并发访问和大规模数据处理的需求有限 MySQL 具有良好的扩展性和性能，可以处理大量数据和高并发访问 安全性和权限管理 SQLite 的安全性较低，通常用于本地应用，不支持用户和权限管理 MySQL 提供了完善的用户和权限管理机制，可以对数据库进行细粒度的访问控制 SQLite适用于小型、嵌入式应用而MySQL适用于大型、多用户的应用 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-22 22:47:53 "},"about_StudyPath/":{"url":"about_StudyPath/","title":"学习路径","keywords":"","body":"About StudyPath 1、计算机组成、计算机网络、操作系统 OS 2、算法题、选择题 3、web介绍、html、css、js（nodejs、jquery、bootstrap、Vuejs） Web知识 4、python基础、爬虫、网络编程、统计数据分析、机器学习、人工智能深度学习 5、C基础、数据结构、C++ 其他：threejs、godot、mapreduce Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-03 22:32:15 "},"about_StudyPath/Web.html":{"url":"about_StudyPath/Web.html","title":"Web 知识","keywords":"","body":"参考资料 https://www.jianshu.com/nb/4686146 Web 概述 web，网状物Web 是万维网（world wide web）的简称Website 即网站，是网络和站点的结合 常见的 Web 客户端就是浏览器，例如谷歌、火狐浏览器等等通过网络，浏览器可以访问 Web 服务器上的内容Web 服务器上的内容是一些互相链接的超文本资源，资源由统一资源标识符（URI）标识而资源需要通过协议进行传输，常见的有超文本传输协议（HTTP）等等 network 也是指网络，但是偏向于底层基础；Web 则是偏向应用层 Internet（互联网、因特网） Web，是 Internet 的一部分 E-mail：电子邮件 FTP：文件传输协议 \"Cloud（云）\"更多地被视为一个商业概念，而不是一个单纯的技术概念 Tim Berbers Lee（蒂姆·伯纳斯·李）在 1991 年提出了万维网的概念1994 年，他创立了 W3C 组织，旨在发展 Web 规范，达成全球统一标准 Web 类比 Web环境 餐厅 Client 你和你的家人 Server 服务员 Browser 菜单 Web page 菜单里的内容 编程语言 客户端语言 HTML、CSS、JavaScript 服务器语言及对应的框架 PHP：ThinkPHP 等等Java：Spring 等Python：Django、Flask、Tornado 等等GoC#：ASP.NET 等等 JavaScript 目前有 nodejs，也可以用于服务器端开发 内容管理系统（CMS） 目的是：为了有效解决用户网站建设与信息发布中出现的常见问题和需求CMS 几乎不需要编程，没有经验的人也可以轻松搭建一个网站例如：Wordpress、Joomla 等等缺陷是 自定制性较差，不能随意实现自己想要的功能 数据库 由于 Web 应用的兴起，可能需要1、存储、管理 大量的数据 等等2、为了保持 数据的持久性，防止数据丢失带来的损失3、需要进行数据的 筛选和检索4、应对 高并发 的使用场景这些需要通过数据库来实现 分类： 关系型数据库MySQL、Oracle、SQlite、PostgreSQL 等等 非关系型数据库（Not only SQL，简称 NoSQL）HBase、MongoDB 等等适用于：数据模型比较简单，对数据库性能要求较高，不需要高度的数据一致性，大规模数据集合，多重数据种类 移动端 手机和平板的流行使得网站和软件发生了改变原先的网站在电脑上可以正常显示，但是在手机等移动设备上可能会出现问题 针对这个问题，开发者有几种选择： 1、将网站优化成 响应式网站 针对不同设备，网站会自适应不同设备的分辨率 注意：整个页面会进行调整，优先显示的内容区块会不一样 优：易于管理，易于做搜索引擎优化，易于营销等等 缺：对于一些老旧的设备可能会不支持 2、做成 原生 app 即安装在对应操作系统中的app，需要使用对应的语言才能开发 优：用户体验是最佳的 缺：不能在不同系统上使用，更新需要再次下载，有的需要通过应用商店更新（需要得到批准），开发成本高，推广应用需要使用不同于其他的营销策略 3、做成 Web app 不需要安装，为移动设备专门设计一个站点 优：同响应式 缺：一般主站和移动网站的域名是不同的，有时候需要进行重定向，用户体验可能会受到影响。维护的时候也需要二者同时维护 以上，响应式设计的方式是大势所趋。不过最终适合用户的才是最好的 服务器 服务器生成网页，储存网页，并将其分发到各个客户端上。服务器一般都位于被称为数据中心的房间里，需要控制温度、湿度、消防系统、保安、供电服务器之间以网线相连，很多数据都是通过海底光缆传输的 IP 地址和域名 全球各地的机器通过 Web 连接着，有些时服务器，有些是客户机 机器之间如何寻找和辨认？每台机器是通过互联网协议 Internet Protocol（IP）地址来表示的，并且是唯一标识 类比电脑---电话IP地址---电话号码 IP 地址的不同版本 IPv4地址长度 32 位，共有 2^32 个 IP 地址 详细见🔜计算机网络 IPv6地址长度 128 位，共有 2^128 个 IP 地址分为 8 段，每段 16 位，段与段之间通过冒号连接形象比喻：IPv6 可以使得地球上的每一粒沙子都拥有一个 IP 地址 IP 地址不便于记忆，于是就有了 域名我们可以通过 访问域名来代替长串的IP地址，更加方便由于服务器只认识 IP 地址，所以需要有能够将域名解析成对应的 IP地址的服务，它就是 域名系统 Domain Name System（DNS） DNS 域名服务器保存该网络中所有主机的域名和对应的 IP 地址 域名解析器能够将域名转换成 IP 地址 [!NOTE] 域名必须对应一个 IP 地址而 IP 地址不一定有域名 协议 人与人之间若要交流，则需要能够理解对方的语言，或者统一使用一种语言而 Web 中的机器也一样，科学家们发明了各种协议，只要机器都遵循同样的协议就能互相交流常见的协议，详细见🔜计算机网络 TCP 是端到端（P2P）的传输层数据流传输服务的协议。不同主机的两个应用程序之间建立虚拟连接，TCP 报文就能够在连接的基础上进行传输【可靠、全双工】 UDP 是无连接的传输层协议。【不可靠、简单的】 HTTP，设计最初目的是为了提供一种 发布和接收HTML页面 的方法 HTTPS，在HTTP的基础上添加了SSL/TLS握手以及数据加密传输 FTP，用于将文件从一台机器传送到另一台机器 SMTP，控制信件的中转方式，帮助计算机发送邮件时找到下一目的地 Web 程序员 任务：维持公司的网站运行良好 Web前端（FrontEnd）负责网站的外观 Web后端（BackEnd）负责网站服务器端的编写和维护，实现各种功能 质量主管（Quality Assurance Manager）对网站的质量进行监控，可以向其他职位人员提出问题或者新需求 系统管理员（System Administrator）保证Web服务器正常运作，负责一些硬件的维修和管理 全栈工程师（Full Stack）以上职位的任务均能胜任 学习路径：HTMLCSS选择一门喜欢的服务器语言JavaScriptLinux命令行 总的来说，还是多多逛大型编程社区，学习新兴的技术 经常练习编程，实践 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-23 22:05:43 "},"about_StudyPath/计算机操作系统.html":{"url":"about_StudyPath/计算机操作系统.html","title":"操作系统","keywords":"","body":"参考资料 https://blog.csdn.net/Royalic/article/details/119999404 操作系统概述 定义 操作系统是系统软件，用于：控制管理计算机的软硬件，分配调度资源 基本功能 1、统一管理计算机资源：处理器、IO设备、存储器、文件资源2、对计算机资源进行抽象：数据读写、文件操作接口3、提供用户与计算机之间的接口：图形用户界面、命令形式 特征 并行性 并发性 共享性：资源可供多个并发程序共同使用 虚拟性：把一个物理实体转变为若干个逻辑实体 异步性 [!NOTE] 同时访问，指的是某资源被多个程序 并发 的访问，注意不是并行虚拟和异步的前提就是具有并发性时分复用：不同程序 分时 使用硬件资源，提高资源利用率空分复用：将物理磁盘虚拟为逻辑磁盘，例如电脑的C、D盘等 中断处理 为什么需要中断处理？。。。。。。 分类 内中断：若当前执行的命令出现异常，CPU内部会发送该信号 外中断：CPU外部有中断信号传入 进程管理 进程概述 进程是系统进行 资源分配和调度 的基本单位是程序独立运行的载体大幅提升操作系统的资源利用率 [!NOTE] 进程存在的唯一标识：进程控制块（PCB），记录进程的状态和运行的信息 五状态模型 创建状态：准备好了PCB，但是缺少其他资源就绪状态：其他资源（内存、栈空间、堆空间等）也准备好了，就差CPU状态执行状态：进程获得CPU，正在执行阻塞状态：进程放弃CPU状态，阻塞的进程以队列的形式放置终止状态：系统清理、归还PCB状态 进程同步 四原则： 作业管理 作业管理的进程调度 计算机通过决策决定哪个进程获得CPU使用权 什么时候需要进程调度？ 主动放弃进程正常终止或者发生异常终止；等待I/O的主动阻塞 被动放弃进程的时间片用完；就绪队列中出现了优先级更高的进程；I/O中断等紧急的事情 调度方式 非抢占式：当前进程主动放弃CPU使用权 抢占式：操作系统剥夺当前进程的CPU使用权 调度机制 排队机制：就绪的进程按照一定方式排成队列 委派机制：从队列中选择某进程，将CPU资源分配给它 上下文切换机制：保存当前进程的上下文信息，放入主存中 调度算法 先来先服务 运行时间短的进程优先 高优先权优先 时间片轮转调度：按照先进先出的原则排列就绪进程，每次从队列取出一个进程并分配一个时间片执行 死锁 死锁 饥饿 死循环 进程之间由于 竞争资源 或者 彼此通信 或者 调度顺序不当 所造成的阻塞现象 进程长期得不到资源 代码存在BUG 怎样会导致死锁的产生？（死锁产生的必要条件） 互斥 保持资源 不可剥夺 环路等待 死锁处理策略 预防破坏上述条件中的一条或者多条 银行家算法检测当前剩余资源是否可以满足某进程的最大需求，可以的话就将其加入安全队列 撤销回退终止进程 存储管理 内存的分配与回收 动态分区分配算法 首次适应：每次从头部空间查找合适的内存区 最佳适应：空闲区链表需按照容量大小排列，遍历查找最合适的内存区 快速适应：？ 内存回收的过程当回收区出现在空闲区的不同位置的时候，回收区和空闲区是直接合并，还是需要创建新的空闲节点？新的空闲区使用的地址是哪一个？ 段页式存储管理 用于离散地管理进程的逻辑空间 段式存储，逻辑单位将进程逻辑空间分成若干段（不是等分）段的长度可以动态变化 页式存储，物理单位为了合理利用空间将进程逻辑空间 等分成 若干页面页面大小一般是512B~8KB 虚拟内存 对物理内存的扩充 [!NOTE] 局部性原理：CPU访问存储器时，所访问的存储单元都聚集在一个较小的连续区域中 Linux 的存储管理 Buddy 内存管理算法：解决内存外碎片的问题 Swap 空间是Linux系统的交换空间，是磁盘的一个分区，在初始化系统时配置的当内存满时，系统会将一些内存交换至Swap空间 Swap 空间 虚拟内存 操作系统概念 进程概念 解决系统的物理内存不足问题 解决进程的物理内存不足问题 文件管理 Linux 的文件系统 FAT NTFS EXT2/3/4 设备管理 IO 设备 存储设备：内存、磁盘、U盘 交互IO设备：键盘、显示器、鼠标 字符设备：打印机、shell终端 IO设备的缓冲区：减少CPU处理IO请求的频率 线程池 线程池存放多个线程。CPU调度线程执行后不会销毁线程，而是将其放回线程池以重新利用 作用：减少线程频繁创建和销毁；业务创建和处理解耦 队列是存放元素的池 如何实现线程安全？可以结合队列实现 1、若有多个线程访问队列中的元素 使用锁保护队列，保证多个线程获取的串行 2、若队列为空时 阻塞，使用条件变量等待队列不为空 Task 任务对象 实现任务具体的执行逻辑 ProcessThread 任务处理线程 实现线程执行的逻辑和停止 Pool 任务处理线程池 存放多个 ProcessThread，负责多个线程的启停，控制线程池的大小 AsyncTask 异步任务处理 给任务标记（任务是否完成），获取任务结果 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-29 21:06:53 "},"about_Math/":{"url":"about_Math/","title":"数学小记","keywords":"","body":"About Math 概率论与数理统计 高等数学 线性代数 概率论 统计相关 其他 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-03 22:33:47 "},"about_Math/概率论与数理统计笔记.html":{"url":"about_Math/概率论与数理统计笔记.html","title":"概率论与数理统计","keywords":"","body":"*人生，是从不充分的证据开始，引出完美结论的一种艺术。——Samuel Bulter* 参考资料 GitHub：QianXzhen 事件与概率 随机试验和随机事件 1、随机现象： 自然界中的 客观现象，当人们观测它时，所得结果不能预先确定，而仅仅是多种可能结果之一。 2、随机试验： 随机现象的实现和对它某个特征的观测。 3、基本事件： 随机试验中的每个单一结果，犹如分子中的原子，在化学反应中不可再分。 e.g. 硬币抛 3 次，有 2^3=8 种结果：正正正、正正反、正反正……这 8 种可能结果的每一个都是基本事件。 4、随机事件： 简称事件，在随机试验中我们所关心的、可能出现的各种结果，它由一个或若干个基本事件组成。 5、样本空间： 随机试验中所有基本事件所构成的集合，通常用 $\\Omega$ 或 $S$ 表示。 e.g. 掷一枚骰子，观察出现的点数，则 $\\Omega={1,2,3,4,5,6}$. 6、必然事件（$\\Omega$）： 在试验中一定会发生的事件。 7、不可能事件（$\\phi$）： 在试验中不可能发生的事件。 [!NOTE|style:flat] 根据随机现象做随机试验，随机试验产生随机事件，随机事件由基本事件组成，所有基本事件构成样本空间 事件的运算 1、子事件 $A \\subset B$： 事件 $A$ 发生蕴含事件 $B$ 一定发生，则事件 $A$ 称为事件 $B$ 的子事件。若 $A \\subset B$，且 $B \\subset A$，则称事件 $A$ 与事件 $B$ 相等，记为 $A=B$. 2、事件的和（$A \\cup B$）： 事件 $A$ 和事件 $B$ 中 至少有一个发生 称为事件 $A$ 和事件 $B$ 的和。 3、事件的积（$A \\cap B$）： 事件 $A$ 和事件 $B$ 同时发生称为 $A$ 和事件 $B$ 的积。如果 $A\\cap B=\\phi$，则称 $A$ 和 $B$ 不相容，即事件 $A$ 和 $B$ 不能同时发生。 4、对立事件 $A^c$（或 $\\overline{A}$）： $A$ 不发生这一事件称为事件 $A$ 的对立事件（或余事件）。 5、事件 $A$ 和事件 $B$ 的差（$A-B$）： 事件 $A$ 发生而事件 $B$ 不发生这一事件称为事件 $A$ 和事件 $B$ 的差，或等价于 $AB^c$. 6、De Morgan 对偶法则及其推广 \\overline{A\\cup B}=\\overline{A}\\cap \\overline{B}, \\overline{A\\cap B}=\\overline{A}\\cup \\overline{B} 上式可推广到 $n$ 个事件： \\overline{\\bigcup_{i=1}^{n}A_i}=\\bigcap_{i=1}^{n}\\overline{A_i}, \\overline{\\bigcap_{i=1}^{n}A_i}=\\bigcup_{i=1}^{n}\\overline{A_i}, 概率的定义   概率是 随机事件 发生的可能性大小的数字表征，其值在 [0,1] 之间，即概率是事件的函数。概率有以下定义： 古典概率   设一个试验有 N 个等可能的结果，而事件 $E$ 恰包含其中的 $M$ 个结果，则事件 $E$ 的概率，记为 $P(E)$，定义为 P(E)=M/N 或 P(E)=\\#(M) / \\#(N), 其中，$#(M)$ 为事件 $M$ 中基本事件的个数。   古典概型有 两个条件： 有限性，试验结果只有有限个（记为 $n$）， 等可能性，每个基本事件发生的可能性相同。 注： 古典概率可引申出“几何概率”。 概率的统计定义   古典概率的两个条件 往往不能满足，但可以将事件的随机试验独立反复做 $n$ 次（Bernouli 试验），设事件 $A$ 发生了 $n_A$ 次，称比值 $\\frac{n_A}{n}$ 为事件 $A$ 发生的频率，当 $n$ 越来越大时，频率会在某个值 p 附近波动，且波动越来越小，这个值 p 就定义为事件 $A$ 的概率。该学派为 频率派。 注： 不能写为 $lim_{n\\rightarrow{\\infty}}\\frac{n_A}{n}=p$，因为 $\\frac{n_A}{n}$ 不是 $n$ 的函数。 主观概率   主观概率可以理解为一种 心态或倾向性。究其根由，大抵有二：一是根据其经验和知识，二是根据其利害关系。该学派在金融和管理有大量的应用，这一学派称为 Bayes 学派。 概率的公理化定义   对概率运算规定一些简单的基本法则： 1、设 $A$ 是随机事件，则 $0 \\leq P(A) \\leq 1$, 2、设 $\\Omega$ 为必然事件，则 $P(\\Omega)=1$, 3、若事件 $A$ 和 $B$ 不相容，则 $P(A\\cup B)=P(A)+P(B)$, 可推广至无穷：P(\\bigcup_{i=1}^{n}A_i)=\\sum_{i=1}^{\\infty}P(A_i). 注： 1、一般情况下，$P(A\\cup B)=P(A)+P(B)-P(AB)$，$P(A\\cup B \\cup C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$ 2、$P(\\overline{A})=1-P(A)$ 3、$P(A-B)=P(A)-P(AB)$ 古典概率计算 排列组合 选排列： 从 $n$ 个不同元素中取 r 个不同取法（$1\\leq r\\leq n$），$P^{n}_{r}=n(n-1)...(n-r+1)$. 重复排列： 从 $n$ 个不同元素中可重复地取 r 个不同取法（$1\\leq r\\leq n$），$P^{n}_{r}=n^r$. 组合： 同选排列，但不考虑次序，$\\binom{n}{r}=\\frac{P^{n}_{r}}{r!}$. 注： 1、排列英文为 Permutation，组合英文为 Combination.2、$0!$ 为 1。当 r 不是非负整数时，记号 $r!$ 没有意义.3、一些书中将组合写成 $C{n}^{r}$ 或 $C{r}^{n}$，更通用的是 $\\binom{n}{r}$. 其他公式 组合系数 $\\binom{n}{r}$ 又常称为二项式系数 (a+b)^n=\\sum_{i=0}^{n}\\binom{n}{r}a^i b^{n-1} $n$ 个相异物件分成 k 堆，各堆物件数分为 $r_1, ..., r_k$ 的方法是 n!/(r_1!...r_k!). 条件概率   条件概率就是知道了 一定信息 下得到的随机事件的概率。设事件 $A$ 和 $B$ 是随机试验 $\\Omega$ 中的两个事件，$P(B)>0$，称 P(A|B)=\\frac{P(AB)}{P(B)} 为事件 $B$ 发生条件下事件 $A$ 发生的条件概率，可用图形表示： 注： 事实上，我们所考虑的概率都是在一定条件下计算的，因为随机试验就是在一定条件下进行的。 条件概率性质   给定 $A$ 发生，$P(A)>0$： $0 \\leq P(B|A) \\leq 1$ $0 \\leq P(\\Omega|A) = 1$ 若 $B_1 \\cap B_2 = \\phi _1$，则 $P(B_1 \\cup B_2 | A) = P(B_1|A) + P(B_2|A)$，可推广至无穷。 乘法定理   由 $P(A|B)=\\frac{P(AB)}{P(B)} \\Rightarrow P(AB)=P(A|B)P(B)$，可推广至 P(A_1 A_2 ...A_n)=P(A_1)P(A_2|A_1)...P(A_n|A_1...A_{n-1}) 注： 右边看似麻烦，其实容易算，左边看似简单，但是难算。 全概率   设 $B1,B_2,...B_n$ 是样本空间$\\Omega$ 中的 两两不相容 的一组事件，即$B_i B_j=\\phi$，$i\\neq j$，且满足$\\bigcup{i=1}^{n}B_i=\\Omega$，则称 $B_1,B_2,...B_n$ 是样本空间 $\\Omega$ 的一个分割（又称为 完备事件群，英文为 partition）。   设 ${B_1,B_2,...B_n}$ 是样本空间 $\\Omega$ 的一个分割，$A$ 为 $\\Omega$ 的一个事件，则 P(A)=\\sum_{i=1}^{n}P(A|B_i)P(B_i) 推导： \\begin{align} P(A)&=P(A \\cap \\Omega)\\\\ &=P(A \\cap \\sum_{i=1}^{n}B_i)\\\\ &=P(\\sum_{i=1}^{n}AB_i)\\\\ &=\\sum_{i=1}^{n}P(AB_i)\\\\ &=\\sum_{i=1}^{n}P(A|B_i)P(B_i)\\\\ &=\\sum_{i=1}^{n}P(A|B_i)P(B_i) \\end{align} 注： 有时不易直接计算事件 $A$ 的概率，但是在每个 $B_i$ 上 $A$ 的条件概率容易求出 Bayes 公式   设 ${B_1, B_2, ...B_n}$ 是样本空间的一个分割，$A$ 为 $\\Omega$ 中的一个事件，$P(B_i)>0$，$i=1,2,...,n$，$P(A)>0$，则 P(B_i|A)=\\frac{P(A|B_i)P(B_i)}{\\sum_{j=1}^{n}P(A|B_j)P(B_j)} 注： 当有 因果关系互换 时必须用 Bayes 公式。 事件的独立性   设 $A$，$B$ 是随机试验中的两个事件，若满足 $P(AB)=P(A)P(B)$，则称事件 $A$ 和 $B$ 相互独立。判断事件的独立，应该是 从实际出发，如果能够判断事件 $B$ 的发生与否对事件 $A$ 的发生与否不产生影响，则事件 $A$，$B$ 即为独立。   设 $\\widetilde{A}$ 表示事件 $A$ 发生和不发生之一，$\\widetilde{B}$ 表示事件 $B$ 发生和不发生之一。有独立性的定义可推至 $P(\\widetilde{A}\\widetilde{B})=P(\\widetilde{A})P(\\widetilde{B})$（一共有四个等式）。可推广至： P(\\widetilde{A}_1\\widetilde{A}_2...\\widetilde{A}_n)=P(\\widetilde{A}_1)...P(\\widetilde{A}_n) 上面有 $2^n$ 个等式。 注： 独立（independent）和不相容（exclusive）是不同的两个概念，前者有公共部分，后者没有公共部分，独立一定相容。 重要公式与结论 \\begin{align} &(1)\\ P(\\overline{A})=1-P(A)\\\\ \\\\ &(2)\\ P(A \\cup B)=P(A)+P(B)-P(AB)\\\\ \\\\ &(3)\\ P(A\\cup B \\cup C)=P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)\\\\ \\\\ &(4)\\ P(A-B)=P(A)-P(AB)\\\\ \\\\ &(5)\\ P(A\\overline{B})=P(A)-P(AB),P(A)=P(AB)+P(A\\overline{B}),\\\\ &\\ \\ \\ \\ \\ \\ P(A\\cup B)=P(A)+P(\\overline{A}B)=P(AB)+P(A\\overline{B})+P(\\overline{A}B)\\\\ \\\\ &(6)\\ P(\\overline{A}_1|B)=1-P(A_1|B),P(A_1\\cup A_2|B)=P(A_1|B)+P(A_2|B)-P(A_1A_2|B)\\\\ &\\ \\ \\ \\ \\ P(A_1A_2|B)=P(A_1|B)P(A_2|A_1B)\\\\ \\\\ &(7)\\ 若A_1,A_2,...A_n相独立，则P(\\bigcap_{i=1}^{n}A_i)=\\prod_{i=1}^{n}P(A_i),P(\\bigcup_{i=1}^{n}A_i)=\\prod_{i=1}^{n}(1-P(A_i)) \\end{align} 随机变量及其分布 随机变量的概念 1、随机变量（Random variable）： 值随机会而定的变量，研究随机试验的一串事件。可按维数分为一维、二维至多维随机变量。按性质可分为 离散型随机变量 以及 连续型随机变量。2、分布（Distribution）： 事件之间的联系，用来计算概率。3、示性函数（Indication function）： $I_A(\\omega)=\\begin{cases} 1& \\omega \\in A \\ 0& \\text{ 反之} \\end{cases}$，事件 $A$ 有随机变量 $I_A$ 表示出来，$I_A$ 称为事件 $A$ 的示性函数。 离散型随机变量及其分布 1、离散型随机变量： 设 $X$ 为一随机变量，如果 $X$ 只取有限个或可数个值，则称 $X$ 为一个（一维）离散型随机变量。 2、概率函数： 设 $X$ 为一随机变量，其全部可能值为 ${a_1, a_2,...}$，则 $p_i=P(X=a_i),i=1,2,...$ 称为 $X$ 的概率函数。 3、概率分布： 离散型随机变量的概率分布可以用分布表来表示： 可能值 $a_1$ $a_2$ ... $a_i$ ... 概率 $p_1$ $p_2$ ... $p_i$ ... 4、概率分布函数： 定义： 设 $X$ 为一随机变量，则函数 F(X)=P(X\\leq x)\\quad(-\\infty 称为 $X$ 的分布函数。（注：这里并未限定 $X$ 为离散型的，它对任何随机变量都有定义。） 性质： $F(x)$ 是单调非降的：当 $x_1 当 $x \\rightarrow \\infty$ 时，$F(x)\\rightarrow1$；当 $x \\rightarrow-\\infty$ 时，$F(x)\\rightarrow0$. 离散型随机变量分布函数： 对于离散型随机变量，$F(X)=P(X\\leq x)=\\sum_{{i|a_i\\leq x}}p_i, \\quad p_i=P(X=i)=F(i)-F(i-1)$。 5、二项分布（Bionomial distribution）： 定义： 设某事件 $A$ 在一次试验中发生的概率为 $p$，先把试验独立地重复 n 次，以 $X$ 记 $A$ 在这 n 次试验中发生的次数，则 $X$ 取值 $0,1,...,n$，且有 P(X=k)=\\binom{n}{k}p^k(1-p)^{n-k},\\quad k=0,1,...,n 称 $X$ 服从二项分布，记为 $X\\sim B(n,p)$. 服从二项分布的条件： 1、各次试验的条件是稳定的，即事件 $A$ 的概率 $p$ 在各次试验中保持不变；2、各次试验的独立性 6、泊松分布（Poisson distribution）： 定义： 设随机变量 $X$ 的概率分布为 P(X=i)=\\frac{\\lambda^i}{i!}e^{-\\lambda},\\quad i=0,1,2,...,\\quad\\lambda>0 则称 $X$ 服从参数为 $\\lambda$ 的 Poisson 分布，并记 $X\\sim P(\\lambda)$. 特点： 描述稀有事件发生概率 作为二项分布的近似。若 $X\\sim B(n,p)$，其中 $n$ 很大，$p$ 很小，而 $np=\\lambda$ 不太大时（一般 $n>30,np\\leq5$），则 $X$ 的分布接近泊松分布 $P(\\lambda)$. 推导： 若事件 $A\\sim B(n,p)$，且 $n$ 很大，$p$ 很小，而 $np=\\lambda$ 不太大时，设 $\\lambda=np$， \\begin{align} P(X=i)&=\\lim_{n\\rightarrow \\infty}\\binom{n}{i}(\\frac{\\lambda}{n})^i(1-\\frac{\\lambda}{n})^{n-i}\\\\ &=\\lambda^i\\lim_{n\\rightarrow \\infty}\\frac{\\binom{n}{i}}{n^i}\\lim_{n\\rightarrow \\infty}(1-\\frac{\\lambda}{n})^{n-i}\\\\ &=\\lambda^i e^{-\\lambda}\\lim_{n\\rightarrow \\infty}\\frac{n(n-1)(n-2)...(n-i+1)}{i!n^i}\\\\ &=\\lambda^i e^{-\\lambda}\\lim_{n\\rightarrow \\infty}\\frac{(1-\\frac{1}{n})(1-\\frac{2}{n})...(1-\\frac{i-1}{n})}{i!}\\\\ &=\\frac{\\lambda^i}{i!}e^{-\\lambda} \\end{align} 连续型随机变量及其分布 1、连续型随机变量： 设 $X$ 为一随机变量，如果 $X$ 不仅有无限个而且有不可数个值，则称 $X$ 为一个连续型随机变量。 2、概率密度函数： 定义： 设连续型随机变量 $X$ 有概率分布函数 $F(x)$，则 $F(x)$ 的导数 $f(x)=F'(x)$ 称为 $X$ 的概率密度函数。 性质： 对于所有的 $-\\infty $\\int_{-\\infty}^{+\\infty}f(x)dx=1$； 对于任意的 $-\\infty 注： 对于任意的 $-\\infty 假设有总共一个单位的质量连续地分布在 $a\\leq x\\leq b$ 上，那么 $f(x)$ 表示在点 $x$ 的质量密度且 $\\int_{c}^{d}f(x)dx$ 表示在区间 $[c, d]$ 上的全部质量。 3、概率分布函数： 设 $X$ 为一连续型随机变量，则 F(x)=\\int_{-\\infty}^xf(u)du,\\quad-\\infty 4、正态分布（Normal distribution）： 定义： 如果一个随机变量具有概率密度函数 f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}},\\quad -\\infty 其中 $-\\infty0$，则称 $X$ 为正态随机变量，并记为 $X\\sim N(\\mu,\\sigma^2)$.特别地，$\\mu=0,\\sigma=1$ 的正态分布称为标准正态分布。用 $\\Phi(x)$ 和 $\\phi(x)$ 表示标准正态分布 $N(0,1)$ 的分布函数和密度函数。 性质： 正态分布的密度函数是以 $x=\\mu$ 为对称轴的对称函数，$\\mu$ 称为位置参数，密度函数在 $x=\\mu$ 处达到最大值，在 $(-\\infty,\\mu)$ 和 $(\\mu,+\\infty)$ 内严格单调。 $\\sigma$ 的大小决定了密度函数的陡峭程度，通常称 $\\sigma$ 为正态分布的形状参数。 若 $X\\sim N(\\mu,\\sigma^2)$，则 $Y=(X-\\mu)/\\sigma\\sim N(0,1)$. $\\Phi(-k)=1-\\Phi(k)$ 图像（密度和分布函数图）： 4、指数分布（Exponential distribution）： 定义： 若随机变量 $X$ 具有概率密度函数 f(x)= \\begin{cases} \\lambda e^{-\\lambda x}& x>0 \\\\ 0& x\\leq 0 \\end{cases} =\\lambda e^{-\\lambda x}I_{(0,\\infty)}(x) 其中 $\\lambda >0$ 为常数，则称 $X$ 服从参数为 $\\lambda$ 的指数分布。 概率分布函数： $F(x)=\\begin{cases} 1-e^{-\\lambda x}& x>0 \\ 0& x\\leq 0 \\end{cases}=(1-e^{-\\lambda x})I_{(0,\\infty)}(x)$ 性质： 无后效性，即无老化，要来描述寿命（如元件等）的分布。 证明： “无老化”就是说在时刻 $x$ 正常工作的条件下，其失效率总保持为某个常数 $\\lambda>0$，与 $x$ 无关，可表示 \\begin{align} &P(x\\leq X\\leq x+h|X>x)/h=\\lambda\\quad(h\\rightarrow0)\\\\ 证：\\\\ &\\lim_{h\\rightarrow0}\\frac{P(x\\leq X\\leq x+h|X>x)}{h}\\\\ =&\\lim_{h\\rightarrow0}\\frac{P(x\\leq X\\leq x+h,X>x)}{P(X>x)h}\\\\ =&\\lim_{h\\rightarrow0}\\frac{P(xx)h}\\\\ =&\\lim_{h\\rightarrow0}\\frac{-e^{-\\lambda t}|^{x+h}_{x}}{-e^{-\\lambda t}|^{\\infty}_{x}h}\\\\ =&\\lim_{h\\rightarrow0}\\frac{e^{-\\lambda x}-e^{-\\lambda x-\\lambda h}}{e^{-\\lambda x}h}\\\\ =&\\lim_{h\\rightarrow0}\\frac{1-\\frac{1}{e^{xh}}}{h}\\\\ =&\\lim_{h\\rightarrow0}\\lambda e^{-\\lambda h}\\\\ =&\\lambda \\end{align} $\\lambda$ 为失效率，失效率越高，平均寿命就越小。 图像（密度函数）： 5、均匀分布（Uniform distribution）： 定义： 设 $a f(x)= \\begin{cases} \\frac{1}{b-a}& a\\leq x\\leq b \\\\ 0& 其它 \\end{cases} =\\frac{1}{b-a}I_{(a,b)}(x) 则该分布为区间 $[a,b]$ 上的均匀分布。 概率分布函数： $F(x)=\\begin{cases} 0& x\\leq a \\ \\frac{x-a}{b-a}& ab \\end{cases}$ 性质： $\\forall R(c,d) \\subset R(a,b),\\ P(c 多维随机变量（随机向量） 1、随机向量： 设 $X={X_1,...,X_n}$.如果每个 $X_i$ 都是一个随机变量，$i=1,...,n$，则称 $X$ 为 $n$ 维随机变量或者随机向量。 2、离散型随机向量的分布： 如果每一个 $Xi$ 都是一个离散型随机变量，$i=1,...,n$，则称 $X={X_1,...,X_n}$ 为一 $n$ 维离散型随机变量。设 $X_i$ 的所有可能取值为 ${a{i1},a{i2},...},\\quad i=1,...,n$，则称 p(j_1,...,j_n)=P(X_1=a_{1j_1},...,X_n=a_{nj_n}),\\quad j_1,...,j_n=1,2,... 为 $n$ 维随机变量 $X$ 的概率函数，这也是其联合分布。 其具有下列性质： $p(j_1,...,j_n)\\geq0,\\quad j_i=1,2,...,\\quad i=1,2,...,n;$ $\\sum_{j_1,...,j_n}p(j_1,...,j_n)=1.$ 注： 对于高维离散型随机变量，一般不使用分布函数 3、多项式分布 定义： 设 $A_1,A_2,...,A_n$ 是某一试验之下的完备事件群，分别以 $p_1,p_2,...,p_n$ 记事件 $A_1,A_2,...,A_n$ 的概率，则 $p_i\\geq 0,\\quad p_1+...+p_n=1$. 将试验独立地重复 $N$ 次，以 $X_i$ 记在这 $N$ 次试验中事件 $A_i$ 出现的次数 $(i=1,...,n)$，则 $X=(X_1,...,X_n)$为一个 $n$ 维随机向量。该分布记作 $M(N;p_1,...,p_n)$. 概率分布函数： $P(X_1=k_1,X_2=k_2,...,X_n=k_n)=\\frac{N!}{k_1!k_2!...k_n!}p_1^{k_1}p_2^{k_2}....p_n^{k_n}$ 4、连续型随机向量的分布： $X={X_1,...,X_n}$为 $n$ 维连续型随机变量，如果存在 $\\R^n$ 上的非负函数 $f(x_1,...,x_n)$，使得对任意的$-\\infty P(a_1\\leq X_1 \\leq b_1,...,a_n\\leq X_n\\leq b_n)=\\int_{a_n}^{b_n} ...\\int_{a_1}^{b_1}f(x_1,...,x_n)dx_1...dx_n 则称为 $f$ 为 $X$ 的概率密度函数。有 P(a_1\\leq X_1 \\leq b_1,...,a_n\\leq X_n\\leq b_n)=F(x_1,...,x_n) 则称为 $F$ 为 $X$ 的（联合）分布函数。其中分布函数 $F(X_1,...,X_n)$ 具有下述性质： $F(x_1,...,x_n)$ 单调非降； 对任意的 $1\\leq j \\leq n$，有 $\\lim_{x_j\\rightarrow-\\infty F(x_1,...,x_n)}=0$； $\\lim_{x_1\\rightarrow\\infty,...,x_n\\rightarrow\\infty}F(x_1,...,x_n)=1$ 5、边缘分布： 因为 $X$ 的每个分量 $X_i$ 都是一维随机变量，故它们都有各自的分布 $F_i\\ (i=1,...,n)$，这些都是一维分布，称为随机向量 $X$ 或其分布 $F$ 的边缘分布。 离散型随机向量 行和与列和就是边缘分布。即固定某个 $x_i$，即可计算边缘分布，故有 p_X(x_i)=P(X=x_i)=\\sum_{j}^{m}P(X=x_i,Y=y_j)=\\sum_{j}^{m}p_{ij}=p_{i\\cdot},\\quad i=1,2,...,n\\\\ p_Y(y_i)=P(Y=y_i)=\\sum_{i}^{m}P(X=x_i,Y=y_j)=\\sum_{i}^{m}p_{ij}=p_{j\\cdot},\\quad j=1,2,...,n 连续型随机向量 为求某分量 $Xi$ 的概率密度函数，只需把 $f(x_1,...,x_n)$ 中的 $x_i$ 固定，然后对$x_1,...,x{i-1},x_{i+1},...,x_n$ 在 $-\\infty$ 到 $\\infty$ 之间做定积分，如 (X,Y)\\sim f(x, y)\\\\ f_X(u)=\\int^{+\\infty}_{-\\infty}f(u,v)dv\\\\ f_Y(u)=\\int^{+\\infty}_{-\\infty}f(u,v)du\\\\ 注： 二维正态分布 $N(a,b,\\sigma_1^2,\\sigma_2^2,\\rho )$ 的边缘分布密度分别是一维正态分布 $N(a,\\sigma_1^2)$ 和 $N(b,\\sigma_2^2)$。因此联合分布可推边缘分布，而边缘分布不可推联合分布。 条件分布和随机变量的独立性 1、离散型随机变量的条件分布： 设 $(X,Y)$ 为二维离散型随机变量，对于给定的事件 ${Y=y_j}$，其概率 $P(Y=y_j)>0$，则称 P(X=x_i|Y=y_j)=\\frac{P(X=x_i,Y=y_j)}{P(Y=y_j)}=\\frac{p_{ij}}{p_{\\cdot j}},\\quad i=1,2,... 为在给定 $Y=y_j$ 的条件下 $X$ 的条件分布律。类似的，称 P(Y=y_i|X=x_j)=\\frac{P(X=x_i,Y=y_j)}{P(X=x_j)}=\\frac{p_{ij}}{p_{i\\cdot}},\\quad j=1,2,... 为在给定 $X=x_j$ 的条件下 $Y$ 的条件分布律。 2、连续型随机变量的条件分布： 设 $(X,Y)$ 为二维连续型随机变量，对于给定条件 $Y=y$ 下的条件概率密度为 f_{X|Y}(x|y)=\\frac{f(x,y)}{f_Y(y)}, \\quad f_Y(y)>0.\\\\ 类似的，在 $X=x$ 下的条件概率密度为 f_{Y|X}(y|x)=\\frac{f(x,y)}{f_X(x)}, \\quad f_X(x)>0.\\\\ 二维正态分布 $\\rho=0$ 时，其联合密度分布等于条件密度分布的乘积。 3、随机变量的独立性 称随机变量 $X_1, ...,X_n$ 相互独立， 离散型随机变量 则联合分布律等于各自的边缘分布律的乘积，即 P(X_1=x_1,...,X_n=x_n)=P(X_1=x_1)...P(X_n=x_n) 其中 $(x_1,...x_n)$ 为 $(X_1,...,X_n)$ 的值域中的任意一点。 连续型随机变量 则联合密度等于各自的边缘密度的乘积，即 f(x_1,...,x_n)=f_1(x_1)...f_n(x_n),\\quad \\forall(x_1,...,x_n)\\in \\R ^n 更具一般地 设 $X_1,...,X_n$ 为 $n$ 个随机变量，如果它们的联合分布函数等于各自边缘分布函数的乘积，即 F(X_1, ...,x_n)=F_1(x_1)...F_n(x_n),\\quad \\forall (x_1,...,x_n)\\in \\R^n 则称随机变量 $X_1, ...,X_n$ 相互独立。 一些重要的结论 随机变量的函数的概率分布   最简单的情形，是由一维随机变量 $X$ 的概率分布去求其一给定函数 $Y=g(X)$ 的分布。较为常见的，是由 $(X_1,X_2,...,X_n)$ 的分布去求 $Y=g(X_1,X_2,...,X_n)$ 的分布。更一般地，由 $(X_1,X_2,...,X_n)$ 的分布去求 $(Y_1,Y_2,...,Y_m)$ 的分布，其中 $Y_i=g_i(X_1,X_2,...,X_n),\\quad i=1,2,...,m$. 1、离散型分布的情形： 设 $X$ 的分布律为 $P(X=x_i)=p_i,\\quad i=1,2,...$ $g:R\\rightarrow R$，令 $Y=g(X)$，则 $Y$ 的分布律为 P(Y=y_j)=P(g(X)=y_j)=\\sum_{x_i:g(x_i)=y_j}P(X=x_i)=\\sum_{i:g(x_i)=y_j}p_i 即把 $Y=g(X_1,...,X_n)$ 可以取的不同值找出来，把与某个值相应的全部 $(X_1,...,X_n)$ 值的概率加起来，即得 $Y$ 取这个值的概率。 2、连续型分布的情形 一个变量的情况 设 $X$ 有密度函数 $f(x)$.设 $Y=g(x)$，$g$ 是一个严格单调的函数，即当 $x_1x_2$ 时，必有 $g(x_1)>g(x_2)$.又设 $g$ 的导数 $g'$ 存在。由于 $g$ 的严格单调性，其反函数 $X=h(Y)$ 存在，且 $h$ 的导数 $h'$ 也存在。有 $g(X)$ 的密度函数 $l(y)$ 为 l(y)=f(h(y))|h'(y)|. 多个变量的情形 以两个为例，设 $(X_1,X_2)$ 的密度函数 $f(x_1,x_2)$，$Y_1,Y_2$ 都是 $(X_1,X_2)$ 的函数： Y_1=g_1(X_1,X_2),\\quad Y_2=g_2(X_1,X_2), 要求 $(Y_1,Y_2)$ 的概率密度函数 $l(y_1,y_2)$.假定 $(X_1,X_2)$ 到 $(Y_1,Y_2)$ 的一一对应变换有逆变换： X_1=h_1(Y_1,Y_2),\\quad X_2=h_2(Y_1,Y_2) 即雅可比行列式 J(y_1,y_2)=\\begin{vmatrix} \\partial h_1/\\partial y_1&\\partial h_1/\\partial y_2 \\\\ \\partial h_2/\\partial y_1&\\partial h_2/ \\partial y_2 \\end{vmatrix} 不为 0.在 $(Y1,Y2)$ 的平面上任取一个区域 $A$，变换后到 $(X_1,X_2)$ 平面的区域 $B$，则有 P((Y_1,Y_2)\\in A)=P((X_1,X_2)\\in B)=\\iint_Bf(x_1,x_2)dx_1dx_2\\\\ P((Y_1,Y_2)\\in A)=\\iint_Af(h_1(y_1,y_2),h_2(y_1,y_2))|J(y_1,y_2)|dy_1dy_2 随机变量和的密度函数 设 $(X_1,X_2)$ 的联合密度函数为 $f(x_1,x_2)$，$Y=X_1+X_2$ 的密度函数： 一般的，$l(y)=\\int{-\\infty}^\\infty f(x_1,y-x_1)dx_1=\\int{-\\infty}^\\infty f(x,y-x)dx$. 若 $X1,X_2$ 独立，则 $l(y)=\\int{-\\infty}^\\infty f1(x)f_2(y-x)dx=\\int{-\\infty}^\\infty f_1(y-x)f_2(x)dx$. 两个独立的正态变量的和仍服从正态分布，且有关的参数相加，其逆命题也成立。 随机变量商的密度函数 设 $(X_1,X_2)$ 的联合密度函数为 $f(x_1,x_2)$，$Y=X_1/X_2$ 的密度函数： 一般的，$l(y)=\\int_{0}^\\infty x_1f(x_1,x_1y)dx_1$. 若 $X1,X_2$ 独立，则 $l(y)=\\int{0}^\\infty x_1f_1(x_1)f_2(x_1y)dx_1$. 统计学三大分布 引入两个重要的特殊函数： $\\Gamma(x)=\\int_0^\\infty e^{-t}t^{x-1}dt\\quad (x>0)$ 和 $B(x,y)=\\int_0^1t^{x-1}(1-t)^{y-1}dt\\quad (x>0,y>0)$ 其中，$\\Gamma(1)=1,\\quad \\Gamma(1/2)=\\sqrt{\\pi},\\quad \\Gamma(n)=(n-1)!$ $B(x,y)=\\Gamma(x)\\Gamma(y)/\\Gamma(x+y)$ 卡方分布，记作 $\\chi_n^2$ 密度函数： $kn(x)=\\frac{1}{\\Gamma(\\frac{n}{2}2^{n/2})}e^{-x/2}x^{(n-2)/2}I{(0,\\infty)}(x)$ 性质： 1、设 $X1,X_2$ 独立，$X_1\\sim\\chi_m^2,X_2\\sim\\chi_n^2$，则 $X_1+X_2\\sim\\chi{m+n}^2$ ​2、若 $X1,...,X_n$ 独立，且都服从指数分布，则 $X=2\\lambda(X_1+...+X_n)\\sim\\chi{2n}^2$ $t$ 分布，记作 $t_n$ 设 $X_1，X_2$ 独立，$X_1\\sim\\chi_n^2,X_2\\sim N(0,1)$，而 $Y=X_2/\\sqrt{X_1/n}$，则 $Y\\sim t_n$. 密度函数： $t_n(y)=\\frac{\\Gamma((n+1)/2)}{\\sqrt{n\\pi}\\Gamma(n/2)}(1+\\frac{y^2}{n})^{(\\frac{n+1}{2})}$ 性质： 密度函数关于原点对称，其图形与正态分布 $N(0,1)$ 的密度函数的图形相似。 $F$分布，记作 $F_{mn}$ 设 $X1,X_2$ 独立，$X_1\\sim\\chi_n^2,X_2\\sim\\chi_m^2$，而 $Y=m^{-1}X_2/(n^{-1}X_1)$，则 $Y\\sim F{mn}$ 密度函数： $f_{mn}(y)=m^{m/2}n^{n/2}\\frac{\\Gamma(\\frac{m+n}{2})}{\\Gamma(\\frac{m}{2})\\Gamma(\\frac{n}{2})}y^{m/2-1}(my+n)^{-(m+n)/2}\\quad (y>0)$ 三大分布的几个重要性质 1、设 $X1,...,X_n$ 独立同分布，有公共的正态分布 $N(\\mu,\\sigma^2)$.记 $\\bar{X}=(X_1+...+X_n),S^2=\\sum{i=1}^{n}(Xi-\\bar(X))^2/(n-1)$.则 $(n-1)S^2/\\sigma^2=\\sum{i=1}^{n}(Xi-\\bar{X})^2/\\sigma^2\\sim\\chi{n-1}^{2}$. 2、设 $X1,...,X_n$ 的假定同 1，则 $\\sqrt{n}(\\bar{X}-\\mu)/S\\sim t{n-1}$ 3、设 $X_1,...,X_n,Y_1,...,Y_m$ 独立，$X_i$ 各有分布 $N(\\mu1,\\sigma_1^2)$，$Y_j$ 各有分布 $N(\\mu_2,\\sigma_2^2)$，则 > [\\sum_{j=1}^m(Y_j-\\bar{Y})^2/(\\sigma_2^2(m-1))]/[\\sum_{i=1}^n(X_i-\\bar{X})^2/(\\sigma_1^2(n-1))]\\sim F_{m-1,n-1} > 若 $\\sigma_1^2=\\sigma_2^2$，则 > \\sqrt{\\frac{nm(n+m-2)}{n+m}}[(\\bar{X}-\\bar{Y})-(\\mu_1-\\mu_2)]/[\\sum_{i=1}^{n}(X_i-\\bar{X})^2+\\sum_{j=1}^m(Y_j-\\bar{Y})^2]^{1/2}\\sim t_{n+m-2} > 随机变量的数字特征 数学期望（均值）与中位数 1、数学期望 定义：设随机变量 $X$ 只取有限个可能值$a_1,...,a_m$，其概率分布为 $P(X=a_i)=p_i\\ (i=1,...,m)$.则 $X$ 的数学期望记作 $E(X)^*$ 或 $E(X)$，定义为 $E(X)=a_1p_1+a_2p_2+...+a_mp_m$.数学期望也常称为”均值“，即指以概率为权的加权平均。 离散型变量的数学期望： $E(X)=\\sum^\\infty{i=1}a_ip_i.$（当级数绝对收敛，即 $\\sum{i=1}^\\infty|a_i|p_i 连续型变量的数学期望： $E(X)=\\int{-\\infty}^\\infty xf(x)dx$.（当 $\\int{-\\infty}^\\infty |x|f(x)dx 常见分布的数学期望： 泊松分布： $E(X)=\\lambda$. 二项分布： $E(X)=np$. 均匀分布： $E(X)=\\frac{1}{2}(a+b)$. 指数分布： $E(X)=\\lambda^{-1}$. 正态分布： $E(X)=\\mu$. 卡方分布： $E(X)=n$. $t$ 分布： $E(X)=0 \\quad (n>1)$. $F$分布：$E(X)=n/(n-2)\\quad (n>2)$. 性质： 若干个随机变量之和的期望等于各变量的期望值和，即 E(X_1+X_2+...+X_n)=E(X_1)+E(X_2)+...+E(X_n). 若干个 独立 随机变量之积的期望等于各变量的期望之积，即 E(X_1X_2...X_n)=E(X_1)E(X_2)...E(X_n). 设随机变量 $X$ 为离散型，有分布 $P(X=a_i)=p_i(i=1,2,...)$；或者为连续型，有概率密度函数 $f(x)$.则 E(g(x))=\\sum_ig(a_i)p_i\\quad (当\\sum_i|g(a_i)|p_i 若 $c$ 为常数，则 $E(cX)=cE(X)$. 2、条件数学期望 定义： 随机变量 $Y$ 的条件期望就是它在给定的某种附加条件下的数学期望。$E(Y|x)=\\int_{-\\infty}^{\\infty}yf(y|x)dy$.它反映了随着 $X$取值 $x$ 的变化 $Y$ 的平均变化的情况如何。在统计上，常把条件期望 $E(Y|x)$ 作为 $x$ 的函数，称为 $Y$ 对 $X$ 的回归函数。 性质： $E(Y)=\\int_{-\\infty}^{\\infty}E(Y|x)f_X(x)dx$. $E(Y)=E[E(Y|X)]$. 3、中位数 定义： 设连续型随机变量 $X$ 的分布函数为 $F(x)$，则满足条件 $P(X\\leq m)=F(m)=1/2$ 的数 $m$ 称为 $X$ 或分布 $F$ 的中位数。即 $m$ 这个点把 $X$ 的分布从概率上一切两半。 性质： 与期望值相比，中位数受特大值或特小值影响很小，而期望不然。 中位数可能不唯一，且在某些离散型情况下，中位数不能达到一分两半的效果。 方差与矩 1、方差与标准差 定义： 设 $X$ 为随机变量，分布为 $F$，则 $Var(X)=E(X-EX)^2$ 称为 $X$（或分布 $F$）的方差，其平方根 $\\sqrt{Var(X)}$（取正值）称为 $X$（或分布 $F$）的标准差。 常见分布的方差： 泊松分布： $Var(X)=\\lambda$. 二项分布： $Var(X)=np(1-p)$. 正态分布： $Var(X)=\\sigma^2$. 指数分布： $Var(X)=1/\\lambda^2$. 均匀分布： $Var(X)=(b-a)^2/12$. 卡方分布： $Var(X)=2n$. $t$ 分布： $Var(X)=n/(n-2)$. $F$ 分布： $Var(X)=2n^2(m+n-2)/[m(n-2)^2(n-4)]\\quad (n>4)$. 性质： $Var(X)=E(X^2)-(EX)^2$. 常数的方差为 0，即 $Var(c)=0$. 若 $c$ 为常数，则 $Var(X+c)=Var(X)$. 若 $c$ 为常数，则 $Var(cX)=c^2Var(X)$. 独立 随机变量和的方差等于各变量方差和，即 $Var(X_1+...+X_n)=Var(X_1)+...+Var(X_n)$. 2、矩 定义： 设 $X$ 为随机变量，$c$ 为常数，$k$ 为正整数。则量 $E[(X-c)^k]$ 称为 $X$ 关于 $c$ 点的 $k$ 阶矩。特别地，有两种重要的情况： (1) $c=0$ .这时 $a_k=E(X^k)$ 称为 $X$ 的 $k$ 阶原点矩。 (2) $c=E(X)$.这时 $\\mu_k=E[(X-EX)^k]$ 称为 $X$ 的 $k$ 阶中心矩。 一阶原点矩就是期望，一阶中心距 $\\mu_1=0$，二阶中心距 $\\mu_2$ 就是 $X$ 的方差 $Var(X)$. 两种重要应用： 偏度系数： $\\beta_1=\\mu_3/\\mu_2^{3/2}$.衡量概率分布函数 $f(x)$ 是否关于均值对称。如果 $\\beta>0$，则称分布为正偏或右偏；如果 $\\beta 峰度系数： $\\beta_2=\\mu_4/\\mu_2^2$.衡量概率分布函数 $f(x)$ 在均值附近的陡峭程度。若 $X$ 有正态分布 $N(\\mu,\\sigma^2)$，则 $\\beta_2=3$.(注：$\\mu_2^2$ 为标准差的四次方，将 $\\mu_4$ 缩放到一次因次。为了迁就正态分布，也常定义 $\\mu_4/\\mu_2^2-3$ 为峰度系数，以使正态分布的峰度系数为 0) 协方差与相关系数   两者都反映了随机变量之间的关系。 1、协方差（Covariance） 定义： 称 $E[(X-m_1)(Y-m_2)]$ 为 $X$，$Y$ 的协方差，并记为 $Cov(X,Y)$. 性质： $Cov(X,Y)$ 与 $X,Y$ 的次序无关，即 $Cov(X,Y)=Cov(Y,X)$. $Cov(c_1X+c_2,c_3Y+c_4)=c_1c_3Cov(X,Y)$. $Cov(X,Y)=E(XY)-E(X)E(Y)$. 若 $X,Y$ 独立，则 $Cov(X,Y)=0$. $[Cov(X,Y)]^2\\leq \\sigma_1^2\\sigma_2^2$.等号当且仅当 $X,Y$ 之间有严格线性关系（$Y=a+bX$）时成立。 注： 协方差的结果受随机变量量纲影响。 2、相关系数（Correlation coefficient） 定义： 称 $Cov(X,Y)/(\\sigma_1\\sigma_2)$ 为 $X,Y$ 的相关系数，并记为 $Corr(X,Y)$. 性质： 若 $X,Y$ 独立，则 $Corr(X,Y)=0$. $-1\\leq Corr(X,Y)\\leq 1$，或 $|Corr(X,Y)\\leq 1|$，等号当且仅当 $X$ 和 $Y$ 有严格线性关系时达到。当 $Corr(X,Y)=0$ 时，推出 $X,Y$ 不线性相关。 注： 相关系数常称为“线性相关系数”，实际上相关系数并不是刻画了 $X,Y$ 之间 消除量纲后 “一般”关系的程度，而只是“线性关系的程度”。即使 $X$ 与 $Y$ 有某种严格的函数关系但非线性关系，$|Corr(X,Y)|$ 不仅不必为 1，还可以为 0. 大数定理和中心极限定理 1、大数定理 “大数”的意思，就是指涉及大量数目的观察值 $X_i$，它表明这种定理中指出的现象只有在大量次数的试验和观察之下才能成立。 定义： 设 $X1,X_2,...,X_n,...$ 是独立同分布的随机变量，记它们的公共均值为 $a$.又设它们的方差存在并记为 $\\sigma^2$.则对任意给定的 $\\varepsilon >0$，有 $lim{n\\rightarrow\\infty}P(|\\bar{X}_n-a|\\geq \\varepsilon )=0$.（该式表明，当 $n$ 很大时，$\\bar{X}_n$ 接近 $a$） 2、中心极限定理 即和的分布收敛于正态分布。 定义： 设 $X1,X_2,...,X_n$ 为独立同分布的随机变量，$E(X_i)=a,Var(X_i)=\\sigma^2(0{n\\rightarrow\\infty}P(\\frac{1}{\\sqrt{n}\\sigma}(X_1+...+X_n-na)\\leq x)=\\Phi(x)$.（$\\Phi(x)$ 为标准正态分布 $N(0,1)$ 的分布函数） 特例： 设 $X1,X_2,...,X_n$ 独立同分布，$X_i$ 分布是 $P(X_i=1)=p$，$P(X_i=0)=1-p\\ (0{n\\rightarrow \\infty}P(\\frac{1}{\\sqrt{np(1-p)}}(X_1+...+X_n-np)\\leq x)=\\Phi(x)$. 注： 如果 $t_1,t_2$ 是两个正整数，$t_1 > P(t_1\\leq X_1+...+X_n\\leq t_2)\\approx \\Phi(y_2)-\\Phi(y_1), > 其中 > y_i=(t_i-np)/sqrt{np(1-p)}\\quad (i=1,2). > 若把 $y_1,y_2$ 修正为 > y_1=(t_1-\\frac{1}{2}-np)/\\sqrt{np(1-p)},\\\\ > y_2=(t_2-\\frac{1}{2}-np)/\\sqrt{np(1-p)} > 在应用上式，则一般可提高精度。 统计量及其分布 该部分后续需拓展 总体与样本 1、总体   在一个统计问题里，研究对象的全体叫做总体，构成总体的每个成员称为个体。根据个体的数量指标数量，定义总体的维度，如每个个体只有一个数量指标，总体就是一维的，同理，个体有两个数量指标，总体就是二维的。总体就是一个分布，数量指标就是服从这个分布的随机变量。   总体根据个体数分为 有限总体 和无限总体，当有限总体的个体数充分大时，其可以看为无限总体。 2、样本 定义：   从总体中随机抽取的部分个体组成的集合称为样本，样本个数称为样本容量。 性质： 二重性： 抽取前随机，是随机变量；抽取后确定，是一组数值。 随机性： 每个个体都有同等的机会被选入样本。 独立性： 每个样本的取值不影响其他样本取值，即分部独立。 满足后面两个性质称为 简单随机样本，则 F(x_1,x_2,...,x_n)=\\prod^n_{i=1}F(x_i),\\\\ f(x_1,x_2,...,x_n)=\\prod^n_{i=1}f(x_i),\\\\ p(x_1,x_2,...,x_n)=\\prod^n_{i=1}p(x_i) 3、分组样本   只知样本观测值所在区间，而不知具体值的样本称为分组样本。缺点： 与完全样本相比损失部分信息。优点： 在样本量较大时，用分组样本既简明扼要，又能帮助人们更好地认识总体。 样本数据的整理与显示 1、经验分布函数   若将样本观测值 $x1,x_2,...,x_n$ 由小到大进行排列，得到有序样本 $x{(1)}\\leq x{(2)}\\leq...\\leq x{(n)}$，用有序样本定义如下函数 F_n(x)=\\left\\{\\begin{matrix} 0 & 当x 则称为 $F_n(x)$ 为该样本的经验分布函数。 2、格里纹科定理   设 $x_1,x_2,...,x_n$ 是取自总体分布函数为 $F(x)$ 的样本，$F_n(x)$ 是该样本的经验分布函数，则当 $n\\rightarrow+\\infty$ 时，有 P(sup_{-\\infty 表明当 n 相当大时，经验分布函数 $F_n(x)$ 是总体分布函数 $F(x)$ 的一个良好的近似。它是经典统计学的一块基石。 3、频数频率分布表   有样本 $x_1,x_2,...,x_n$ 制作频数频率分布表的操作步骤如下： 确定组数 k； 确定每组组距，通常取每组组距相等为 d（方便起见，可选为整数）； 确定组限（下限 $a_0$ 略小于最小观测值，上限 $a_k$ 略大于最大观测值）； 统计样本数据落入每个区间的频数，并计算频率。 该表能够简明扼要地把样本特点表示出来。不足之处是该表依赖于分组，不同的分组方式有不同的频数频率分布表。 4、直方图 利用频数频率分布表上的区间（横坐标）和频数（纵坐标）可作为频数直方图； 若把纵坐标改为频率就得频率直方图； 若把纵坐标改为频率/组距，就得到单位频率直方图。这时长条矩形的面积之和为1. 5、茎叶图   把样本中的每个数据分为茎与叶，把茎放于一侧，叶放于另一侧，就得到一张该样本的茎叶图。比较两个样本时，可画出背靠背的茎叶图。茎叶图保留数据中全部信息，当样本量较大，数据很分散，横跨二、三个数量级时，茎叶图并不适用。 统计量及其分布 1、统计量   不含未知参数的样本函数称为统计量。统计量的分布称为抽样分布。 2、样本均值 定义：   样本 $x1,x_2,...,x_n$ 的算数平均值称为样本均值，记为 $\\bar{x}$.分组样本均值$\\bar{x}=\\frac{1}{n}\\sum{i=1}^{k}x_if_i$，其中 n 为样本量，k 为组数，$x_i$与$f_i$为第i组的组中值和频率，分组样本均值是完全样本均值的一种较好的近似。   样本均值是样本的位置特征，样本中大多数值位于 $\\bar{x}$ 左右。平均可消除一些随机干扰，等价交换也是在平均数中实现的。 性质： $\\sum_{i=1}^n (x_i-\\bar{x})=0$，样本数据 $x_i$ 对样本均值 $\\bar{x}$ 的偏差之和为零； 样本数据 $x_i$ 与样本均值 $\\bar{x}$ 的偏差平方和最小，即对任意的实数 c 有 $\\sum{i=1}^n(x_i-\\bar{x})^2\\leq \\sum{i=1}^n(x_i-c)^2$; 若总体分布为 $N(\\mu,\\sigma^2)$，则 $\\bar{x}$ 的精确分布为 $N(\\mu,\\sigma^2/n)$； 若总体分布未知，但其期望 $\\mu$ 与方差 $\\sigma^2$ 存在，则当 n 较大时，$\\bar{x}$ 的渐进分布为 $N(\\mu,\\sigma^2/n)$，这里渐进分布是指 n 较大时的近似分布。 3、样本方差与样本标准差   样本方差有两种，$s*^2=\\frac{1}{n}\\sum{i=1}^n(xi-\\bar{x})^2$ 与 $s^2=\\frac{1}{n-1}\\sum{i=1}^n(xi-\\bar{x})^2$，后者为无偏方差，也是最常用的。（这是因为当 $\\sigma^2$ 为总体方差时，总有 $E(s^2)=\\frac{n-1}{n}\\sigma^2$,$E(s^2)=\\sigma^2$，表明 $s_^2$ 有系统偏小的误差，$s^2$ 无此系统偏差。）称 $\\sqrt{s^2}$ 为样本标准差。   样本方差是样本的散布特征，$s^2$ 越大样本越分散，$s^2$ 越小分布越集中，样本标准差比样本方差使用更频繁，因为前者和样本均值有着相同的单位。   $s^2$ 的计算有如下 三个公式 可供选用： s^2=\\frac{1}{n-1}\\sum(x_i-\\bar{x})^2=\\frac{1}{n-1}[\\sum x_i^2-\\frac{(\\sum x_i)^2}{n}]=\\frac{1}{n-1}(\\sum x_i^2-n\\bar{x}^2) 在分组样本场合，样本方差的近似计算公式为 s^2=\\frac{1}{n-1}\\sum_{i=1}^kf_i(x_i-\\bar{x})^2=\\frac{1}{n-1}(\\sum_{i=1}^k f_ix_i^2-n\\bar{x}^2) 其中 k 为组数，$x_i,f_i$ 分别为第 i 个区间的组中值与频数，$\\bar{x}$ 为分组样本的均值。 4、样本矩及其函数 样本的 k 阶原点矩 $ak=\\frac{1}{n}\\sum{i=1}^{n}x_i^k$，样本均值 $\\bar{x}$ 为样本的一阶原点矩； 样本的 k 阶中心距 $bk=\\frac{1}{n}\\sum{i=1}^n(xi-\\bar{x})^k$，样本方差 $s^2$ 和 $s*^2$ 都为样本的二阶中心矩； 样本变异系数 $C_r=s/\\bar{x}$； 样本的偏度 $\\hat{\\beta_s}=b_3/b_2^{3/2}$，反映样本数据与对称性偏离程度和偏离方向； 样本的峰度 $\\hat{\\beta_k}=\\frac{b_4}{b_2^2}-3$，反映总体分布密度曲线在其峰值附近的陡峭程度和尾部粗细. 5、次序统计量及其分布   设 $x1,...,x_n$ 是取自某总体的一个样本，$x{(i)}$ 称为该样本的第 i 个次序统计量（升序排序后，第i个样本）。 $x_{(1)}=min{x_1,...,x_n}$ 称为该样本的 最小次序统计量； $x_{(n)}=max{x_1,...,x_n}$ 称为该样本的 最大次序统计量； $(x{(1)},x{(2)},...,x_{(n)}}$ 称为该样本的次序统计量，即 不独立也不同分布； $R=x{(n)}-x{(1)}$ 称为样本极差。 设总体 $X$ 的密度函数为 $f(x)$，分布函数为 $F(x)$ ，$x_1,...,x_n$ 为样本，则有 样本第 k 个次序统计量 $x_{(k)}$ 的密度函数为 f_k(x)=\\frac{n!}{(k-1)!(n-k)!}(F(x))^{k-1}(1-F(x))^{n-k}f(x); 样本第 i 个与第 j 个次序统计量的联合密度函数为 f_{ij}(y,z)=\\frac{n!}{(i-1)!(j-i-1)!(n-j)!}(F(y))^{i-1}(F(z)-F(y))^{j-i-1}(1-F(z))^{n-j}f(xy)f(z),\\quad y\\leq z, 1\\leq i 6、样本中位数与样本分位数 设 $x1,...,x_n$ 是取自某总体的样本，$x{(1)}\\leq x{(2)}\\leq ...\\leq x{(n)}$ 为该样本的次序统计量，则样本中位数 $m_{0.5}$ 定义为 m_{0.5}=\\left\\{\\begin{matrix} x_{(\\frac{n+1}{2})} & n 为奇数\\\\ \\frac{1}{2}(x_{(\\frac{n}{2})} + x_{(\\frac{n}{2}+1)}) & n 为偶数 \\end{matrix}\\right. 样本的 p 分位数 $m_p$ 定义为 m_{p}=\\left\\{\\begin{matrix} x_{[np+1]} & np 不是整数\\\\ \\frac{1}{2}(x_{(np)} + x_{(np+1)}) & np 是整数 \\end{matrix}\\right. 其中 $[x]$ 表示向下取整。中位数对样本的极端值有抗干扰性，或称有稳健性。 样本分位数的渐近分布： 设总体的密度函数为 $f(x)$，$x_p$ 为总体的 p 分位数。若 $p(x)$ 在$x_p$ 处连续且 $p(x_p)>0$，则当 n 充分大时，有 m_p\\sim N(x_p,\\frac{p(1-p)}{n\\cdot p^2(x_p)}),\\\\ m_{0.5}\\sim N(x_{0.5},\\frac{1}{4n\\cdot p^2(x_{0.5})}) 7、五数概括与箱线图   五数指用样本的五个次序统计量，即最小观测值，最大观测值，中位数，第一4分位数和第三4分位数。其图形为箱线图，可描述样本分布形状。 参数估计   统计学与概率论的区别就是归纳和演绎，前者通过样本推测总体的分布，而后者已知总体分布去研究样本。因此参数估计则是归纳的过程，参数估计有两种形式：点估计和区间估计（点估计和区间估计都是对于未知参数的估计，而点估计给出的是一个参数可能的值，区间估计给出的是参数可能在的范围）。 点估计 点估计的概念 点估计（Point estimation）： 设 $x_1, ..., x_n$ 是来自总体的一个样本，用于估计未知参数 $\\theta$ 的统计量 $\\hat{\\theta}=\\hat{\\theta}(x_1,...,x_n)$ 称为 $\\theta$ 的估计量，或称为 $\\theta$ 的点估计。 点估计的方法 1、矩估计 定义： 设总体概率函数已知，为 $p(x;\\theta1,...,\\theta_k)$，$(\\theta_1,...,\\theta_k)\\in\\Theta$ 是未知参数或参数向量，$x_1,...,x_n$ 是样本，假定总体的 $k$ 阶原点矩 $\\mu_k$ 存在，则对所有的 $j$，$o \\hat{\\theta_j}=\\theta_j(a_1,...,a_k),\\quad j=1,...,k 其中 $a_1,...,a_k$ 是前 $k$ 阶样本原点矩 $a_j=\\frac{1}{n}\\sum{i=1}^{n}x_i^j$. 矩估计基于大数定律（格里纹科定理），实质是用经验分布函数去替换总体分布，矩估计可以概括为： 用样本矩代替总体矩（可以是原点矩也可以是中心矩）； 用样本矩的函数去替换相应的总体矩的函数。 注： 矩估计可能是不唯一的，尽量使用低阶矩给出未知参数的估计 。 2、最大似然估计 定义： 设总体的概率函数为 $p(x;\\theta),\\ \\theta\\in\\Theta$，其中 $\\theta$ 是一个未知参数或几个未知参数组成的参数向量，$\\Theta$ 是参数空间，$x_1,...,x_n$ 是来自该总体的样本，将样本的联合概率函数看成 $\\theta$ 的函数，用 $L(\\theta;x_1,...,x_n)$ 表示，简记为 $L(\\theta)$， L(\\theta)=L(\\theta;x_1,...,x_n)=p(x_1;\\theta)p(x_2;\\theta)...p(x_n;\\theta) $L(\\theta)$ 称为样本的 似然函数。若统计量$\\hat{\\theta}=\\hat{\\theta}(x_1,...,x_n)$ 满足 L(\\hat{\\theta})=\\max_{\\theta\\in\\Theta}L(\\theta) 则称 $\\hat{\\theta}$ 是 $\\theta$ 的 最大似然估计，简称 MLE（maximum likelihood estimate）. 注： 最大似然估计基于样本观测数据，根据概率论思想进行参数估计，首先抽取一定样本，默认这些样本的出现概率是符合原始分布的，即恰好抽到这些样本是因为这些样本出现的概率极大，然后根据概率密度计算联合概率，形成似然函数，似然函数极值位置即为参数的估计值。最大似然估计的前提是已知数据的分布。 最大似然估计步骤： 写出似然函数； 对似然函数取对数，并整理； 求参数向量的偏导，令其为0，得到似然方程； 求解似然方程，其解为参数值。 3、最小均方误差估计 在样本量一定时，评价一个点估计好坏的度量指标可使用估计值 $\\hat{\\theta}$ 与参数真值 $\\theta$ 的距离函数，最常用的是距离平方，由于 $\\hat{\\theta}$ 具有随机性，对该函数求期望即得 均方误差： \\begin{align} MSE(\\hat{\\theta})&=E(\\hat{\\theta}-\\theta)^2\\\\ &=E[(\\hat{\\theta}-E\\hat{\\theta})+(E\\hat{\\theta}-\\theta)]^2\\\\ &=E(\\hat{\\theta}-E\\hat{\\theta})^2+(E\\hat{\\theta}-\\theta)^2+\\underbrace{2E[(\\hat{\\theta}-E\\hat{\\theta})(E\\hat{\\theta}-\\theta)]}_{E(\\hat{\\theta}-E\\hat{\\theta})=0}\\\\ &=\\underbrace{Var(\\hat{\\theta})}_{点估计的方差}+\\underbrace{(E\\hat{\\theta}-\\theta)^2}_{偏差的平方} \\end{align} 其中，如果 $\\hat{\\theta}$ 是 $\\theta$ 的无偏估计，则 $MSE(\\hat{\\theta})=Var(\\hat{\\theta})$，此时用均方误差评价点估计与用方差是完全一样的。如果如果 $\\hat{\\theta}$ 不是 $\\theta$ 的无偏估计，就要看其均方误差 $MSE(\\hat{\\theta})$，即不仅要看其方差大小，还要看其偏差大小。 定义： 设有样本 $x1,...,x_n$，对待估参数 $\\theta$，设有一个估计类，如果对该估计类中另外任意一个 $\\theta$ 的估计 $\\widetilde{\\theta}$，在参数空间 $\\Theta$ 上都有 $MSE\\theta(\\hat{\\theta})\\leq MSE_\\theta(\\widetilde{\\theta})$，称 $\\hat{\\theta}(x_1,...,x_n)$ 是该估计类中 $\\theta$ 的一致最小均方误差估计。 4、最小方差无偏估计 定义： 设 $\\hat{\\theta}$ 是 $\\theta$ 的一个无偏估计，如果对另外任意一个 $\\theta$ 的无偏估计 $\\widetilde{\\theta}$，在参数空间 $\\Theta={\\theta}$ 上都有 $Var{\\theta}(\\hat{\\theta})\\leq Var{\\theta}(\\widetilde{\\theta})$，则称 $\\hat{\\theta}$ 是 $\\theta$ 的一致最小方差无偏估计，简记为 UMVUE。 判断准则： 设 $\\hat{\\theta}=\\hat{\\theta}(x_1,...,x_n)$ 是 $\\theta$ 的一个无偏估计，$Var(\\hat{\\theta}) Cov_\\theta(\\hat{\\theta},\\varphi)=0,\\quad\\forall\\theta\\in\\Theta, 则 $\\hat{\\theta}$ 是 $\\theta$ 的 UMVUE. 5、贝叶斯估计 区别于频率学派，在统计推断中贝叶斯用到了三种信息：总体信息、样本信息和先验信息（频率学派只用了前两种），其中： 总体信息：总体信息即总体分布或总体所属分布族提供的信息，如，若已知总体是正态分布，则可以知道很多信息； 样本信息：样本信息即抽取样本所得观测值提供的信息，如，在有了样本观测值后，可以根据它知道总体的一些特征数； 先验信息：若把抽取样本看作做一次试验，则样本信息就是试验中得到的信息，如，在一次抽样后，这第一次的抽样就是先验信息。先验信息来源于经验和历史资料。 回顾贝叶斯公式：设 ${B_1, B_2, ...B_n}$是样本空间的一个分割，$A$ 为 $\\Omega$ 中的一个事件，$P(B_i)>0$，$i=1,2,...,n$，$P(A)>0$，则 P(B_i|A)=\\frac{P(A|B_i)P(B_i)}{\\sum_{j=1}^{n}P(A|B_j)P(B_j)} 贝叶斯密度函数形式： 在参数 $\\theta$ 分布已知（已假设）的情况下，$p(x|\\theta)$ 表示随机变量 $\\theta$ 取某个给定值时总体的 条件概率函数，（参考 $P(A|B)$）； 任一未知量 $\\theta$ 都可以看作随机变量，可用一个概率分布去描述，这个分布称为 先验分布，该先验分布 $\\pi(\\theta)$，（参考 $P(B)$）； 贝叶斯的观点，样本 $X=(x_1,...,x_n)$ 的产生需分两步： 从先验分布 $\\pi(\\theta)$ 产生一个样本 $\\theta_0$； 从 $p(X|\\theta_0)$ 中产生一组样本。 此时，样本 $X=(x1,...,x_n)$ 的 联合条件概率函数（参考 $\\sum{j=1}^{n}P(A|B_j)$）为 p(X|\\theta_0)=p(x_1,...,x_n|\\theta_0)=\\prod^{n}_{i=1}p(x_i|\\theta_0) 因为 $\\theta0$ 未知，是从先验分布 $\\pi(\\theta)$ 中产生的，所以需要考虑它的发生概率，样本 $X$ 和参数 $\\theta$ 的 联合分布（参考 $\\sum{j=1}^{n}P(A|B_j)P(B_j)$）为 h(X,\\theta)=p(X|\\theta)\\pi(\\theta) 因为目的是对 $\\theta$ 进行推断，所以在有样本观测值 $X=(x_1,...,x_n)$ 之后，可依据 $h(X,\\theta)$ 对 $\\theta$ 作出推断，按照乘法公式（参考1.5.2节），$h(X,\\theta)$ 可分解为 h(X,\\theta)=\\pi(\\theta|X)m(X) 其中，$m(X)$ 是 $X$ 的边际概率函数，类比 $\\pi(\\theta)$， m(X)=\\int_\\Theta h(X,\\theta)d\\theta=\\int_\\Theta p(X|\\theta)\\pi(\\theta)d\\theta 所以可通过条件概率 $\\pi(\\theta|X)$ 推断 $\\theta$ 的分布 \\pi(\\theta|X)=\\frac{h(X,\\theta)}{m(X)}=\\frac{p(X|\\theta)\\pi(\\theta)}{\\int_{\\Theta}p(X|\\theta)\\pi(\\theta)d\\theta} 该分布称为 $\\theta$ 的 后验分布。它其实是利用总体和样本对先验分布 $\\pi(\\theta)$ 调整的结果，比 $\\pi(\\theta)$ 更接近 $\\theta$ 的实际情况（机器学习里的贝叶斯模型就是基于这样的原理）。 Flag： 感觉贝叶斯定理很有意思，今后也会学习相关的贝叶斯分析数据，敬请期待～ 点估计的优良性准则 1、无偏性： 设 $\\hat{\\theta}=\\hat{\\theta}(x1,...,x_n)$ 是 $\\theta$ 的一个估计，$\\theta$ 的参数空间为 $\\Theta$，若对任意的 $\\theta \\in \\Theta$，有 E_{\\theta}(\\hat{\\theta})=\\theta 则称 $\\hat{\\theta}$ 是 $\\theta$ 的 无偏估计，否则称为 有偏估计。无偏性的要求也可以改写为 $E{\\theta}(\\hat{\\theta-\\theta})=0$，无偏性表示表示估计参数与真实参数没有系统偏差。 一个重要的结论： 样本均值 $\\bar{x}=\\frac{1}{n}\\sum{i=1}^nx_i$ 是总体均值 $\\mu$ 的无偏估计。样本方差 $s_n^2=\\frac{1}{n}\\sum{i=1}^n(xi-\\bar{x})^2$ 不是总体方差 $\\sigma^2$ 的无偏估计（而是渐进无偏估计），因此需要对样本方差进行修正，$s^2=\\frac{1}{n-1}\\sum{i=1}^n(x_i-\\bar{x})^2$. 样本均值的无偏性推导 > \\begin{align} > E(\\bar{x})=&E(\\frac{1}{n}\\sum_{i=1}^nx_i)\\\\ > =&\\frac{1}{n}\\sum_{i=1}^nE(x_i),\\ x_i为iid\\\\ > =&\\frac{1}{n}\\sum_{i=1}^n\\mu\\\\ > =&\\mu > \\end{align} > 样本方差的有偏性推导 > \\begin{align} > E(s_n^2)=&E[\\frac{1}{n}\\sum_{i=1}^n(x_i-\\bar{x})^2]\\\\ > =&E[\\frac{1}{n}\\sum_{i=1}^n((x_i-\\mu)-\\frac{1}{n}(\\bar{x}-\\mu))^2]\\\\ > =&E[\\frac{1}{n}\\sum_{i=1}^n((x_i-\\mu)^2-\\frac{2}{n}(x_i-\\mu)(\\bar{x}-\\mu)+\\frac{1}{n}(\\bar{x}-\\mu)^2)]\\\\ > =&E[\\frac{1}{n}\\sum_{i=1}^n(x_i-\\mu)^2-\\frac{2}{n}\\sum_{i=1}^n(x_i-\\mu)(\\bar{x}-\\mu)+(\\bar{x}-\\mu)^2],\\ 其中,\\bar{X}-\\mu=\\frac{1}{n}\\sum_{i=1}^n(x_i-\\mu)\\\\ > =&E[\\frac{1}{n}\\sum_{i=1}^n(x_i-\\mu)^2-2(\\bar{x}-\\mu)^2+(\\bar{x}-\\mu)^2]\\\\ > =&E[\\frac{1}{n}\\sum_{i=1}^n(x_i-\\mu)^2-(\\bar{x}-\\mu)^2]\\\\ > =&E[\\frac{1}{n}\\sum_{i=1}^n(x_i-\\mu)^2]-E[(\\bar{x}-\\mu)^2]\\\\ > =&\\sigma^2-E[(\\bar{x}-\\mu)^2]\\ ...(1)\\\\ > =&\\sigma^2-\\frac{\\sigma^2}{n}\\\\ > =&\\frac{n-1}{n}\\sigma^2,\\quad 当n\\rightarrow \\infty时, E(s_n^2)\\rightarrow \\sigma^2\\\\ > \\\\ > E[(\\bar{x}-\\mu)^2]=&E(\\bar{x}^2)-2\\mu E(\\bar{x})+\\mu^2\\\\ > =&E(\\bar{x}^2)-\\mu^2\\\\ > =&Var(\\bar{x})+E^2(\\bar{x})-\\mu^2\\\\ > =&Var(x)\\\\ > =&\\frac{\\sigma^2}{n}\\ ...代入(1)式 > \\end{align} > 2、有效性 无偏估计往往有很多种，以总体均值为例，$x_1,...,x_n$ 是取自某总体的样本，样本均值 $\\mu$ 和样本 $x_i$ 都是总体均值的无偏估计，对于两个估计参数的选取需要基于一个度量无偏估计优劣的准则。有效性作为这样的准则，反映了 参数估计值和参数真值的波动，波动大小可用方差来衡量，波动越小表示参数的估计越有效。 设$\\hat{\\theta_1}$，$\\hat{\\theta_2}$是$\\theta$的两个无偏估计，如果对任意的$\\theta\\in\\Theta$有 Var(\\hat{\\theta}_1)\\leq Var(\\hat{\\theta}_2) 且至少有一个 $\\theta\\in\\Theta$ 使得上述不等号严格成立，则称 $\\hat{\\theta}_1$ 比 $\\hat{\\theta}_2$ 有效。 3、相合性 根据格里纹科定理，随着样本量不断增大，经验分布函数逼近真实分布函数，即设 $\\theta\\in\\Theta$ 为未知参数，$\\hat{\\theta}_n=\\hat{\\theta}_n(x_1,...,x_n)$ 是 $\\theta$ 的一个估计量，$n$ 是样本容量，若对任何一个 $\\epsilon>0$，有 \\lim_{n\\rightarrow\\infty}P(|\\hat{\\theta}_n-\\theta|\\geq\\epsilon)=0 则称 $\\hat{\\theta}_n$ 为参数 $\\theta$ 的相合估计。 定理1： 设 $\\hat{\\theta}_n=\\hat{\\theta}_n(x_1,...,x_n)$ 是 $\\theta$ 的一个估计量，若 \\lim_{n\\rightarrow\\infty}E(\\hat{\\theta}_n)=\\theta,\\quad\\lim_{n\\rightarrow\\infty}Var(\\hat{\\theta}_n)=0 则 $\\hat{\\theta}_n$ 是 $\\theta$ 的相合估计。 定理2： 若 $\\hat{\\theta}{n1},...,\\hat{\\theta}{nk}$ 分别是 $\\theta1,...,\\theta_k$ 的相合估计，$\\eta=g(\\theta_1,...,\\theta_k)$ 是 $\\theta_1,...,\\theta_k$ 的连续函数，则 $\\hat{\\eta}_n=g(\\hat{\\theta}{n1},...,\\hat{\\theta}_{nk})$ 是 $\\eta$ 的相合估计。 矩估计一般都具有相合性： 样本均值是总体均值的相合估计； 样本标准差是总体标准差的相合估计； 样本变异系数 $s/\\bar{x}$ 是总体变异系数的相合估计。 4、渐进正态性（MLE） 在很一般条件下，总体分布 $p(x;\\theta)$ 中的 $\\theta$ 的 MLE $\\hat{\\theta}n$ 具有相合性和渐进正态性，即 $\\hat{\\theta}_n\\sim AN(\\theta,\\frac{1}{nI(\\theta)})$，其中 $n$ 为样本容量，$I(\\theta)=\\int{-\\infty}^{\\infty}(\\frac{\\part{lnp}}{\\part\\theta})^2p(x;\\theta)dx$ 为费希尔信息量。 5、充分性（UMVUE） 任一参数 $\\theta$ 的 UMVUE 不一定存在，若存在，则它一定是充分统计量的函数； 若 $\\theta$ 的某个无偏估计 $\\hat{\\theta}$ 不是充分统计量 $T=T(x_1,...,x_n)$ 的函数，则通过条件期望可以获得一个新的无偏估计 $\\widetilde{\\theta}=E(\\hat{\\theta|T})$，且方差比原估计的方差要小； 考虑 $\\theta$ 的估计时，只需要在其充分统计量的函数中寻找即可，该说法对所有统计推断都是正确的，这便是充分性原则。 区间估计 区间估计的概念 双侧区间 设 $\\theta$ 是总体的一个参数，其参数空间为 $\\Theta$，$x_1,...,x_n$ 是来自该总体的样本 对给定的一个 $\\alpha\\quad(0 若对任意的 $\\theta\\in\\Theta$，有： P_\\theta(\\hat{\\theta}_L\\leq\\theta\\leq\\hat{\\theta}_U)\\geq(=)1-\\alpha 其中，总体为连续分布时取等号，表示用足了置信水平 称随机区间 $[\\hat{\\theta}_L,\\hat{\\theta}_U]$ 为 $\\theta$ 的 置信水平为$1-\\alpha$的置信区间 或简称 $[\\hat{\\theta}_L,\\hat{\\theta}_U]$ 是 $\\theta$ 的 $1-\\alpha$ 置信区间 $\\hat{\\theta}_L$ 和 $\\hat{\\theta}_U$ 分别称为 $\\theta$ 的 置信下限 和 置信上限 置信水平 $1-\\alpha$ 的频率解释：在大量的区间估计观测值中，至少有 $100(1-\\alpha)\\%$ 包含 $\\theta$ 如下图所示，其置信度为 0.95 单侧区间 设 $\\hat{\\theta}_L=\\hat{\\theta}_L(x_1,...,x_n)$ 是统计量 对给定的 $\\alpha\\in(0,1)$ 和任意的 $\\theta\\in\\Theta$，有： P_\\theta(\\hat{\\theta}_L\\leq\\theta)\\geq1-\\alpha,\\quad\\forall\\theta\\in\\Theta 则称 $\\hat{\\theta}_L$ 为 $\\theta$ 的置信水平为 $1-\\alpha$ 的 置信下限 同理，设 $\\hat{\\theta}_U=\\hat{\\theta}_U(x_1,...,x_n)$ 是统计量 对给定的 $\\alpha\\in(0,1)$ 和任意的 $\\theta\\in\\Theta$，有 P_\\theta(\\hat{\\theta}_L\\geq\\theta)\\geq1-\\alpha,\\quad\\forall\\theta\\in\\Theta 则称 $\\hat{\\theta}_L$ 为 $\\theta$ 的置信水平为 $1-\\alpha$ 的置信上限 区间估计的方法 枢轴量法 Step 1：设法构造一个样本和 $\\theta$ 的函数 $G=G(x_1,...,x_n,\\theta)$ 使得 $G$ 的分布不依赖于未知参数，称具有这种性质的 $G$ 为枢轴量。 Step 2：适当地选择两个常数 c，d，使对给定的 $\\alpha\\quad(0 P(c\\leq G\\leq d)=1-\\alpha （在离散场合，将上式等号改为 $\\geq$） Step 3：假如能将 $c\\leq G\\leq d$ 进行不等式等价变形化为 $\\hat{\\theta}_L\\leq\\theta\\leq\\hat{\\theta}_U$，则有 P_\\theta(\\hat{\\theta}_L\\leq\\theta\\leq\\hat{\\theta}_U)=1-\\alpha 表明 $[\\hat{\\theta}_L,\\hat{\\theta}_U]$ 是 $\\theta$ 的 $1-\\alpha$ 同等置信区间。 注： 满足条件的 c 和 d 有很多，最终选择的目的是希望平均长度 $E_\\theta(\\hat{\\theta}_U)-\\hat{\\theta}_L$ 尽可能短，但在一些场合中很难做到这一点，因此可以选择 c 和 d，使得两个尾部概率各为 $\\alpha/2$，即 >P_\\theta(Gd)=\\alpha/2 > 得到 等尾置信区间。 例：设 $x_1,...,x_n$ 是来自均匀总体 $U(0,\\theta)$ 的一个样本，试对设定的 $\\alpha\\ (0 解：三步法： 已知 $\\theta$ 的最大似然估计为样本的最大次序统计量 $x{(n)}$，而 $x{(n)}/\\theta$ 的密度函数为 > p(y;\\theta)=ny^{n-1},\\quad 0 它与参数 $\\theta$ 无关，故可取 $x_{(n)}/\\theta$ 作为枢轴量 $G$。 由于 $x{(n)}/\\theta$ 的分布函数为 $F(y)=y^n$，$0{(n)}/\\theta\\leq d=d^n-c^n)$，因此可以选择适当的 c和 d 满足 > d^n-c^n=1-\\alpha > 在 $0\\leq c\\theta(\\hat{\\theta}_U)-\\hat{\\theta}_L$ 取最小值，所以 $[x{(n)},x_{(n)}/\\sqrt[n]{\\alpha}]$ 是 $1-\\alpha$ 置信区间 一些情况下的区间估计 单个正态总体参数的置信区间 $\\sigma$ 已知时 $\\mu$ 的置信区间 $[\\bar{x}-u{1-\\alpha/2}\\sigma/\\sqrt{n},\\quad\\bar{x}+u{1-\\alpha/2}\\sigma/\\sqrt{n}]$ $\\sigma$ 未知时 $\\mu$ 的置信区间 $[\\bar{x}-t{1-\\alpha/2}(n-1)s/\\sqrt{n},\\quad\\bar{x}+t{1-\\alpha/2}(n-1)s/\\sqrt{n}]$ $\\sigma^2$ 的置信区间（$\\mu$ 未知） $[(n-1)s^2/\\chi^2{1-\\alpha/2}(n-1),\\quad(n-1)s^2/\\chi^2{\\alpha/2}(n-1)]$ 大样本置信区间 $[\\bar{x}-u{1-\\alpha/2}\\sqrt{\\frac{\\bar{x}(1-\\bar{x})}{n}},\\quad \\bar{x}+u{1-\\alpha/2}\\sqrt{\\frac{\\bar{x}(1-\\bar{x})}{n}}]$ 两个正态总体下的置信区间 $\\mu_1-\\mu_2$ 的置信区间 $\\sigma^2_1$ 和 $\\sigma^2_2$ 已知时 $[\\bar{x}-\\bar{y}-u{1-\\alpha/2}\\sqrt{\\frac{\\sigma^2_1}{m}+\\frac{\\sigma^2_2}{n}},\\quad \\bar{x}-\\bar{y}+u{1-\\alpha/2}\\sqrt{\\frac{\\sigma^2_1}{m}+\\frac{\\sigma^2_2}{n}}]$ $\\sigma^2_1=\\sigma^2_2=\\sigma^2$ 未知时 $[\\bar{x}-\\bar{y}-\\sqrt{\\frac{m+n}{mn}}swt{1-\\alpha/2}(m+n-2),\\quad \\bar{x}-\\bar{y}+\\sqrt{\\frac{m+n}{mn}}swt{1-\\alpha/2}(m+n-2)]$ $\\sigma^2_2/\\sigma^2_1=c$ 已知时 $[\\bar{x}-\\bar{y}-\\sqrt{\\frac{mc+n}{mn}}swt{1-\\alpha/2}(m+n-2),\\quad \\bar{x}-\\bar{y}+\\sqrt{\\frac{mc+n}{mn}}swt{1-\\alpha/2}(m+n-2)]$ 当 m 和 n 都很大时的近似置信区间 $[\\bar{x}-\\bar{y}-u{1-\\alpha/2}\\sqrt{\\frac{s^2_x}{m}+\\frac{s^2_y}{n}},\\quad \\bar{x}-\\bar{y}+u{1-\\alpha/2}\\sqrt{\\frac{s^2_x}{m}+\\frac{s^2_y}{n}}]$ 一般情况下的近似置信区间 $[\\bar{x}-\\bar{y}-s0t{1-\\alpha/2}(l),\\quad \\bar{x}-\\bar{y}+s0t{1-\\alpha/2}(l)]$ $\\sigma^2_1/\\sigma^2_2$ 的置信区间 $[\\frac{sx^2}{s_y^2}\\cdot\\frac{1}{F{1-\\alpha/2(m-1,n-1)}},\\quad \\frac{sx^2}{s_y^2}\\cdot\\frac{1}{F{\\alpha/2(m-1,n-1)}}]$ 假设检验 假设检验的基本思想和概念 基本思想 以“女士品茶”为例，对于该女士有没有品茶的能力，有两种假设： 该女士没有品茶能力 | 该女士有品茶能力 在统计学上，这两个 非空不相交 参数集合称作 统计假设，简称 假设通过样本对一个假设作出 对与不对 的判断，则称为该假设的一个 检验若检验结果否定了该命题，则称 拒绝 这个假设，反之为 接受（不拒绝） 这个假设 假设可分为两种：1、参数假设检验，即已经知道数据的分布，针对总体的 某个参数 进行假设检验2、非参数假设检验，即数据分布未知，针对该 分布 进行假设检验 假设检验的基本步骤 建立假设—>选择检验统计量，给出拒绝域形式—>选择显著性水平—>给出拒绝域—>做出判断 Step 1：建立假设 主要针对参数假设检验问题 设有来自某分布族 ${F(x,\\theta)|\\theta \\in \\Theta}$ 的样本 $x_1,...,x_n$ 其中 $\\Theta$ 为参数空间，设 $\\Theta_0 \\in \\Theta$，且 $\\Theta_0 \\neq \\phi$ 则命题 $H_0:\\theta \\in \\Theta_0$ 称为 原假设 或 零假设（null hypothesis） 若有另一个 $\\Theta_1$（$\\Theta_1 \\in \\Theta,\\Theta_1\\Theta_0=\\phi$，常见的一种情况是 $\\Theta_1=\\Theta-\\Theta_0$） 则命题 $H_1:\\theta \\in \\Theta_1$ 称为 $H_0$ 的 对立假设 或 备择假设（alternative hypotheis） 当 $H_0$ 为简单假设，即 $\\Theta_0$ 只含一个点时，备择假设有三种可能： $H_1':\\theta \\neq \\theta_0$，$H_1'':\\theta \\theta_0$ Step 2：选择检验统计量，给出拒绝域形式 根据样本计算统计量 $Z$（如样本均值、标准差等，称为 检验统计量），并基于某个法则既可以决定接受 $H_0$ 还是拒绝 $H_0$ 具体地，当统计量在拒绝域 $W$ 中即拒绝 $H_0$，在接受域 $\\overline{W}$ 中即接受 $H_0$ 由此可见，一个拒绝域 $W$ 唯一确定一个检验法则，反之，一个检验法则也唯一确定一个拒绝域 注： 不能用一个样本（例子）证明一个命题（假设成立），但是可以用一个样本（例子）去推翻一个命题 此外，拒绝域与接受域之间有一个模糊域，即统计量恰好符合法则，通常将模糊域归为接受域，因此接受域是复杂的 Step 3：选择显著性水平 假设检验基于 小概率事件，即小概率事件在一次试验中几乎不会发生 因此选择一个很小的概率值 $\\alpha$，令 $p(拒绝H_0|H_0为真)\\leq\\alpha$，表示 $Z\\in W$ 是一个小概率事件，在一次试验中不应该发生 如果通过样本得到的统计量 $z\\in W$，即不该发生的小概率事件竟然发生了，那么应该拒绝 $H_0$ 通常做检验时可能做出错误判断，由此引入了两个错误，分别为 第一类错误 和 第二类错误，如下表所示 | 观测数据情况 | 总体情况 | 总体情况 | | :---: | :---: | :---: | | | $H_0$ 为真 | $H_1$ 为真 | | 接受 $H_0$ | 第一类错误（拒真） | 正确 | | 拒绝 $H_0$ | 正确 | 犯第二类错误（取伪） | 犯第一类错误概率：$\\alpha=P(X\\in W|H_0)$，即 $\\alpha=P(拒绝 H_0|H_0 为真)$ 犯第二类错误概率：$\\beta=P(X\\in \\overline{W}|H_1)$，即 $\\beta=P(接受 H_0|H_0 为假)$ 可以通过势函数证明：在一定样本量下，两类错误概率无法共同减小，但是当样本增加时，可以同时减小。 [!NOTE|style:flat] 势函数定义：设检验问题 $H_0:\\theta\\in\\Theta_0\\quad vs\\quad H_1:\\theta \\in \\Theta_1$ 的拒绝域为 $W$，则样本观测值 $\\mathbf{X}$ 落在拒绝域 $W$ 内的概率称为该检验的 势函数，记为 > g(\\theta)=P_\\theta(\\mathbf{X}\\in W),\\ \\theta\\in\\Theta=\\Theta_0\\cup\\Theta_1\\\\ > g(\\theta)=\\left\\{\\begin{matrix} > \\alpha(\\theta) & \\theta\\in\\Theta_0\\\\ > 1-\\beta(\\theta) &\\theta\\in\\Theta_1 > \\end{matrix}\\right. > 第一类错误概率 $\\alpha$ 即为初始设定的很小的概率，称为 置信水平 称该检验时 显著性水平为 $\\alpha$ 的显著性检验，简称 水平为 $\\alpha$ 的检验 为了尽量减少两类错误，可简单的将其简化为减小第一类错误概率（第二类错误概率难求） 常用的 $\\alpha=0.05$ 有时也选择 0.1 或 0.01 Step 4：给出拒绝域 为了使得第一类错误的概率尽可能小，给定一个较小的 $\\alpha$，并选择一个数 $k$ 设定若 $Z\\geq k$ 拒绝 $H0$，使得 $P(u=|\\frac{z-\\mu}{\\sigma/\\sqrt{n}}|\\geq k)\\leq \\alpha$，所以$k=u{\\alpha/2}$ 注：算拒绝域时，需基于标准正态分布 Step 5：做出判断 通过样本计算统计量，若统计量在拒绝域中，则拒绝原假设，否则接受原假设 检验的 $p$ 值 不同置信水平 $\\alpha$ 的取值，可能会存在不同的结果，因此引入新的指标即利用样本观测值能够作出拒绝原假设的最小显著水平，称为 检验的 $p$ 值 由检验的 $p$ 值与心目中的显著性水平 $\\alpha$ 进行比较，可以容易做出检验结论：若 $\\alpha \\geq p$，则在显著性水平 $\\alpha$ 下拒绝 $H_0$若 $\\alpha [!NOTE|style:flat] 一般以 $p$p$p Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-05 22:33:36 "},"about_Math/高等数学.html":{"url":"about_Math/高等数学.html","title":"高等数学","keywords":"","body":"参考资料：https://www.cnblogs.com/ixtwuko/p/advanced-mathematics.html 基础公式 一元二次方程的解 x_{1,2} = \\cfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} 韦达定理 x_1 + x_2 = -\\cfrac{b}{a}, \\ \\ x_1 x_2 = \\cfrac{c}{a} 快捷公式 (a+b)^3 = a^3 + 3a^2b + 3ab^2 + b^3 (a-b)^3 = a^3 - 3a^2b + 3ab^2 - b^3 a^3 - b^3 = (a - b)(a^2 + ab + b^2) a^3 + b^3 = (a + b)(a^2 - ab + b^2) (a+b)^n = \\displaystyle \\sum_{k=0}^{n} C_n^k a^k b^{n-k} 对数 \\log_a (MN) = \\log_a M + \\log_a N \\log_a \\cfrac{M}{N} = \\log_a M - \\log_a N \\log_a M^n = n \\log_a M 三角函数 \\csc x = \\cfrac{1}{\\sin x}, \\ \\ \\sec x = \\cfrac{1}{\\cos x}, \\ \\ \\cot x = \\cfrac{1}{\\tan x} \\sin^2 x + \\cos^2 x = 1, \\ \\ 1 + \\tan^2 x = \\sec^2 x, \\ \\ 1 + \\cot^2 x = \\csc^2 x \\sin (\\alpha \\pm \\beta) = \\sin \\alpha \\cos \\beta \\pm \\sin \\beta \\cos \\alpha \\cos (\\alpha \\pm \\beta) = \\cos \\alpha \\cos \\beta \\mp \\sin \\alpha \\sin \\beta \\tan (\\alpha \\pm \\beta) = \\cfrac{\\tan \\alpha \\pm \\tan \\beta}{1 \\mp \\tan \\alpha \\tan \\beta} \\sin 2\\alpha = 2\\sin \\alpha \\cos \\alpha, \\ \\ \\cos 2\\alpha = \\cos^2 \\alpha - \\sin^2 \\alpha \\sin^2 \\alpha = \\cfrac{1}{2}(1 - \\cos 2\\alpha), \\ \\ \\cos ^2 \\alpha = \\cfrac{1}{2}(1 + \\cos 2\\alpha) a\\sin \\alpha + b\\cos \\alpha = \\sqrt{a^2 + b^2} \\sin (\\alpha + \\varphi), \\ \\varphi = \\arctan \\cfrac{b}{a} 积化和差： \\sin \\alpha \\sin \\beta = -\\cfrac{1}{2}[\\cos (\\alpha + \\beta) - \\cos (\\alpha -\\beta)] \\sin \\alpha \\cos \\beta = \\cfrac{1}{2}[\\sin (\\alpha + \\beta) + \\sin (\\alpha - \\beta)] \\cos \\alpha \\cos \\beta = \\cfrac{1}{2}[\\cos (\\alpha + \\beta) + \\cos (\\alpha -\\beta)] 和差化积： \\sin \\alpha + \\sin \\beta = 2\\sin \\cfrac{\\alpha + \\beta}{2} \\cos \\cfrac{\\alpha -\\beta}{2} \\cos \\alpha + \\cos \\beta = 2 \\cos \\cfrac{\\alpha + \\beta}{2} \\cos \\cfrac{\\alpha -\\beta}{2} \\sin \\alpha - \\sin \\beta = 2 \\sin \\cfrac{\\alpha -\\beta}{2} \\cos \\cfrac{\\alpha + \\beta}{2} \\cos \\alpha -\\cos \\beta = -2 \\sin \\cfrac{\\alpha + \\beta}{2} \\sin \\cfrac{\\alpha - \\beta}{2} 数列 等差数列 a_n = a_1 + (n-1)d, \\ \\ S_n = \\cfrac{n}{2}(a_1 + a_n) 等比数列 a_n = a_1 q^{n-1}, \\ \\ S_n = \\cfrac{a_1(1-q^n)}{1-q} 1 + 2 + 3 + \\cdots + n = \\cfrac{n(n+1)}{2} 1 + 3 + 5 + \\cdots + (2n-1) = n^2 1^2 + 2^2 + 3^2 + \\cdots + n^2 = \\cfrac{n(n+1)(2n+1)}{6} 1 + 2 + 3 + \\cdots + n = \\cfrac{n(n+1)}{2} 1^3 + 2^3 + 3^3 + \\cdots + n^3 = \\left[ \\cfrac{n(n+1)}{2} \\right]^2 排列组合 约定 0! = 1 A_n^m = \\cfrac{n!}{(n-m)!}, \\ \\ C_n^m = \\cfrac{n!}{m! (n-m)!} C_n^m = C_n^{n-m}, \\ \\ C_{n+1}^m = C_n^m + C_n^{m-1} 曲线和曲面 球表面积 S = 4 \\pi R^2 球的体积 V = \\cfrac{4}{3} \\pi R^3 圆锥体即 V = \\cfrac{1}{3} sh 抛物线 y^2 = 2px 椭圆 \\cfrac{x^2}{a^2} + \\cfrac{y^2}{b^2} = 1，双曲线 \\cfrac{x^2}{a^2} - \\cfrac{y^2}{b^2} = 1 椭球面 \\cfrac{x^2}{a^2} + \\cfrac{y^2}{b^2} + \\cfrac{z^2}{c^2} = 1 单叶双曲面 \\cfrac{x^2}{a^2} + \\cfrac{y^2}{b^2} - \\cfrac{z^2}{c^2} = 1，双叶双曲面 \\cfrac{x^2}{a^2} - \\cfrac{y^2}{b^2} - \\cfrac{z^2}{c^2} = 1 椭圆抛物面 \\cfrac{x^2}{2p} + \\cfrac{y^2}{2q} = z，双曲抛物面/马鞍面 \\cfrac{x^2}{2p} - \\cfrac{y^2}{2q} = z 极坐标 弧长 l = r \\theta 扇形面积 S = \\cfrac{1}{2} r^2 \\theta 极坐标转换为直角坐标 \\begin{cases} x = r(\\theta) \\cos \\theta \\\\ y = r(\\theta) \\sin \\theta \\end{cases} 不等式 2|ab| \\le a^2 + b^2 |a \\pm b| \\le |a| + |b| |a_1 \\pm a_2 \\pm \\cdots \\pm a_n| \\le |a_1| + |a_2| + \\cdots + |a_n| |a - b| \\ge |a| - |b| \\cfrac{a_1 + a_2 + \\cdots + a_n}{n} \\ge \\sqrt[n]{a_1 a_2 \\cdots a_n} \\left| \\cfrac{a_1 + a_2 + \\cdots + a_n}{n} \\right| \\le \\sqrt{\\cfrac{a_1^2 + a_2^2 + \\cdots + a_n^2}{n}} x,y,p,q \\gt 0, \\cfrac{1}{p} + \\cfrac{1}{q} = 1 (a^2 + b^2)(c^2 + d^2) \\ge (ac+bd)^2 常用定理 有界性定理 若 f(x) 在 [a,b] 上连续，则 \\exists K \\gt 0, \\ |f(x)| \\le K. 最值定理 若 f(x) 在 [a,b] 上连续，则 m \\le f(x) \\le M，m,M 为 f(x) 在 [a,b] 上的最小、最大值。 介值定理 若 f(x) 在 [a,b] 上连续，且 m \\le μ \\le M，则 \\exists \\xi \\in [a,b]，使 f(\\xi)=\\mu；若 f(x) 在 [a,b] 上连续，且 f(a) \\ne f(b)，则 f(x) 可以取到 f(a),f(b) 之间的任意函数值。 零点定理 若 f(x) 在 [a,b] 上连续，且 f(a) \\cdot f(b) \\lt 0，则 \\exists \\xi \\in [a,b]，使 f(\\xi)=0. 费马定理 若 f(x) 在 x=x_{0} 处可导，并取到极值，则 f'(x_{0})=0. 罗尔定理 若 f(x) 满足 [a,b] 上连续，(a,b) 上可导，f(a)=f(b)，则 \\exists \\xi \\in (a,b)，使 f'(\\xi)=0. 拉格朗日中值定理 若 f(x) 满足：[a,b] 上连续，(a,b) 上可导，则 \\exists \\xi \\in (a,b)，使 f'(\\xi)=\\cfrac{f(b)−f(a)}{b−a}. 证明如下：令 f'(x)=\\cfrac{f(b)−f(a)}{b−a}，两边同时积分，得 f(x)=\\cfrac{f(b)−f(a)}{b−a} x+C，取 C=0，取 F(x)=f(x)−\\cfrac{f(b)−f(a)}{b−a} x，其中F(a)=\\cfrac{bf(a)−af(b)}{b-a}，F(b)=\\cfrac{bf(a)−af(b)}{b−a}，得 F(a)=F(b)，由罗尔定理，\\exists \\xi \\in (a,b)，F'(\\xi)=0，即 f'(\\xi)=\\cfrac{f(b)−f(a)}{b−a}. 柯西中值定理 若 f(x), g(x) 满足：[a,b] 上连续，(a,b) 上可导，g'(x) \\ne 0 则 \\exists \\xi \\in (a,b)，使 \\cfrac{f(b)−f(a)}{g(b)−g(a)}=f'(\\xi)g'(\\xi). 证明如下：令 \\cfrac{f(b)−f(a)}{g(b)−g(a)}=f'(x)g'(x)，两边同时积分，得 [g(b)−g(a)]f(x)=[f(b)−f(a)]g(x)，取 F(x)=[g(b)−g(a)]f(x)−[f(b)−f(a)]g(x)，F(a)=f(a)g(b)−f(b)g(a)，F(b)=f(a)g(b)−f(b)g(a)，得 F(a)=F(b)，由罗尔定理，\\exists \\xi \\in (a,b)，F'(\\xi)=0，即 \\cfrac{f(b)−f(a)}{g(b)−g(a)}=f'(\\xi)g'(\\xi). 泰勒公式 若 f(x) 在x0 的某个邻域内（或者(a,b)内）有n+1 阶导数，则此邻域内的任意x ，均有f(x) = f(x_0) + f'(x_0)(x - x_0) + \\cfrac{f''(x_0)}{2!}(x - x_0)^2 + \\cdots + \\cfrac{f^{(n)}(x_0)}{n!}(x- x_0)^n + remainder 拉格朗日余项 \\cfrac{f^{(n+1)}(\\xi)}{(n+1)!}(x−x_{0})^{n+1}佩亚诺余项 ο((x−x_{0})^{n}) 积分中值定理 若 f(x) 在 [a,b] 上连续，则 \\exists \\xi \\in [a,b]，使 \\int_{b}^{a} f(x)dx=f(\\xi)(b−a). 证明如下：由题，设 m, M 为 f(x) 在 [a,b] 上的最小值、最大值，m \\le f(x) \\le M，则 \\int_{b}^{a} m dx \\le \\int_{b}^{a} f(x)dx \\le \\int_{b}^{a} M dx，即 m(b−a) \\le \\int_{b}^{a} f(x) dx \\le M(b−a)，记 \\cfrac{\\int_{b}^{a} f(x) dx}{(b−a)}=\\mu, 得 m \\le μ \\le M，由介值定理，\\exists \\xi \\in [a,b], 使 f(\\xi)=\\mu，因此 \\exists \\xi \\in [a,b]，使 f(\\xi)(b−a)=\\int_{b}^{a} f(x) dx. 函数 概念：定义域、值域、映射（函数是 R 下的映射）、邻域、去心邻域、分段函数、隐函数、反函数函数的基本特性：有界性、单调性、周期性、奇偶性基本初等函数：幂函数、指数函数、对数函数、三角函数、反三角函数取整函数 y=[x]狄利克雷函数 D(x) = \\begin{cases} 1&x\\text{ is a rational number}\\\\0&x\\text{ is a irrational number} \\end{cases}​ 有界性f(x) 在 [a,b] 上连续，f(x) 在 [a,b] 上有界f(x) 在 (a,b) 上连续，且 \\displaystyle \\lim_{x \\to a^+} f(x) 和 \\displaystyle \\lim_{x \\to a^-} f(x) 都存在，则 f(x) 在 [a,b] 上有界有界函数之间的和、积均为有界函数 奇偶性质奇函数与奇函数复合为奇函数奇偶为偶偶偶为偶 极限 概念：无穷小、高阶无穷小（更小）、同阶无穷小、等价无穷小、无穷大、单侧极限 数列的极限： \\displaystyle \\lim_{n \\to \\infty} x_n = a\\forall \\varepsilon \\gt 0, \\exists N \\gt 0, \\text{while} \\ n \\gt N, |x_n - a| \\lt \\varepsilon 函数的极限： \\displaystyle \\lim_{x \\to x_0} f(x) = A\\forall \\varepsilon \\gt 0, \\exists \\delta \\gt 0, \\text{while} \\ 0 \\lt |x - x_0| \\lt \\delta, |f(x) - A| \\lt \\varepsilon 性质：极限存在必唯一：\\displaystyle \\lim_{n \\to \\infty} x_n = a \\iff \\lim_{n \\to \\infty} x_{2n} = \\lim_{n \\to \\infty} x_{2n-1} = a\\displaystyle \\lim_{x \\to x_0} f(x) = A \\iff \\lim_{x \\to x_0^+} f(x) = \\lim_{x \\to x_0^-} f(x) = A\\displaystyle \\lim_{x \\to x_0} f(x) = A \\iff f(x) - A = a(x), \\lim_{x \\to x_0} a(x) = 0假设 f(x) 单调减少（增加）且有下界（上界），则 \\displaystyle \\lim_{x \\to +\\infty} f(x) 必存在局部保号性：假设 \\displaystyle \\lim_{x \\to x_0} f(x) = A \\neq 0，则存在 x_0 的一个去心邻域，在此邻域内 f(x) 与 A 同号局部有界性：假设 \\displaystyle \\lim_{x \\to x_0} f(x) = A，则存在 M \\gt 0，当 x \\to x_0 时，|f(x)| = M 连续 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-11-14 22:12:17 "},"about_Math/线性代数.html":{"url":"about_Math/线性代数.html","title":"线性代数","keywords":"","body":" ✨参考资料 https://linalg.apachecn.org/ ✨线代笔记 ⭕ 方程组的几何解释 如何求解线性方程组？假设方程组有 $2$ 个未知数，一共有 $2$ 个方程： \r \\begin{cases}\r 2x& - y& = 0 \\\\\r -x& + 2y& = 3\r \\end{cases}\r ， 写作矩阵形式有 \r \\begin{bmatrix}\r 2&-1\\\\-1&2\r \\end{bmatrix}\r \\begin{bmatrix}\r x\\\\y\r \\end{bmatrix}\r =\r \\begin{bmatrix}\r 0\\\\3\r \\end{bmatrix}\r 通常我们把第一个矩阵称为系数矩阵 $A$，将第二个矩阵称为向量 $x$，将第三个矩阵称为向量 $b$，于是线性方程组可以表示为 $Ax=b$ 分别来看方程组的“行图像”和“列图像”行图像，即直角坐标系中的图像： %matplotlib inline import matplotlib.pyplot as plt import numpy as np import pandas as pd import seaborn as sns x = [-2, 2, -2, 2] y = [-4, 4, 0.5, 2.5] # -2、-4 满足第一行方程 # 2、4 满足第一行方程 # -2、0.5 满足第二行方程 # 2、2.5 满足第二行方程 fig = plt.figure() plt.axhline(y=0, c='black') plt.axvline(x=0, c='black') plt.plot(x[:2], y[:2], x[2:], y[2:]) plt.draw() # plt.close(fig) 上图是我们都很熟悉的直角坐标系中两直线相交的情况接下来我们按列观察方程组 \r x\\begin{bmatrix}\r 2\\\\-1\r \\end{bmatrix}\r +\r y\\begin{bmatrix}\r -1\\\\2\r \\end{bmatrix}\r =\r \\begin{bmatrix}\r 0\\\\3\r \\end{bmatrix}\r 我们把第一个向量称作 $col_1$，第二个向量称作 $col_2$，以表示第一列向量和第二列向量要使得式子成立，需要第一个向量加上两倍的第二个向量，即 \r 1\\begin{bmatrix}\r 2\\\\-1\r \\end{bmatrix}\r +\r 2\\begin{bmatrix}\r -1\\\\2\r \\end{bmatrix}\r =\r \\begin{bmatrix}\r 0\\\\3\r \\end{bmatrix}\r 现在来看列图像，在二维平面上画出上面的列向量 from functools import partial fig = plt.figure() plt.axhline(y=0, c='black') plt.axvline(x=0, c='black') ax = plt.gca() ax.set_xlim(-2.5, 2.5) ax.set_ylim(-3, 4) arrow_vector = partial(plt.arrow, width=0.01, head_width=0.1, head_length=0.2, length_includes_head=True) arrow_vector(0, 0, 2, -1, color='g') arrow_vector(0, 0, -1, 2, color='c') arrow_vector(2, -1, -2, 4, color='b') arrow_vector(0, 0, 0, 3, width=0.05, color='r') plt.draw() # plt.close(fig) 如图，绿向量 $col_1$ 与蓝向量（两倍的蓝绿向量 $col_2$）合成红向量 $b$ 继续观察，发现 $col_1,col_2$ 的某种线性组合得到了向量 $b$，那么 $col_1,col_2$ 的所有线性组合能够得到什么结果？它们将铺满整个平面 下面进入三个未知数的方程组 \r \\begin{cases}\r 2x& -y& & = 0\\\\\r -x& +2y& -z& = -1\\\\\r & -3y& +4z& = 4\r \\end{cases}\r 写作矩阵形式 \r A = \r \\begin{bmatrix}\r 2&-1&0\\\\ -1&2&-1\\\\ 0&-3&4\r \\end{bmatrix},\\ \r b = \r \\begin{bmatrix}\r 0\\\\-1\\\\4\r \\end{bmatrix}\r 在三维直角坐标系中，每一个方程将确定一个平面，而例子中的三个平面会相交于一点，这个点就是方程组的解 同样的，将方程组写成列向量的线性组合，观察列图像 \r x\\begin{bmatrix}\r 2\\\\-1\\\\0\r \\end{bmatrix}\r +\r y\\begin{bmatrix}\r -1\\\\2\\\\-3\r \\end{bmatrix}\r +\r z\\begin{bmatrix}\r 0\\\\-1\\\\4\r \\end{bmatrix}\r =\r \\begin{bmatrix}\r 0\\\\-1\\\\4\r \\end{bmatrix}\r 易知最后一个列向量恰巧等于等式右边的 $b$ 向量，所以我们需要的线性组合为 $x=0,y=0,z=1$假设我们令 $b=\\begin{bmatrix}1\\1\\-3\\end{bmatrix}$，则需要的线性组合为 $x=1,y=1,z=0$ 我们并不能总是这么轻易的求出正确的线性组合，所以需要一种线性方程组的系统性解法——消元法 现在，我们需要考虑，对于任意的 $b$，是否都能求解 $Ax=b$？用列向量线性组合的观点阐述就是，列向量的线性组合能否覆盖整个三维向量空间？对上面这个例子，答案是肯定的，这个例子中的 $A$ 是我们喜欢的矩阵类型，但是对另一些矩阵，答案是否定的。那么 在什么情况下，三个向量的线性组合得不到 $b$ ？——如果 三个向量在同一个平面上，问题就出现了——那么 他们的线性组合也一定都在这个平面上。举个例子，比如 $col_3=col_1+col_2$，那么不管怎么组合，这三个向量的结果都 逃不出这个平面，因此 当 $b$ 在平面内，方程组有解，而当 $b$ 不在平面内，这三个列向量就无法构造出 $b$。在后面的课程中，我们会了解到这种情形称为 奇异、矩阵不可逆 下面我们推广到九维空间，每个方程有九个未知数，共九个方程，此时已经无法从坐标图像中描述问题了，但是我们依然可以从求九维列向量线性组合的角度解决问题仍然是上面的问题，是否总能得到 $b$？当然这仍取决于这九个向量，如果我们取一些并不 相互独立的向量，则答案是否定的，比如取了九列但其实只相当于八列，有一列毫无贡献（这一列是前面列的某种线性组合），则会有一部分 $b$ 无法求得 接下来介绍方程的矩阵形式 $Ax=b$，这是一种乘法运算，举个例子，取 $A=\\begin{bmatrix}2&5\\1&3\\end{bmatrix},\\ x=\\begin{bmatrix}1\\2\\end{bmatrix}$，来看如何计算 矩阵乘以向量 列向量线性组合 的方式，一次计算一列 \r \\begin{bmatrix}2&5\\\\1&3\\end{bmatrix}\\begin{bmatrix}1\\\\2\\end{bmatrix}\r =\r 1\\begin{bmatrix}2\\\\1\\end{bmatrix}\r +\r 2\\begin{bmatrix}5\\\\3\\end{bmatrix}\r =\r \\begin{bmatrix}12\\\\7\\end{bmatrix}\r 将 $Ax$ 看做 $A$ 列向量的线性组合 使用 向量内积 矩阵第一行向量点乘 $x$ 向量 \r \\begin{bmatrix}2&5\\end{bmatrix}\\cdot\\begin{bmatrix}1&2\\end{bmatrix}^T\r =\r 12,\\ \\begin{bmatrix}1&3\\end{bmatrix}\\cdot\\begin{bmatrix}1&2\\end{bmatrix}^T\r =\r 7\r 🔘 标题3 hello world ✨3blue1brown 什么是向量？它有长度和方向，可以理解为有序的数字列表 不同的基向量可以理解为不同的坐标系 共线的基向量张成的空间是直线 什么是基？张成该空间的线性无关的向量集 什么是线性变换？直线经过变换仍为直线，原点不动，网络线保持平行且等距分布 线性代数可以求解特定的线性方程组 矩阵乘法是两个变换相继作用 什么都不做的变换称为恒等变换 无法将一条直线 “解压缩” 为一个平面？因为这个要求一条直线被映射为多个向量，而函数只能将一个输入变换为一个输出 什么是矩阵的秩？经过该矩阵变换后的空间的维度 矩阵A的列空间即基向量 $\\vec{v}$ 讲过矩阵 $A$ 变换后的向量 $A\\vec{v}$ 构成的空间 向量的叉积即两个向量构成的平行四边形的面积，也是 $det([\\vec{v}, \\vec{w}])$ 特征向量 若向量 $\\vec{v}$ 是 $A$ 的特征向量，则 $v$ 会在变换 $A\\vec{v}$ 后停留在它张成的子空间里 \r A\\vec{v} = \\lambda \\vec{v} \\\\\r A\\vec{v}-\\lambda \\vec{v} = \\vec{0} \\\\\r (A-\\lambda)\\vec{v} = \\vec{0} \\\\\r det((A-\\lambda)\\vec{v}) = 0 \\quad 得到 \\lambda 带回上式计算得 \\vec{v}\\\\\r 特征向量方向固定，经过变换 $A$ 后被拉伸为原来的 $\\lambda$ 倍 基向量可以是特征向量，例如：对角矩阵。也可以将特征向量转换为基向量，即寻找特征基 线性的严格定义 \r L(\\vec{v} + \\vec{w}) = L(\\vec{v}) + L(\\vec{w}) \\\\\r L(c\\vec{v}) = cL(\\vec{v})\r 公理不是自然法则而是媒介 普适的代价是抽象 ✨应用 大型稀疏矩阵在生活中的应用非常广泛，例如： 搜索引擎：搜索引擎索引的网页可以看作是一个巨大的稀疏矩阵，其中每一行代表一个网页，每一列代表一个关键词，非零元素表示该网页包含该关键词。 推荐系统：推荐系统利用用户对商品的评分数据构建用户评分矩阵，该矩阵通常是一个大型稀疏矩阵，其中每一行代表一个用户，每一列代表一个商品，非零元素表示该用户对该商品的评分。 图像处理：图像处理中的滤波器通常是一个稀疏矩阵，其中非零元素表示滤波器的权值。在图像压缩中，离散余弦变换（DCT）也会生成一个大型稀疏矩阵。 自然语言处理：在自然语言处理中，通常需要构建文本的共现矩阵，该矩阵也是一个大型稀疏矩阵，其中每一行代表一个单词，每一列代表一个文本，非零元素表示该单词在该文本中出现。 网络分析：社交网络和通信网络都可以表示为一个稀疏矩阵，其中每一行代表一个节点，每一列代表一个节点或边，非零元素表示两个节点之间存在连接。 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-28 23:39:18 "},"about_Math/概率论.html":{"url":"about_Math/概率论.html","title":"概率论","keywords":"","body":"参考链接：https://www.cnblogs.com/Renyi-Fan/p/13938385.html 在线公式编辑网站：https://editor.codecogs.com/ 一、随机事件及其概率 全集 $P(\\Omega) = 1$ 空集 $P(\\phi) = 0$ 加法原理：有几种情况 乘法原理：分为几步 乘法公式：（事件之间不一定独立的时候） \r P(AB) = P(B)P(A|B) = P(A)P(B|A) \\\\\r P(ABC) = P(A)P(A|B)P(C|AB)\r 几何概率模型 与线段、平面、立体有关的模型 一张桌子，一个质子扔到左边部分的的概率是 $1/2$ 频率和概率的关系 频率需要做大量的实验才能逼近概率 只要次数 $n$ 足够大，就可以说频率是概率的近似 条件概率 样本空间发生了变化 $P(A|B)$ 不同于 $P(AB)$，而是 $P(AB)/P(B)$ $P(A|B)$ 表示 $B$ 发生的情况下，$A$ 发生的概率 例子：今天家里买了水果，让你猜猜是什么水果，直接猜测的话概率可能很低，因为有可能苹果、提子、梨、桃等等，不过现在假如是一个特定季节，且告诉你水果的颜色，那么某种水果的概率就会增加。所以给定条件后，会导致事件发生的概率发生变化 联合概率和条件概率 联合概率侧重于同时发生 条件概率侧重于一个先发生，另一个后发生 \r P(AB) = AB/S \\\\\r P(A|B) = AB/B \\\\\r \\text{注意分子相同，但是分母的样本空间是不一样的}\r 全概率公式 $P(B|A{i})$ 即各个 $A{i}$ 中的 $B$ 全部拼起来 白话就是：由因溯果，已知达到某个目的有很多方法，问能到达目的的概率是多少；或者造成某个结果有很多原因，问造成这个结果的概率是多少 贝叶斯公式 \r P(AB) = P(B)P(A|B) = P(A)P(B|A)\r 由来是乘法公式 白话就是：由果溯因，已知结果，问导致这个结果的第 $i$ 个原因的概率是多少 独立、互不相容 独立（可以同时发生）：$P(AB) = P(A)P(B) > 0$ 互不相容（不可能同时发生）：$P(A+B) = P(A) + P(B)$，其中右边的 $-P(AB) = 0$ 省略了 应用：多元线性回归中的概率公式推导，就是用的事件之间的独立性 \r P(A_{1}A_{2}...A_{n})=P(A_{1})P(A_{2})...P(A_{n})\r 伯努利公式 投骰子，有 $5/6$ 的概率投出小于 $6$ 的点数，问投 $100$ 次从未投到 $6$ 的概率是多少？ $P_{100} = (5/6)^{100} = ...$ 二、随机变量及其分布 什么是随机变量？ 将事件与数值联系起来 表示随机试验各种结果的实值单值函数，可以用数学分析的方法来研究随机现象 离散随机变量 抛硬币： | X | 1 | 0 | | --- | --- | --- | | P | 1/2 | 1/2 | 大写 $X$ 表示具体变量，小写 $x$ 表示样本取值 概率表达方式 1、离散型随机变量：概率分布函数 设 $X$ 是一个随机变量，$x$ 是任意实数，函数 $F(x) = P(X \\leqslant x)$ 称为 $X$ 的分布函数。有时也记为 $X \\sim F(x)$。（像一个阶梯）分布函数就是变量小于等于某个特定值 $x$ 的概率 2、连续型随机变量：概率密度函数 $X \\sim f(x)$：$P{a 概率密度直方图 $y$ 轴是频率/组距，所以小长方形的面积之和为 $1$ 介于 $x=a$，$x=b$ 之间的面积（对概率密度函数求积分），近似等于它落在 $(a,b]$ 之间的频率 概率密度函数的某一个 $x$ 对应的值的意义是什么？ $x$ 对应的 $y$ 并不是概率的大小，因为 某个点的概率为 $0$ $x$ 对应的 $y$ 的值是取 $x$ 附近的概率值的大小，$P{x 分布函数 $F(x) = P(X \\leqslant x)$ 对离散型和连续型都成立，但是具体对离散型和连续型的求法不一样 离散型分布 1、泊松分布 可以通过 无限细分的二项分布 推出来，求极限的话就是得到的结果就是泊松分布 \r P(X=k) = \\frac{\\lambda^{k}}{k!} e^{-\\lambda}\r 描述人群每分钟闯红灯的情况 2、超几何分布 从 $a$ 个白球和 $b$ 个黑球中抽取 $n$ 个球，那么以 $X$ 表示抽取出的白球的数目，它的分布律满足超几何分布 近似计算，$N$ 很大，$n/N$ 很小时可以转换成泊松分布？？？？？ 3、01 分布 4、几何分布 前 $k-1$ 次均没发生，但是第 $k$ 次发生 5、二项分布 近似计算，当 $n>100$ 且 $np \\leqslant 10$ 时，可以转换成泊松分布 $lambda=np$ ？？？？？ 指数分布 $X \\sim \\text{Exp}(\\lambda)$ \r F(x; \\lambda) = \r \\begin{cases}\r \\ 1-e^{-\\lambda x} &, x \\geqslant 0 \\\\\r \\ 0 &, x 应用：半导体器件的抽验方案都是采用指数分布；还用来描述大型复杂系统（如计算机）的平均故障间隔时间 MTBF 的失效分布 离散型随机变量函数的分布 已知 $X$ 的分布，求 $Y=3X+5$ 和 $Z=X^{2}$ 的分布 | X | -1 | 0 | 1 | 2 | | --- | --- | --- | --- | --- | | P | 0.2 | 0.3 | 0.4 | 0.1 | $Y$ 的取值有：$2、5、8、11$，故 | Y | 2 | 5 | 8 | 11 | | --- | --- | --- | --- | --- | | P | 0.2 | 0.3 | 0.4 | 0.1 | $Z$ 的取值有：$0、1、4$，故 | Y | 0 | 1 | 4 | | --- | --- | --- | --- | | P | 0.3 | 0.2+0.4=0.6 | 0.1 | 连续型随机变量函数的分布 设随机变量 $X$ 的概率密度函数为 $f{X(x)}$，并假设 $y=g(x)$ 及其 一阶导数是连续 函数，则 $Y=g(X)$ 是连续型随机变量，现在来求 $Y$ 的概率密度函数 $f{Y(x)}$ 第一步：建立随机变量 $Y$ 的分布函数 $F{Y(x)}$ 与 $X$ 的分布函数 $F{X(x)}$ 之间的关系，或者求出随机变量 $Y$ 的分布函数 $FY(x)$ 第二步：对 $F{Y(x)}$ 求导便得 $f{Y(x)}$ 例子 设随机变量 $X$ 的概率密度函数为 $f{X(x)}$，$Y=3X+2$，求 $Y$ 的概率密度函数 $f{Y(x)}$ 1、建立随机变量 $Y$ 的概率分布函数 $F{Y(x)}$ 与 $X$ 的概率分布函数 $F{X(x)}$ 之间的关系： \r F_{Y(x)} = P\\{Y \\leqslant x\\} = P\\{3X+2 \\leqslant x\\} = P\\{X \\leqslant (x-2)/3\\} = F_{X((x-2)/3)}\r 2、两边求导： \r f_{Y(x)} = 1/3*f_{X((x-2)/3)}\r 3、如果知道 $f{X(x)}$，直接将它替换成 $f_{Y(x)}$ 即可，例如若 \r f_{X(x)} = 1/4，(0 \\leqslant x \\leqslant 4)\r 那么对应的 \r f_Y(x)=1/3*1/4，(0 \\leqslant (x-2)/3 \\leqslant 4)\r 分布函数 $F(x)$ 和概率密度函数 $f(x)$ 的关系 分布函数 求导 是概率密度函数 概率密度函数 积分 是分布函数 概率密度函数积分是求面积，那么自然结果是分布函数 线性和非线性 线性：一维的相加减 非线性：$y=x^2$，$sinx$，$1/y$，$lnz$，$tan(x^2+1)$ 等等 三、多维随机变量及其分布 二维随机变量及其分布函数 设 $E$ 是随机试验，其样本空间为 $Ω$，$X$、$Y$是定义在 $Ω$ 上试验 $E$ 的两个随机变量 称以 $x$、$y$ 为分量的向量 $(X,Y)$ 为试验 $E$ 的二维随机变量，或称二维随机向量 比如研究人的身高体重，身高体重就是 $(X,Y)$ 向量 设 $x$、$y$ 为任意实数，二元函数 $F(x,y) = P{X \\leqslant x,Y \\leqslant y}$ 称为 二维随机变量 $(X,Y)$ 的分布函数，或称为 $X$ 与 $Y$ 的 联合分布函数 $F(X,Y)$ 的值即左下角区域的 面积 二维离散型的联合分布和边缘分布 联合分布：随机变量 $(X,Y)$ 的概率分布函数为联合分布 | X\\Y | 1 | 2 | 3 | | --- | --- | --- | --- | | 1 | 0 | 1/2 | 1/8 | | 2 | 1/8 | 1/8 | 1/8 | $P{X=x{i}; Y=y{j}} = P_{ij} \\geqslant 0$ $F(-1,2) = P{X \\leqslant -1, Y \\leqslant 2} = 0$ $F(1,2) = P{X \\leqslant 1, Y \\leqslant 2} = 0+1/2 = 1/2$ $F(4,5) = P{X \\leqslant 4, Y \\leqslant 5} = 1$ 边缘分布：对离散的概率表的行或列求和，得到分量 $X$(或$Y$) 的概率分布，称为边缘分布 | X | 1 | 2 | | --- | --- | --- | | P | 0 | 5/8 | 3/8 | Y 1 2 3 P 1/8 5/8 2/8 二维离散型的联合分布和边缘分布 联合分布 \r F(x,y) = P\\{X \\leqslant x, Y \\leqslant y\\} = \\int_{-\\infty}^{x} \\int_{-\\infty}^{y} f(u,v) dudv\r 其中 $f(u,v)$ 是联合密度函数 边缘分布 利用联合密度函数，$X$ 的边缘就对 $y$ 积分，$Y$ 的边缘就对 $x$ 积分 \r f_{X}(x) = \\int_{-\\infty}^{+\\infty} f(x,v) dv = \\int_{-\\infty}^{+\\infty} f(x,y) dy\r 独立性： 若边缘分布相乘等于联合分布，则说明变量之间是独立的，反之不独立，例如 | X\\Y | 0 | 1 | $P{i}^{X}（X的边缘分布,i=0,1）$ | | --- | --- | --- | :---: | | 0 | 0.2 | 0.2 | 0.4 | | 1 | 0.2 | 0.4 | 0.6 | | $P{j}^{Y}（Y的边缘分布,j=0,1）$ | 0.4 | 0.6 | 1 | X\\Y 0 1 $P_{i}^{X}（X的边缘分布,i=0,1）$ 0 0.2 0.3 0.5 1 0.2 0.3 0.5 $P_{j}^{Y}（Y的边缘分布,j=0,1）$ 0.4 0.6 1 多维随机变量 之前描述的问题都只有一个变量，比如身高，体重之类的 但是有些问题一定需要多个变量，比如研究家庭生活情况的衣食住行四个方面 条件分布 在 某条件之下发生的分布 比如身高限定在 1.7m，看体重的分布 样本空间会发生改变 1、离散型 随机变量 | X\\Y | 0 | 1 | $P{i}^{X}（X的边缘分布,i=0,1）$ | | --- | --- | --- | :---: | | 0 | 0.1 | 0.3 | 0.4 | | 1 | 0.3 | 0.3 | 0.6 | | $P{j}^{Y}（Y的边缘分布,j=0,1）$ | 0.4 | 0.6 | 1 | $P{X=1 | Y=0} = \\frac{P{X=1,Y=0}}{P{Y=0}} = \\frac{0.3}{0.4} = 0.75$ 2、连续型 随机变量的条件分布 同理 定义：$(X,Y)$，$f(x,y)$，$f{X}(x)$，$f{Y}(y)>0$，则 \r f(x | y) = \\frac{f(x,y)}{f_{Y}(y)} \\\\\r F(x | y) = \\int_{-\\infty}^{x} \\frac{f(u,y)}{f_{Y}(y)} du\r 二维离散型 随机变量函数 的分布 | X\\Y | 4 | 4.2 | | --- | --- | --- | | 5 | 0.2 | 0.4 | | 5.1 | 0.3 | 0.1 | 若 $Z = XY$，则 $Z$ 的分布为 | Z | 20 | 21 | 20.4 | 21.41 | | --- | --- | --- | --- | --- | | P | 0.2 | 0.4 | 0.3 | 0.1 | 四、随机变量的数字特征 离散型变量的数学期望 对 $x{i}p{i}$ 求和 连续型变量的数学期望 对 $xf(x)$ 求积分，$x$ 是取值，$f(x)$ 是概率 随机变量函数 的数学期望 已知 $x$ 的期望，此时 $Y=g(x)$，求 $Y$ 的期望 直接把公式里面的 $x$ 换成 $g(x)$ 数学期望的性质 若 $X$、$Y$ 独立，则有 $E(XY) = E(X)E(Y)$ 条件期望 两个变量，一个变量取定了某个值的前提下，另一个变量的期望 离散 $E(X|Y=y{j}) = x{i}P(X=x{i}|y=y{j})$ 连续 $E(X|Y=y_{j}) = yf(x|y)dx$ 方差 $D(X) = E[(X-EX)^2]$ 离散 连续 标准差即再开根号 $D(X) = E(X^2)-E(X)^2$ 常见分布的期望和方差 | 分布 | 定义 | 数学期望 | 方差 | | --- | --- | --- | --- | | 01分布 | $P(X=k)=p^{k}(1-p)^{1-k} \\quad k=0,1$ | $p$ | $pq$ | | 二项分布 | $P(X=k)=C_{n}^{k}p^{k}(1-p)^{n-k} \\quad k=0,1,...,n$ | $np$ | $npq$ | | 几何分布 | $P(X=k)=(1-p)^{k-1}p \\quad k=1,2,...$ | $\\frac{1}{p}$ | $\\frac{1-p}{p^{2}}$ | | 泊松分布 | $P(X=k)=\\frac{\\lambda^{k}}{k!} e^{-\\lambda} \\quad k=0,1,...$ | $\\lambda$ | $\\lambda$ | | 均匀分布 | $f(x) = \\begin{cases} \\ \\frac{1}{b-a} & ,x \\in [a,b] \\ \\ 0 & ,\\text{else} \\end{cases}$ | $\\frac{a+b}{2}$ | $\\frac{ (b-a)^{2} }{12}$ | | 指数分布 | $f(x) = \\begin{cases} \\ \\lambda e^{-\\lambda x} & ,x>0 \\ \\ 0 & ,\\text{else} \\end{cases}$ | $\\frac{1}{\\lambda}$ | $\\frac{1}{\\lambda^{2}}$ | | 正态分布 | $f(x)=\\frac{1}{\\sqrt{2 \\pi}\\sigma} \\text{exp}(-\\frac{(x-\\mu)^{2}}{2 \\sigma^{2}})$ | $\\mu$ | $\\sigma^{2}$ | 协方差 \r \\begin{aligned}\r Cov(X,Y) = \\,& E[(X-EX)(Y-EY)] \\\\\r = \\,& E[XY-XE(Y)-YE(X)+E(X)E(Y)] \\\\\r = \\,& E(XY) - E(X)E(Y) - E(X)E(Y) + E(X)E(Y) \\\\\r = \\,& E(XY)-E(X)E(Y)\r \\end{aligned}\r 【协方差表示两变量的关系】：两个变量在变化过程中是同方向变化？还是反方向变化？同向或反向程度如何？ 【相关系数看做特殊协方差】：相关系数 $\\rho = \\frac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}} = \\frac{E(XY)-E(X)E(Y)}{\\sqrt{D(X)D(Y)}}$，是一种剔除了两个变量量纲影响、标准化后的特殊协方差 $X$, $Y$ 不相关和 $X$, $Y$ 独立 不相关：指的是 $X$, $Y$ 线性不相关 独立：指的是 $X$, $Y$ 之间没有任何关系，包括线性关系，非线性关系 $X$, $Y$ 独立可以推出则 $X$, $Y$ 不相关 中心矩与原点矩 原点矩以原点为中心：$E[(X-0)^{k}]=E(X^{k})$，期望是 $E(X)$，所以 期望是一阶原点矩 几何图形的重心 中心矩以 $E(X)$ 为中心：$E[(X-E(X))^k]$，一阶中心距 $E[(X-EX)^1]=E(X)-E(X)=0$；二阶中心距 $E[(X-E(X))^2]$ 就是方差 五、大数定律与中心极限定理 大数定理：大量重复试验的平均结果（期望）的稳定性 切比雪夫不等式：事件大多会集中在平均值附近 期望和方差存在的时候 \r P(|X-EX| \\geqslant \\varepsilon) \\leqslant \\frac{DX}{\\varepsilon_{2}} \\\\\r \\text{等价于} \\\\\r P(|X-EX| 切比雪夫大数定律 变量均值收敛于期望均值 \r \\displaystyle \\lim_{ n \\to \\infty } P\\{ \\left| \\frac{1}{n} \\sum_{i=1}^{n} X_{i} - \\frac{1}{n} \\sum_{i=1}^{n} E(X_{i}) \\right| 中心极限定理 大量独立同分布的变量和的极限分布是正态分布 如果样本量足够大，则变量 均值的采样分布 将 近似于正态分布，而与该变量在总体中的分布无关 标准化之后，期望为 $0$，方差为 $1$，没标准化的话，期望为为 $nμ$，方差为 $nσ^{2}$ 六、数理统计的基本概念 总体就是全体集合 样本就是抽出的样本 样本变量是 $X{i}$ 样本观测值是 $x{i}$ 统计量 不含任何未知参数的样本的函数 需要通过样本去 构造 函数 常用统计量：均值、样本方差、标准差、原点矩、中心距等 七、参数估计 参数估计就是用样本的值来猜测总体分布的参数值（需要用样本 构造函数 来估计） 参数空间即参数的取值范围 点估计：只猜一个点。例如要猜身高我们只给出了 $180$ 区间估计：猜测一个区间。例如要猜身高我们给出在 $[160, 185]$ 极大似然估计 概率大的事件比概率小的事件更容易发生，即将使事件发生的概率最大的参数值作为估计值 似然函数为什么是连乘起来的？ 本来是联合概率函数，因为独立，所以分开来写 做题步骤： 1、离散型随机变量就确定总体的概率函数，连续型随机变量就确定密度函数 2、写似然函数 $L(λ)$，$λ$ 是参数 3、两边去 $ln$（因为是连乘），得 $lnL(λ)$ 4、对 $λ$ 求导，得最大值的话，就是令导数为 $0$s Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-11-20 23:20:10 "},"about_Math/统计相关.html":{"url":"about_Math/统计相关.html","title":"统计相关","keywords":"","body":" 6σ 使得变异和波动可度量 σ越大，废品率越低 μ±σ 占大约68% μ±2σ 占大约95% μ±3σ 占大约99.7% 描述数据分布 统计参数： 1、位置参数：均值、中位数、众数 2、波动参数 频率直方图 p 值 Fisher 发明的，即发生原假设事件的概率或者原假设为真的概率 p 值是累计概率。首先原假设无罪，随着证据越明显，无罪概率 p 值越小，若小到给定的一个界限例如 α=0.05，即可推翻原假设，断定有罪 概率分布图 曲线下方的面积为1，横坐标是随机变量，纵坐标是概率密度 自由度 一般说的是总体的自由度，可有限或者无限 从总体中随机抽取一个样本，求出的样本均值和样本方差叫做样本统计量，可以用来估计总体参数，即总体的均值和方差 样本方差的分母为自由度-1，保证无偏估计。因为在样品均值固定时，剩余一个样品的值便固定了，故为自由度-1 这说明计算样本均值的时候就已经使用了一个自由度 注意若计算样本方差时已知了总体均值，这时没有消耗自由度，故除以n 中心极限定理 从总体中抽取许多的样本，每个样本计算得到样本均值 将样本均值绘制成曲线，得到均值分布 均值分布的均值会随诊样本量的增加越来越接近总体均值 均值分布的标准差叫做标准误，且有：$\\sigma^{'}=\\frac{\\sigma}{\\sqrt{n}}$ 置信区间 一般只会从总体中抽取一个样本 我们先求出其标准差和均值，由此算出一个区间，这个区间有95%的概率包含总体均值 对于均值的置信区间，常用的计算公式是：置信区间 = 样本均值 ± Z * (标准误差)，其中，样本均值是对总体均值的估计值，Z是标准正态分布的分位数，标准误差是样本均值的标准差。对于95%的置信区间，Z的值通常取1.96，因为在标准正态分布中，95%的面积位于均值左右两侧1.96个标准差的范围内 标准差和标准误差 标准差：是 数据精密度 的衡量指标，反映了整个样本对样本平均数的离散程度，即就是样本数据的离散程度，重点是样本 标准误差：是量度 结果精密度 的指标，反映样本平均数对总体平均数的变异程度，表示的是抽样的误差，代表的就是样本平均数与总体均数的相对误差，重点是样本和总体 数据的正态性检验方法 1、图形观察法：通过直方图、P-P图或Q-Q图进行观察，如果分布严重偏态和尖峰分布则建议进行进一步的假设检验。如果图形分布结果不好判断，则再进行正态性检验 2、统计检验法：包括Shapiro-Wilk检验、Kolmogorov-Smirnov检验、Jarque-Bera检验等 3、描述法：通过样本数据的平均值、中位数、众数、标准差等基本特征来判断数据是否符合正态分布 z 值和 z 分布 总体分布假设是正态分布 抽样 $n \\geq 30$： 总体 $\\sigma$ 已知，则 $\\sigma^{'}=\\frac{\\sigma}{\\sqrt{n}}$ 总体 $\\sigma$ 未知，则 $\\sigma^{'}=\\frac{S（样本标准差）}{\\sqrt{n}}$ 抽样 $n \\lt 30$： 总体 $\\sigma$ 已知，则 $\\sigma^{'}=\\frac{\\sigma}{\\sqrt{n}}$ 总体 $\\sigma$ 未知，该怎么办？ 为了解决上述问题，定义 $Z{i}=\\frac{\\bar{X{i}}-\\mu}{\\sigma^{'}}=\\frac{\\bar{X{i}}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}}$，即从均值分布中任取一个均值 $\\bar{X{i}}$，计算其与总体均值之间的差异计算多个后得到对应的 $Z{1},Z{2},...,Z_{m}$，即z分布，服从标准正态分布~N(0,1) t 值和 t 分布 当抽样 $n \\lt 30$： 若 $\\mu$ 未知，$\\sigma^{'}=\\frac{\\sigma}{\\sqrt{n}} \\ne \\frac{S}{\\sqrt{n}}$ 令 $t=\\frac{\\bar{X}-\\mu}{\\frac{S}{\\sqrt{n}}}=\\frac{(\\bar{X}-\\mu)/\\frac{\\sigma}{\\sqrt{n}}}{\\frac{S}{\\sqrt{n}}/\\frac{\\sigma}{\\sqrt{n}}}=\\frac{Z}{S/\\sigma} \\sim t(n-1)$ 这里因为使用了 S 故自由度减一，其中 $S/\\sigma=\\sqrt{\\frac{(n-1)S^{2}}{(n-1)\\sigma^{2}}}=\\frac{\\sqrt{\\frac{(n-1)S^{2}}{\\sigma^{2}}}}{\\sqrt{n-1}} \\sim X^{2}(n-1)$ 故 $t=\\frac{Z}{\\sqrt{\\frac{Y}{n-1}}}$ t 分布的形状与抽取的样本量有关，当抽取的样本量增大，t 会趋于服从正态分布 箱线图 $IQR = Q{3}-Q{1}$ 四分位数：该样本中所有数值由小到大排列后第25%、50%、75%位置上的数字 第一四分位数 (Q1)，又称“较小四分位数”，第二四分位数 (Q2)，又称“中位数”，第三四分位数 (Q3)，又称“较大四分位数” 箱线图的箱子部分即IQR，上下两端还有虚线称为whiskers，它的长度 $\\leq 1.5*IQR$，故超出箱子部分加上whiskers部分的区域叫做离群值 f 值和 f 分布 用于方差分析，f值可以反映总体之间的差异，以及组内的差异 $f=\\frac{\\text{组间波动}}{\\text{组内波动}}$ f值越大，表示越有可能发生 f分布是由f值形成的频率直方图，有前提，原假设 $\\mu{1}=\\mu{2}=\\mu_{3}$，三个总体的均值相等 差异的平方和➗自由度=均方和 ANOVA：analysis of variance 二项分布 抛硬币，要么正面，要么反面（两种情况） 泊松分布 是二项分布的极限情况 一个产品已知有平均4个缺陷，将一个产品分为10个间隔（需要使得每个间隔仅能存在一个缺陷，故只有间隔无穷小的时候能满足所有情况），求一个产品中出现0、1、2、...、n个缺陷的概率，这些概率构成的分布即泊松分布 要求事件发生独立同分布，两次时间发生互不影响 指数分布 $P(Y \\gt t)=e^{-\\lambda t}$ $P(x=0, t)=\\frac{(\\lambda t)^{0}}{0!} e^{-\\lambda t}=e^{-\\lambda t}$ 数据类型 定类 可以比较是否相等 定序 可以比较大小 定距 乘除无意义 定比 可以加减乘除 双样本 t 检验 用于判断两个总体的均值是否相等 原假设：$\\mu{1}=\\mu{2}$，备择假设：$\\mu{1} \\ne \\mu{2}$ 从两个总体中分别抽取一个样本，可以计算它们之间的差异 $X{i}-X{j}$，多次相同的操作后，可以得到对应的分布 每个差值可以计算得到一个t值：$\\frac{(X{1}-X{2})-0}{\\sqrt{\\frac{S{1}^{2}}{n{1}}+\\frac{S{2}^{2}}{n{2}}}}$，分母是标准误，这样就得到了双样本均值差的 t 分布 原假设和备择假设 普遍的倾向放在原假设里，例如法官对于嫌疑犯的假设就如普通人一样是无罪的 想要推翻的放在原假设，否则既然想要的结果已经在原假设里那就没有推翻它的必要了 等价检验 样本量越大，越有肯能推翻原假设，因为标准误中分母是样本量，会影响双样本均值差的分布 给定等价区间，当样本量差异落在这个区间时，便容忍接受 原假设：$\\mu{1} \\ne \\mu{2}$=>$\\mu{1}-\\mu{2} \\leq \\delta{L}$ 或者 $\\mu{1}-\\mu{2} \\geq \\delta{U}$ 备择假设：$\\mu{1}=\\mu{2}$=>$\\delta{L} \\lt \\mu{1}-\\mu{2} \\lt \\delta{U}$ 协方差和相关系数 协方差：$\\frac{\\sum(X{i}-\\mu{1})(Y{j}-\\mu{2})}{N} = E[(X-\\mu{1})(Y-\\mu{2})]$ 用于描述两个变量的相关程度，绝对值越大越相关，正负号表示正或者负相关 相关系数：$\\frac{E[(X-\\mu{1})(Y-\\mu{2})]}{\\sigma{1}\\sigma{2}} $ 协方差的标准化 自相关系数 $r=\\frac{\\sum{i=1}^{N}(Y{i}-\\bar{Y})(Y{i-1}-\\bar{Y})}{\\sum{i=0}^{N}(Y{i}-\\bar{Y})(Y{i}-\\bar{Y})}$ 分母相当于做标准化 假设现在要研究一个家族男性身高是否和父辈有关系，那么 $Y{i}$ 可以看作是 $Y{i-1}$ 的儿子的身高 卡方分布 假设总体分布的均值和标准差为 $\\mu、\\sigma$ 抽取若干个样本分别计算其均值，得到若干个样本均值，绘制对应的分布图得到均值分布，其均值和标准差为 $\\mu、\\frac{\\sigma}{\\sqrt{n}}$ 计算z值得到z分布：$Z{1}=\\frac{\\bar{X}{1}-\\mu}{\\sigma^{'}}=\\frac{\\bar{X}{1}-\\mu}{\\frac{\\sigma}{\\sqrt{n}}},Z{2},...,Z{n}$，均值为 0 方差为 1 对 z 值取平方，画出频率直方图，即为自由度为 1 的卡方分布 若 3 个一组求 z 值的平方和，得到自由度为 3 的卡方分布 $\\sum{i=1}^{n} Z{i}^{2}=\\frac{\\sum(X-\\mu)^{2}}{\\sigma^{2}} \\sim \\chi{n}^{2}$，其中的 $\\mu$ 为总体均值 当总体均值未知时，需要用样本均值代替，因为 $S^{2}=\\frac{\\sum(X-\\bar{X})^{2}}{n-1}$，带入上式得到 $\\frac{\\sum(X-\\bar{X})^{2}}{\\sigma^{2}}=\\frac{S^{2}(n-1)}{\\sigma^{2}} \\sim \\chi_{n-1}^{2}$ 交互作用 影响一个事件的因素可能有多种，而因素之间的组合可能会有不同的影响 卡方分布的方差检验 卡方分布可以用于比较方差 $\\sum{i=1}^{n} Z{i}^{2}=\\frac{\\sum(X-\\mu)^{2}}{\\sigma^{2}} \\sim \\chi{n}^{2}$ $=\\frac{S^{2}(n-1)}{\\sigma^{2}} \\sim \\chi{n-1}^{2}$ 假设 $\\sigma^{'}=\\sigma$，计算 $\\frac{S^{2}(n-1)}{\\sigma^{2}}$，查表若落在给定的区间内，说明假设成立 贝叶斯定理 $P(A|B)=\\frac{P(AB)}{P(B)}，P(B|A)=\\frac{P(AB)}{P(A)}，P(AB)=P(A|B)P(B)=P(B|A)P(A)$ 假设现在有10000人，其中5500人是特的支持者，4500人是拜的支持者 特：1500人高学历，4000人低学历 拜：2250人高学历，2250人低学历 则：$P(高学历|特)=\\frac{P(高学历且特)}{P(特)}=\\frac{1500/10000}{5500/10000}$，$P(特|高学历)=\\frac{P(高学历且特)}{P(高学历)}=\\frac{1500/10000}{3750/10000}=0.4$ 综上 $P(特)$ 先验概率：不知晓一个人的前提下，他支持特的概率 $P(高学历)$ 证据：一个人是高学历的概率 $P(特|高学历)$ 后验概率：已知一个人是高学历，他支持特的概率 $P(高学历|特)$ 似然：一个人支持特的情况下，他是高学历的可能性 计算过程就是获得新数据，不断更新先验概率，再去计算后验概率 卡方独立性检验 列联表：对表格的行和列进行求和 原假设：两个属性相互独立 $\\sum \\frac{(观测-期望)^{2}}{期望} \\sim \\chi^{2}$ 卡方拟合优度检验 检验 分类变量 的观测值与期望值的拟合效果 已知某地盲盒各类型的投放比例，令其为原假设。之后抽样对比原假设计算出的期望值，$\\sum \\frac{(0-E)^{2}}{E}$，若结果落在右侧的拖尾处则有理由拒绝原假设 几何分布 几何就是等比，指数级的意思 $P(X=i)=(1-p)^{i-1}p$ 常用数据统计分析方法 参考链接：https://blog.csdn.net/weixin_30776273/article/details/98408366 描述统计 描述数据的集中趋势、离散趋势、偏度、峰度1、缺失值填充常用方法：剔除法、均值法、最小邻居法、比率回归法？、决策树法？2、正态性检验很多统计方法都要求数值服从或近似服从正态分布，所以之前需要进行正态性检验常用方法：非参数检验的 K-量检验、P-P图、Q-Q图、W检验、动差法 假设检验 1、参数检验参数检验是在已知总体分布的条件下（一股要求总体服从正态分布）对一些主要的参数(如均值、百分数、方差、相关系数等）进行的检验 U验 使用条件：当样本含量n较大时，样本值符合正态分布 T检验 使用条件：当样本含量n较小时，样本值符合正态分布 单样本t检验：推断该样本来自的总体均数μ与已知的某一总体均数μ0 (常为理论值或标准值)有无差别； 配对样本t检验：当总体均数未知时，且两个样本可以配对，同对中的两者在可能会影响处理效果的各种条件方面扱为相似； 两独立样本t检验：无法找到在各方面极为相似的两样本作配对比较时使用 2、非参数检验https://zhuanlan.zhihu.com/p/93196547非参数检验则不考虑总体分布是否已知，常常也不是针对总体参数，而是针对总体的某些假设（如总体分布的位罝是否相同，总体分布是否正态）进行检验 适用情况：顺序类型 的数据资料，这类数据的分布形态一般是未知的 虽然是连续数据，但 总体分布形态未知 或者非正态 体分布虽然正态，数据也是连续类型，但 样本容量极小，如10以下 主要方法包括：卡方检验、秩和检验、二项检验、游程检验、K-量检验等 列联表分析 用于分析离散变量或定型变量之间是否存在相关对于二维表，可进行卡方检验，对于三维表，可作Mentel-Hanszel分层分析列联表分析还包括配对计数资料的卡方检验、行列均为顺序变量的相关检验 相关分析 研究现象之间是否存在某种依存关系，对具体有依存关系的现象探讨相关方向及相关程度1、单相关： 两个因素之间的相关关系叫单相关，即研究时只涉及一个自变量和一个因变量2、复相关 ：三个或三个以上因素的相关关系叫复相关，即研究时涉及两个或两个以上的自变量和因变量相关3、偏相关：在某一现象与多种现象相关的场合，当假定其他变量不变时，其中两个变量之间的相关关系称为偏相关 方差分析 使用条件：各样本须是相互独立的随机样本；各样本来自正态分布总体；各总体方差相等分类1、单因素方差分析：一项试验只有一个影响因素，或者存在多个影响因素时，只分析一个因素与响应变量的关系2、多因素有交互方差分析：一顼实验有多个影响因素，分析多个影响因素与响应变量的关系，同时考虑多个影响因素之间的关系3、多因素无交互方差分析：分析多个影响因素与响应变量的关系，但是影响因素之间没有影响关系或忽略影响关系4、协方差分祈：传统的方差分析存在明显的弊端，无法控制分析中存在的某些随机因素，使之影响了分祈结果的准确度。协方差分析主要是在排除了协变量的影响后再对修正后的主效应进行方差分析，是将线性回归与方差分析结合起来的一种分析方法 回归分析 聚类分析 判别分析 主成分分析 因子分析 时间序列分析 ROC分析 其他分析 多重响应分析、距离分祈、项目分祈、对应分祈、决策树分析、神经网络、系统方程、蒙特卡洛模拟等 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-11-13 20:00:56 "},"about_Math/其他.html":{"url":"about_Math/其他.html","title":"其他","keywords":"","body":"如何阅读文献 影响因子越高代表文章的含金量越高 决定影响因子的因素： 1、论文出版时滞、论文长度、类型、合著者等等 2、期刊因素 3、学科因素 4、检索系统因素 5、名人效应因素 tips 先看学位论文，再看小论文 可以只看绪论部分，了解该领域的经典参考文献 先看摘要，不能逮到一篇就精读 建议做好阅读笔记 写论文常用的网站 SJR：https://www.scimagojr.com/journalrank.php SCImago Joumal Rankings 的缩写，是一个既考虑了期刊被引数量，又考虑了期刊被引质量的指标，反映了期刊的声望指数 英文语法检查：https://www.grammarly.com/ 论文预稿查阅：https://arxiv.org/ 中国知网：https://www.cnki.net/ 万方数据资源系统：https://g.wanfangdata.com.cn/ 期刊查询：https://www.letpub.com/index.php?page=journalapp&view=search https://www.letpub.com/journalapp/ Word 公式编辑技巧：https://zhuanlan.zhihu.com/p/439988361 预共轭梯度法 一、共轭梯度法 Conjugate Gradient Method，简称 CG 算法。经常用于求解线性方程组 1.1 思想 选择一个优化方向后，便将该方向优化到极致，后面优化的过程不再影响之前的方向的极小值 这就要求每一次的优化方向都共轭正交 1.2 什么是共轭？什么是正交？ 假设有一组向量 $\\boldsymbol{S{1}}\\boldsymbol{S{2}}...\\boldsymbol{S{m}}$，矩阵 $\\boldsymbol{A}$ 正定 若有 $\\left{\\begin{matrix} \\boldsymbol{S{i}}^{T}A\\boldsymbol{S{j}} = 0 \\ \\boldsymbol{S{i}}^{T}A\\boldsymbol{S{i}} \\neq 0 \\ \\end{matrix}\\right.$，则称 $\\boldsymbol{S{1}}\\boldsymbol{S{2}}...\\boldsymbol{S{m}}$ 是 $\\boldsymbol{A}$ 的共轭向量，它们之间线性无关 若 $\\boldsymbol{A}$ 还是单位矩阵，则 $\\boldsymbol{S{1}}\\boldsymbol{S{2}}...\\boldsymbol{S_{m}}$ 是 $\\boldsymbol{A}$ 的正交向量 所以共轭是正交的推广，正交的要求更高 假设有矩阵 $X、Y$，矩阵 $\\boldsymbol{A}$ 是 $n$ 阶正定阵 若有 $X^{T}AY = 0$，则称 $X$ 与 $Y$ 关于 $\\boldsymbol{A}$ 是共轭的 1.3 优缺点 优 克服了梯度下降收敛慢 避免了牛顿法所需的二阶导数信息 对于 $n$ 维优化问题，最多 $n$ 次迭代就能找到最优解 缺 极端情况下，矩阵 $\\boldsymbol{A}$ 的条件数很大，会影响收敛速度 需要注意设置迭代次数，并不是越多越好 1.4 详细过程 假设有方程： \r \\boldsymbol{A}\\boldsymbol{x} = \\boldsymbol{b}\r 其中 $\\boldsymbol{A}$ 是 $n$ 阶的对称正定矩阵，$\\boldsymbol{b}$ 已知，求解 $\\boldsymbol{x}$ 构造 $f(\\boldsymbol{x}) = \\frac{1}{2}\\boldsymbol{x}^{T}\\boldsymbol{A}\\boldsymbol{x} - \\boldsymbol{b}^{T}\\boldsymbol{x} + c$，则 $\\frac{\\partial f(\\boldsymbol{x})}{\\partial \\boldsymbol{x}} = \\boldsymbol{A}\\boldsymbol{x} - \\boldsymbol{b}$ 由 $\\boldsymbol{A}\\boldsymbol{x} = \\boldsymbol{b}$ 得 $\\frac{\\partial f(\\boldsymbol{x})}{\\partial \\boldsymbol{x}} = 0$，即求解方程转换成求能使得 $f(\\boldsymbol{x})$ 最小的向量 \r \\boldsymbol{x}^{*} = \\mathop{\\arg\\min} \\limits_{\\boldsymbol{x}} (\\frac{1}{2}\\boldsymbol{x}^{T}\\boldsymbol{A}\\boldsymbol{x} - \\boldsymbol{b}^{T}x + c)\r 向量 $\\boldsymbol{x}$ 任取初值 $\\boldsymbol{x}{0}$，函数 $f(\\boldsymbol{x})$ 在 $\\boldsymbol{x}{0}$ 处的负梯度方向为 $\\boldsymbol{r}{0} = \\boldsymbol{b} − \\boldsymbol{A}\\boldsymbol{x}{0}$ 最速下降（Gradient Descent）法的基本思想是每次迭代都沿着 $\\boldsymbol{x}$ 的梯度的方向下降，最终会收敛到最优值上。共轭梯度法则是在由前一步的下山方向 $\\boldsymbol{p}{k-1}$ 与当前步的梯度方向 $\\boldsymbol{r}{k}$ 所张成的「二维平面」上找到新的最优下山方向 ===>如何推导？？？ $\\boldsymbol{x}$、$\\boldsymbol{b}$、$\\boldsymbol{r}$ 是向量需要粗体，$c$ 是常数，$\\alpha$、$\\beta$、$\\xi$、$\\eta$ 是标量 给定初始向量 $\\boldsymbol{x}{0}$，第一步选取的下山方向 $\\boldsymbol{p}{0}$ 仍是 $\\boldsymbol{r}{0} = \\boldsymbol{b} − \\boldsymbol{A}\\boldsymbol{x}{0}$，之后第 $k+1$ 步 $（k \\geq 1）$，就在前一步的下山方向 $\\boldsymbol{p}{k−1}$ 和当前步的梯度方向 $\\boldsymbol{r}{k}$ 所张成的平面上找最优的下山方向，即第 $k+1$ 步的下山方向 $\\boldsymbol{p}{k}$ 为： \r \\boldsymbol{p}_{k} = \\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}，其中 \\xi, \\eta \\in \\mathbb{R}\r 当然 $\\boldsymbol{p}{k}$ 也不能任意取，需要考虑到二次型 $f(\\boldsymbol{x})$ 的限制？？？？？。将 $\\boldsymbol{p}{k}$ 带入 $f(\\boldsymbol{x})$，构造一个新函数 $\\psi(\\xi, \\eta)$： \r \\begin{aligned}\r \\psi(\\xi, \\eta) = \\, & f(\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1})\\\\ \r = \\, & \\frac{1}{2}(\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1})^\\mathrm{T}\\boldsymbol{A}(\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1})\\\\ \r & -\\boldsymbol{b}^\\mathrm{T}(\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}) + c\r \\end{aligned}\r \\tag{1}\r 式 1 分别对 $\\xi$ 和 $\\eta$ 求偏导得 \r \\begin{aligned}\r \\frac{\\partial\\psi}{\\partial\\xi} = \\, & \\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}(\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}) - \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{r}_{k}\\\\ \r = \\, & \\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1} - \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{r}_{k}\\\\\r \\, & 又因为 \\boldsymbol{r}_{k} = \\boldsymbol{b} - \\boldsymbol{A}\\boldsymbol{x}_{k}\\\\\r = \\, & \\boldsymbol{r}_{k}^\\mathrm{T}(\\boldsymbol{b} - \\boldsymbol{r}_k) + \\xi\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1} - \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{r}_{k}\\\\ \r \\, & 又因为 \\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{b} = \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{r}_{k}\\\\\r = \\, & -\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{r}_k + \\xi\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1}\\\\ \r \\frac{\\partial\\psi}{\\partial\\eta} =\\, &\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}(\\boldsymbol{x}_{k} + \\xi\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}) - \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{p}_{k-1}\\\\ \r = \\, & \\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{x}_{k} + \\xi\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1} - \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{p}_{k-1}\\\\ \r \\, & 又因为 \\boldsymbol{r}_{k} = \\boldsymbol{b} - \\boldsymbol{A}\\boldsymbol{x}_{k}\\\\\r = \\, & \\boldsymbol{p}_{k-1}^\\mathrm{T}(\\boldsymbol{b} - \\boldsymbol{r}_k) + \\xi\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1} - \\boldsymbol{b}^\\mathrm{T}\\boldsymbol{p}_{k-1}\\\\ \r = \\, & -\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{r}_{k} + \\xi\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1}\\\\ \r \\, & 又因为 \\boldsymbol{p}_{k-1} 与 \\boldsymbol{r}_{k} 共轭\\\\ \r = \\, & \\xi\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\eta\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1}\\\\ \r \\end{aligned}\r 令 $\\frac{\\partial\\psi}{\\partial\\xi} = \\frac{\\partial\\psi}{\\partial\\eta} = 0$，即： \r \\begin{cases}\r \\tilde\\xi\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\tilde\\eta\\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1} - \\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{r}_k = 0\\\\ \r \\tilde\\xi\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{r}_{k} + \\tilde\\eta\\boldsymbol{p}_{k-1}^\\mathrm{T}\\boldsymbol{A}\\boldsymbol{p}_{k-1} = 0\r \\end{cases}\r \\tag{2}\r 可解得极小值点 $\\tilde{\\boldsymbol{x}} = \\boldsymbol{x}{k} + \\tilde\\xi\\boldsymbol{r}{k} + \\tilde\\eta\\boldsymbol{p}{k-1}$，故 \r \\begin{aligned}\r \\tilde{\\boldsymbol{x}} - \\boldsymbol{x}_{k} = \\tilde\\xi\\boldsymbol{r}_{k} + \\tilde\\eta\\boldsymbol{p}_{k-1}\r \\end{aligned}\r 由于 $\\boldsymbol{r}k \\neq 0$ （因为 $\\boldsymbol{r}_k$ 是残差，若为 $0$ 则应该停止迭代了），所以 $\\tilde{\\xi} \\neq 0$（否则更新值只与前一次的下山方向有关，这样无法收敛）可作为分母，因此可取： \r \\begin{aligned}\r \\boldsymbol{p}_k = \\frac{1}{\\tilde\\xi}(\\tilde{\\boldsymbol{x}} - \\boldsymbol{x}_k) = \\boldsymbol{r}_k + \\frac{\\tilde\\eta}{\\tilde\\xi}\\boldsymbol{p}_{k-1}\r \\end{aligned}\r 作为新的下山方向。令 $\\beta{k-1} = \\frac{\\tilde{\\eta}}{\\tilde{\\xi}}$，则可由式 2 得： \r \\begin{aligned}\r \\beta_{k-1} = \\, & \\frac{\\tilde{\\eta}}{\\tilde{\\xi}} \\\\\r \\, & 因为 \\frac{\\partial\\psi}{\\partial\\eta} = 0 得 \\xi\\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{A}\\boldsymbol{r}_{k} = - \\eta\\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{A}\\boldsymbol{p}_{k-1} \\\\\r \\, & 左右同除以 -\\xi 和 \\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{A}\\boldsymbol{p}_{k-1} \\\\\r = \\, & -\\frac{\\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{Ar}_{k}}{\\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{Ap}_{k-1}} \\\\\r \\, & 因为\\boldsymbol{p}、\\boldsymbol{r}是向量，\\boldsymbol{A}对称，结果是标量，所以可以交换顺序 \\\\\r = \\, & -\\frac{\\boldsymbol{r}_k^{\\mathrm{T}}\\boldsymbol{Ap}_{k-1}}{\\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{Ap}_{k-1}}\r \\tag{3}\r \\end{aligned}\r 至此就找到了新的下山方向，向量 $\\boldsymbol{x}$ 将每次沿着下山方向，以 $\\alpha$ 为步长下降，即 $\\boldsymbol{x}{k+1} = \\boldsymbol{x}{k} + \\alpha{k}\\boldsymbol{p}{k}$，将其带入 $f(\\boldsymbol{x})$ 可得： \r \\begin{aligned}\r \\phi(\\alpha_k) = \\, & f(\\boldsymbol{x}_k + \\alpha_k\\boldsymbol{p}_k)\\\\ \r = \\, & \\frac{1}{2}(\\boldsymbol{x}_k + \\alpha_k\\boldsymbol{p}_k)^{\\mathrm{T}}\\boldsymbol{A}(\\boldsymbol{x}_k + \\alpha_k\\boldsymbol{p}_k) - \\boldsymbol{b}^{\\mathrm{T}}(\\boldsymbol{x}_k + \\alpha_k\\boldsymbol{p}_k) + c\\\\ \r = \\, & f(\\boldsymbol{x}_k) + \\frac{1}{2}\\alpha_{k}^2\\boldsymbol{p}_k^{\\mathrm{T}}\\boldsymbol{Ap}_k + \\alpha_{k}\\boldsymbol{x}_{k}^{\\mathrm{T}}\\boldsymbol{Ap}_{k} - \\alpha_{k}\\boldsymbol{b}^{\\mathrm{T}}\\boldsymbol{p}_{k}\\\\\r \\, & 又因为 \\boldsymbol{r}_{k}^{\\mathrm{T}} = (\\boldsymbol{b} - \\boldsymbol{A}\\boldsymbol{x}_{k})^{\\mathrm{T}} = \\boldsymbol{x}_{k}^{\\mathrm{T}}\\boldsymbol{A} - \\boldsymbol{b}^{\\mathrm{T}}\\\\\r = \\, & f(\\boldsymbol{x}_k) + \\frac{1}{2}\\alpha_{k}^2\\boldsymbol{p}_k^{\\mathrm{T}}\\boldsymbol{Ap}_k - \\alpha_{k}\\boldsymbol{r}_k^{\\mathrm{T}}\\boldsymbol{p}_k\r \\end{aligned}\r 令 ${\\phi}'(\\alpha{k}) = 0$ 可解得： \r \\begin{aligned}\r \\alpha_k = \\, & \\frac{\\boldsymbol{r}_k^{\\mathrm{T}}\\boldsymbol{p}_k}{\\boldsymbol{p}_k^{\\mathrm{T}}\\boldsymbol{Ap}_k}\\\\ \r = \\, & \\frac{\\boldsymbol{r}_k^{\\mathrm{T}}(\\boldsymbol{r}_k + \\beta_{k-1}\\boldsymbol{p}_{k-1})}{\\boldsymbol{p}_k^{\\mathrm{T}}\\boldsymbol{Ap}_k}\\\\ \r \\, & 因为 \\boldsymbol{p}_{k-1} 与 \\boldsymbol{r}_{k} 相互共轭 \\\\\r = \\, & \\frac{\\boldsymbol{r}_k^{\\mathrm{T}}\\boldsymbol{r}_k}{\\boldsymbol{p}_k^{\\mathrm{T}}\\boldsymbol{Ap}_k}\r \\end{aligned}\r \\tag{4}\r 根据 $\\boldsymbol{x}{k+1} = \\boldsymbol{x}{k} + \\alpha{k}\\boldsymbol{p}{k}$ 重新整理 $\\boldsymbol{r}{k+1}$ 可得： \r \\begin{aligned}\r \\boldsymbol{r}_{k+1} = \\, & \\boldsymbol{b} - \\boldsymbol{Ax}_{k+1}\\\\ \r = \\, & \\boldsymbol{b} - \\boldsymbol{A}(\\boldsymbol{x}_k + \\alpha_k\\boldsymbol{p}_k)\\\\ \r = \\, & \\boldsymbol{r}_k - \\alpha_k\\boldsymbol{A}\\boldsymbol{p}_k\\\\ \r \\end{aligned}\r 移项 \r \\begin{aligned}\r \\boldsymbol{A}\\boldsymbol{p}_k = \\frac{1}{\\alpha}(\\boldsymbol{r}_k - \\boldsymbol{r}_{k+1})\r \\tag{5}\r \\end{aligned}\r 将式 7 带入式 3 得： \r \\begin{aligned}\r \\beta_{k} = \\, & -\\frac{\\boldsymbol{r}_{k+1}^{\\mathrm{T}}\\boldsymbol{Ap}_{k}}{\\boldsymbol{p}_{k}^{\\mathrm{T}}\\boldsymbol{Ap}_{k}}\\\\ \r = \\, & -\\frac{\\frac{1}{\\alpha}\\boldsymbol{r}_{k+1}^{\\mathrm{T}}(\\boldsymbol{r}_k - \\boldsymbol{r}_{k+1})}{\\frac{1}{\\alpha}\\boldsymbol{p}_{k}^{\\mathrm{T}}(\\boldsymbol{r}_k - \\boldsymbol{r}_{k+1})}\\\\ \r \\, & 因为 \\boldsymbol{p}_{k-1} 与 \\boldsymbol{r}_{k} 相互共轭，\\boldsymbol{r}_{k+1} 与 \\boldsymbol{r}_{k} 相互共轭 \\\\\r = \\, & \\frac{\\boldsymbol{r}_{k+1}^{\\mathrm{T}}\\boldsymbol{r}_{k+1}}{\\boldsymbol{p}_{k}^{\\mathrm{T}}\\boldsymbol{r}_k}\\\\ \r = \\, & \\frac{\\boldsymbol{r}_{k+1}^{\\mathrm{T}}\\boldsymbol{r}_{k+1}}{\\boldsymbol{r}_{k}^{\\mathrm{T}}\\boldsymbol{p}_k}\\\\ \r = \\, & \\frac{\\boldsymbol{r}_{k+1}^{\\mathrm{T}}\\boldsymbol{r}_{k+1}}{\\boldsymbol{r}_{k}^{\\mathrm{T}}(\\boldsymbol{r}_k + \\beta_{k-1}\\boldsymbol{p}_{k-1})}\\\\ \r = \\, & \\frac{\\boldsymbol{r}_{k+1}^{\\mathrm{T}}\\boldsymbol{r}_{k+1}}{\\boldsymbol{r}_{k}^{\\mathrm{T}}\\boldsymbol{r}_k}\r \\end{aligned}\r 由此可得到共轭梯度法的一般过程：首先向量 $\\boldsymbol{x}$ 任意取一初值 $\\boldsymbol{x}{0}$，由 $\\boldsymbol{r}{0} = b - \\boldsymbol{A}\\boldsymbol{x}{0}$ 得到残差 $\\boldsymbol{r}{0}$，第一步的下山方向 $\\boldsymbol{p}{0} = \\boldsymbol{r}{0}$，根据式 6 更新向量 $\\boldsymbol{x}$： \r \\begin{aligned}\r \\boldsymbol{x}_1 = \\, & \\boldsymbol{x}_0 + \\alpha_0\\boldsymbol{p}_0\\\\ \r = \\, & \\boldsymbol{x}_0 + \\frac{\\boldsymbol{r}_0^{\\mathrm{T}}\\boldsymbol{r}_0}{\\boldsymbol{p}_0^{\\mathrm{T}}\\boldsymbol{Ap}_0}\\boldsymbol{p}_0\r \\end{aligned}\r 之后的第 $k+1$ 步 $（k \\geq 1）$，其上一步的残差 $\\boldsymbol{r}{k}$、新下山方向 $\\boldsymbol{p}{k}$、新的向量 $\\boldsymbol{x}_{k+1}$ 分别为： \r \\begin{aligned}\r \\boldsymbol{r}_{k} = \\, & \\boldsymbol{r}_{k-1} - \\frac{\\boldsymbol{r}_{k-1}^{\\mathrm{T}}\\boldsymbol{r}_{k-1}}{\\boldsymbol{p}_{k-1}^{\\mathrm{T}}\\boldsymbol{Ap}_{k-1}}\\boldsymbol{A}\\boldsymbol{p}_{k-1}\\\\ \r \\boldsymbol{p}_{k} = \\, & \\boldsymbol{r}_{k} - \\frac{\\boldsymbol{r}_{k}^{\\mathrm{T}}\\boldsymbol{r}_{k}}{\\boldsymbol{r}_{k-1}^{\\mathrm{T}}\\boldsymbol{r}_{k-1}}\\boldsymbol{p}_{k-1}\\\\ \r \\boldsymbol{x}_{k+1} = \\, & \\boldsymbol{x}_k + \\frac{\\boldsymbol{r}_k^{\\mathrm{T}}\\boldsymbol{r}_k}{\\boldsymbol{p}_k^{\\mathrm{T}}\\boldsymbol{Ap}_k}\\boldsymbol{p}_{k}\r \\end{aligned}\r 1.5 需要注意的地方 $\\boldsymbol{p}{k-1}$ 与 $\\boldsymbol{r}{k}$相互共轭 $\\boldsymbol{r}{k+1}$ 与 $\\boldsymbol{r}{k}$相互共轭 在共轭梯度法中，相邻的两次搜索得到的梯度相互正交 共轭梯度法依赖于线搜索，非精确线搜索不能保证共轭性和下降性 子空间扩展定理： \r \\boldsymbol{r}_{k}^\\mathrm{T}\\boldsymbol{p}_{j} = 0（j=0,1,...k-1）\r 二、预共轭梯度法 对矩阵 $\\boldsymbol{A}$ 进行预处理，减小 $\\boldsymbol{A}$ 的条件数，即 PCG 算法 包括 Cholesky 分解预处理、Jacobi 预处理等等 首先把矩阵A分为严格下三角，对角，以及严格上三角矩阵 \r \\boldsymbol{A} = \\boldsymbol{L} + \\boldsymbol{D} + \\boldsymbol{L}^\\mathrm{T}\r 那么 jacobi 预处理矩阵就是 $\\boldsymbol{A}$ 的对角矩阵 \r \\boldsymbol{M} = \\boldsymbol{D}\r 另外两种比较简单的预处理矩阵分别是 GaussSeidel 以及 SOR \r \\boldsymbol{M} = \\boldsymbol{L} + \\boldsymbol{D} \\\\\r \\boldsymbol{M} = \\frac{1}{\\omega}(\\boldsymbol{D}+\\omega\\boldsymbol{L})\r cholesky 分解 \r \\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^\\mathrm{T}，其中 \\boldsymbol{A} 是下三角矩阵\r 参考资料 https://blog.csdn.net/weixin_29732003/article/details/103433096 https://zhuanlan.zhihu.com/p/408993709 https://zhuanlan.zhihu.com/p/338838078 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-11-01 22:38:16 "},"about_Algorithm/":{"url":"about_Algorithm/","title":"算法整理","keywords":"","body":"About Algorithm 概述 常见算法模板 leetbook 奇妙操作 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-24 21:33:01 "},"about_Algorithm/概述.html":{"url":"about_Algorithm/概述.html","title":"概述","keywords":"","body":"参考资料 经典算法：https://github.com/nonstriater/Learn-Algorithms 数据结构与算法 基本算法 分治 动态规划 贪心算法 回溯 剪枝 枚举 排序 插入排序 直接插入排序 希尔排序 选择排序 选择排序 堆排序 交换排序 冒泡排序 交换排序 归并排序 桶排序 计数排序 基数排序 查找 顺序查找 有序表查找 二分查找 差值查找 斐波那契查找 线性索引查找 树查找 二叉 平衡：平衡二叉、红黑树 多路 散列表查找 散列函数 冲突处理 线性结构 线性表：数组、链表（单、双向） 链表 数组 内存不连续 内存连续 需要时再扩容 空间需要一次性分配足 删除某元素只需要移动指针 删除某元素则后续的元素均需要移动 特性 数组（Array） 链表（Linked List） 存储方式 连续存储 非连续存储，通过指针链接节点 访问速度 快速，O(1) 相对较慢，平均O(n) 大小固定 是，固定大小 否，动态大小 插入和删除 相对较慢，可能需要移动其他元素 相对较快，仅需要调整指针 空间效率 通常较好，无额外指针 相对较差，每个节点需要额外的指针空间 数组 元素在内存之中连续存储 元素可通过索引直接访问，访问速度快O(1) 数组大小无法动态改变 链表 由节点组成，节点包含数据和指针，不要求连续存储 访问需要逐个遍历，访问速度较慢O(n) 大小可以动态调整 字符串（KMP算法） KMP（Knuth-Morris-Pratt，三位提出者的名字）是一种高效的字符串匹配算法，用于在一个主文本串中查找一个模式串的出现位置。KMP算法在某些情况下具有更好的性能，特别是在模式串较长或者存在重复字符的情况下。 KMP算法的核心思想是：当发生不匹配时，利用已经匹配的部分信息，尽可能地减少比较的次数。构建一个部分匹配表，用于保存在模式串中每个位置的最长相等真前缀和后缀的长度。在主文本串中，当发生不匹配时，根据部分匹配表，可以将模式串移动到相对于主文本串的合适位置，而不是重新开始匹配。这样就能够提高匹配的效率。 def kmp_table(pattern): m = len(pattern) table = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = table[j - 1] if pattern[i] == pattern[j]: j += 1 table[i] = j return table def kmp_search(text, pattern): n = len(text) m = len(pattern) table = kmp_table(pattern) j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: # 匹配成功，返回匹配的起始位置 return i - m + 1 # 没有找到匹配，返回 -1 return -1 # 示例 text = \"ABABDABACDABABCABAB\" pattern = \"ABABCABAB\" result = kmp_search(text, pattern) if result != -1: print(f\"Pattern found at index {result}\") else: print(\"Pattern not found\") 栈 队列 哈希表 集合 图形结构 最短路径 最小生成树 拓扑排序 邻接矩阵/邻接表 遍历 深度优先 广度优先 树 二叉树 平衡二叉树 多路查找树 大小堆 字典树 并查集 Other base64编码表 1234567890 abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ +/ base58编码表少了6个，分别是0、大写O、大写I、小写l、+、/ 通过异或位运算交换两个变量的值，不需要中间变量 a ^= b; b ^= a; a ^= b; 可以简单理解为，第一步新的a中包含了原始a和b的特征，第二步中b与新的a进行异或位运算后只剩下原始a的特征，从而实现数值的交换 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-01 21:27:31 "},"about_Algorithm/常见算法模板.html":{"url":"about_Algorithm/常见算法模板.html","title":"常见算法模板","keywords":"","body":"常见算法模板 1、回溯2、贪心3、排序4、字符串、动态规划5、递归、动态规划6、二分查找7、深度优先搜索、二叉树8、字符串、哈希表9、滑动窗口10、栈和矩阵11、枚举12、并查集 回溯 模板 def backtrack(s, res, path): \"\"\" s一般是长度，比如n皇后问题就是对应的n res存放所有的结果 path存放可行的单个个体 \"\"\" if s==0 或者 s为空: #跳出条件 res.append(与path相关的内容) return for i in range(与s或者长度有关): #想象成一棵倒立的树，向下往枝叶延展 if ...: #设置回溯的筛选条件 backtrack(s, res, path) 典例 n_queens：https://leetcode.cn/problems/n-queens/ 贪心 一般可以将问题进行图形化，简化问题有时候需要从列表的两端进行分析 典例 分发糖果：https://leetcode.cn/problems/candy/ 盛最多水的容器：https://leetcode.cn/problems/container-with-most-water/ 排序 Python内置的堆 import heapq #默认是最小堆 class Solution: def findKthLargest(self, nums, k): maxHeap = [] for x in nums: heapq.heappush(maxHeap, -x) for i in range(k - 1): heapq.heappop(maxHeap) return -maxHeap[0] 将元素heappush进小根堆中，之后再heappop将元素从小到大弹出 heap[0]对应的元素是堆中最小的 若需要大根堆，则要在各元素前面加上负号 import heapq a = [] heapq.heappush(a, 10) heapq.heappush(a, 2) heapq.heappush(a, 8) heapq.heappush(a, 100) print(a) #[2, 10, 8, 100] for i in range(len(a)): print(heapq.heappop(a)) # 2、8、10、100 快速排序 import random class mysort(): def set_random_pivot(self, nums, low, high): \"\"\" 随机选择基准值 再将基准值与数组的第一个元素互换 \"\"\" pivot = random.randint(low, high) nums[low], nums[pivot] = nums[pivot], nums[low] return nums def partition(self, nums, low, high): \"\"\" 取出基准值 设置左右指针 先让right指针向左移动寻找小于基准值的位置 再让left指针向右移动寻找大于基准值的位置 之后将基准值放在left指向的位置 返回安放好的基准值的位置left \"\"\" pivot = nums[low] left, right = low, high while left =pivot: #注意这里的右指针是大于等于基准值时均可向左移动 right -= 1 nums[left] = nums[right] while left= high: #注意这个停止条件，low需要与high重合或者超过它 return # nums = self.set_random_pivot(nums, low, high) #随机选择基准值 ind = self.partition(nums, low, high) self.quickly_sort(nums, low, ind-1) #ind左侧排序 self.quickly_sort(nums, ind+1, high) #ind右侧排序 return nums nums = [3,2,1,5,6,4] nums = [3,2,3,1,2,4,5,5,6] mysort().quickly_sort(nums, 0, len(nums)-1) 典例 数组中的第k个最大元素：https://leetcode.cn/problems/kth-largest-element-in-an-array/ 字符串、动态规划 遇到两个字符串，根据它们求出符合条件的子串的问题考虑使用动态规划 class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -> int: m = len(text1) n = len(text2) # 创建dp数组 # 一般还需要关注边界的问题，长度+1 dp = [[0 for _ in range(n+1)] for _ in range(m+1)] #注意这里使用for循环创建，不要使用乘法 #乘法得到的嵌套列表各行的id是一样的，操作上会出现问题 for i in range(1, m+1): #注意这里从下标1开始 for j in range(1, n+1): # 分情况写出状态转移方程 if text1[i-1] == text2[j-1]: dp[i][j] = ... else: dp[i][j] = ... return dp[m][n] 递归、动态规划 典例：正则表达式匹配 from functools import lru_cache class Solution: @lru_cache(None) #利用缓存 def isMatch(self, s: str, p: str) -> bool: if not p: #正则表达式为空 return not s #查看当前字符串s是否匹配完毕 # 首先判断首字符是否匹配得到 first_match = (len(s)>0) and p[0] in {'.', s[0]} if len(p)>=2 and p[1]=='*': #判断存在*号的情况，*号可以匹配前一个字符n次或者0次 # 星号没有匹配 或者 匹配成功 return self.isMatch(s, p[2:]) or (first_match and self.isMatch(s[1:], p)) # 判断普通情况，字符是否相同 return first_match and self.isMatch(s[1:], p[1:]) 二分查找 r = ... left = 0 right = len(...)-1 temp = 0 while left 典例 528 按权重随机选择 深度优先搜索、二叉树 注意遍历方式，前序、中序、后序 def dfs(node): if not node: return ... # 递归左子树 left = dfs(node.left) # 递归右子树 right = dfs(node.right) return ... ... = dfs(root) 利用栈进行中序遍历 root = ... stack = [] res = [] while stack or root: if root: stack.append(root) root = root.left else: tmp = stack.pop() res.append(tmp.val) root = tmp.right return res 字符串、哈希表 class Solution: def groupAnagrams(self, strs): str_dic = dict() #创建字典充当哈希表 for i in strs: tmp = ''.join(sorted(i)) if tmp not in str_dic: #选择好字典的键、值 str_dic[tmp] = [i] else: str_dic[tmp].append(i) return [i for i in str_dic.values()] strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] print(Solution().groupAnagrams(strs)) 滑动窗口 有时候通过两个指针实现滑动的区间有时候是创建一个window列表存储在循环中不断更新窗口或者指针位置 #一般需要保存当前最优和全局最优 cur_len = 0 res = 0 #在循环中比较上述二者，以更新res 典例 1423 可获得的最大点数 3 无重复字符的最长子串 1004 最大连续1的个数 III 栈和矩阵 单调栈 stack = [...] for i in range(...): while len(stack) > 0 and anth[i][j] > stack[-1]: ... stack.pop() # while循环结束后，stack就是单调递减栈 ... stack.append(auth[i][j]) 枚举 当给定的数据范围很大时，考虑简化问题，缩小区间 典例 906 超级回文数 并查集 class UnionFindSet: \"\"\" 本质上是将两个对象关联起来，使得它们有了相同的祖先 \"\"\" def __init__(self, n): self.fa = [idx for idx in range(n)] self.count = n def find(self, x): if x != self.fa[x]: self.fa[x] = self.find(self.fa[x]) return self.fa[x] return x def union(self, x, y): x_fa = self.find(x) y_fa = self.find(y) if x_fa != y_fa: self.fa[y_fa] = x_fa self.count -= 1 # # # 参考：https://github.com/ls1248659692/leetcode 滑动窗口 滑动窗口是一种常用的算法思想，主要应用于数组和字符串的处理中。它可以把嵌套的循环问题，转换为单循环问题，降低时间复杂度 滑动窗口的基本思想是，维护一个固定大小的窗口，窗口通过不断滑动来遍历整个数据集合。在窗口内部进行某些操作，如求最大值、最小值、平均值等等 以求解数组连续子数组的和为例，滑动窗口可以通过维护左右指针来实现：初始时，左指针指向数组的第一个元素，右指针指向第 k 个元素（k 为窗口大小），窗口内的和为 S。然后，移动右指针，移动左指针，并再次更新窗口内的和，直到右指针到达数组的末尾，同时不断更新窗口内的和。这样，就可以得到所有长度为 k 的子数组的和 使用滑动窗口可以有效地解决一些数组和字符串相关的问题，特别是在需要 连续子数组或子字符串的问题 中，滑动窗口可以缩小搜索空间，减少不必要的操作，降低时间复杂度 # https://leetcode.com/problems/minimum-window-substring/solutions/26808/ from collections import Counter def sliding_window_template_with_examples(s, p): counter = Counter(p) start, end = 0, 0 count = 0 res = 0 while end 1: count += 1 end += 1 while count > 0: ''' update res here if finding minimum ''' counter[s[start]] -= 1 if counter[s[start]] > 0: count -= 1 start += 1 ''' update res here if finding maximum ''' res = max(res, end - start) return res 双指针 双指针算法的基本思路是，定义两个指针分别指向数组或链表中的不同位置，然后根据问题的要求不断移动这两个指针。通常情况下，移动的方向是相同的，即向前或向后，也有可能是相反的，即向中间靠拢，如求解最大回文子串的问题 在求解两数之和的问题中，双指针算法可以通过将数组排序，然后使用双指针从数组两端向中间移动来查找，时间复杂度可以降低到 O(n log n) 在求解三数之和的问题中，双指针算法通常需要先将数组排序，然后使用一个指针固定位置，再用另外两个指针分别从左右两端向中间移动，寻找符合要求的三个数之和，时间复杂度为 O(n^2) 在链表中使用双指针通常是为了找到链表中点或判断链表是否存在环。其中，找到链表中点的算法可以使用快慢指针，即使用一个指针每次走一步，另外一个指针每次走两步，当快指针走到链表末尾时，慢指针指向的节点即为链表中点。判断链表是否存在环也可以使用快慢指针，当快指针与慢指针相遇时，即可判断链表中存在环 双指针算法的优点在于 不需要额外的辅助空间，常常可以降低时间复杂度。但它也有一定的局限性，比如 无法处理存在多个解 的问题 # 双指针通常用在排好序的数组或是链表中寻找对子, 或者是 merge 或者是排序，或者去除 element，反正一般都是头尾各一个指针，然后根据条件移动 # 1. old & new state: old, new = new, cur_result # 新旧指针迭代 # 2. slow & fast runner: slow-> fast->-> # 快慢指针 # 3. left & right boundary or index: left-> p2-> # 不同序列上的指针 # 5. start & end sliding window boundary: start-> end-> # 滑动窗口的指针 快慢指针链表 快慢指针是处理 linked list 链表常用的套路，通常是用来 判断成环 以及 环的入口，或者是寻找 list 中 第 k 个元素 原地链表翻转 注意 Python 中 ..., ... = ..., ... 这种形式的赋值！ # 迭代翻转 def reverse_iteratively(head: ListNode): prev, cur = None, head while cur: # 先改变链表指向，然后 pre 和 cur 指针分别向前移动一格 cur.next, cur, prev = prev, cur.next, cur #注意这里赋的值应该是该式子之前出现的变量值 return prev # 递归翻转 def reverse_recursively(head: ListNode): def recursive(cur, pre=None): if not cur: return pre # pre 指针先指向 cur 节点的下一节点防止丢失 # 然后 cur 再指向原先 pre 的位置 pre, cur.next = cur.next, pre return recursive(pre, cur) return recursive(head) 集合查找 字符串 DFS # 递归实现深度优先搜索，常用 def dfs_recursively(self, node, visited: set): visited.add(node) ''' process current node logic here ''' self.process_logic(node) #处理节点数据 for next_node in node.get_successors(): if next_node not in visited: self.dfs_recursively(next_node, visited) #进入递归 # 迭代实现深度优先搜索，不常用 def dfs_iteratively(self, root): stack, visited = [root], set() while stack: #利用栈来存储节点 node = stack.pop() visited.add(node) ''' process current node logic here ''' self.process_logic(node) #处理节点数据 for next_node in node.get_successors(): if next_node not in visited: stack.append(next_node) #栈先进后出的特点 BFS BFS 通常采用 queue 队列来实现，用列表也是类似的，但是最后不是append而是将节点直接加进列表 from collections import deque # 迭代实现广度优先搜索，常用 def bfs_iteratively_by_queue(self, start, target=None): queue, visited = deque([start]), {start} while queue: #以队列是否为空为循环停止的标准 node = queue.popleft() #左出队列 visited.add(node) #将搜索过的节点进行保存，注意这里的 set 使用 add 加入 ''' process current node logic here ''' self.process_logic(node) #处理节点数据 # target is optional if node == target: ''' reach the goal and break out ''' self.process_target_logic(target) break for next_node in node.get_successors(): #获取节点的后继 if next_node not in visited: queue.append(next_node) #没有搜索过就将其加入队列中 # 递归实现广度优先搜索 def bfs_recursively(self, queue: deque, visited: set, target=None): if not queue: #队列为空，递归结束的标志 return node = queue.popleft() visited.add(node) ''' process current node logic here ''' self.process_logic(node) #处理节点数据 # target is optional if node == target: ''' reach the goal and break out ''' self.process_target_logic(target) return for next_node in node.get_successors(): if next_node not in visited: queue.append(next_node) self.bfs_recursively(queue, visited) #在最后再调用自身，这里传入的队列和已访问过的节点集合都更新过了 # 二叉树的 BFS def bfs_row(self, root): row = [root] while row: ''' process current node logic here ''' # process logic separately row = [child for node in row for child in (node.left, node.right) if node] #这个双重 for 循环取出每个节点的左右子节点，并存入列表 row 中 回溯法 双堆模式 二分法与二分法变种 当你需要解决的问题的输入是排好序的数组，链表，或是排好序的矩阵，要求咱们寻找某些特定元素。这个时候就可以选择二分搜索 # 在 [ , ] 的区间上寻找 def binary_search(arr, target): lo, hi = 0, len(arr) - 1 while lo target: hi = mid else: lo = mid + 1 ''' return lo #注意结果取的是左侧的 lo 前 K 大的数模式 HEAP 采用 priority queue 或者说在 python 中的 heapq 求 top k 采用 最小堆（默认） 采用 最大堆 的时候可以采用 push 负的 value import heapq def heap_operations(): heap = [4, 2, 1, 3] # heapify heapq.heapify(heap) # top top = heap[0] # heappop top = heapq.heappop(heap) # heappush heapq.heappush(heap, 5) # heappushpop = push + pop heapq.heappushpop(heap, 0) # heapreplace = pop + push heapq.heapreplace(heap, 0) data = [10, 5, 18, 2, 37, 3, 8, 7, 19, 1] heapq.heapify(data) old, new = 8, 22 # increase the 8 to 22 i = data.index(old) data[i] = new # _siftup, from root to leaf, when increase heapq._siftup(data, i) old, new = 10, 4 # decrease the 10 to 4 i = data.index(old) data[i] = new # _siftdown, from leaf to root, when decrease heapq._siftdown(data, 0, i) # find n largest by queue 从队列中找出前 n 个最大的 heapq.nlargest(data, 3) # find n smallest by queue heapq.nsmallest(data, 3) # Merge multiple sorted inputs into a single sorted output # e.g. merge timestamped entries from multiple log files heapq.merge([1, 3, 5, 7], [0, 2, 4, 8], [5, 10, 15, 20], [], [25]) 分治思想 DP 动态规划 通过 递归方式 将复杂问题分解为更简单的 子问题 来简化它 状态定义、状态转换方程、最优子结构 排序算法 import random import time from collections import deque from collections import defaultdict # 快速排序 def quick_sort(arr): quick_sort_rec(arr, 0, len(arr) - 1) # 注意区间为 [lo, hi] def quick_sort_rec(arr, lo, hi): if lo > 1], lo + hi >> 1)))[1] # 下面为 x 找到合适的位置放置 arr[lo], arr[idx] = arr[idx], arr[lo] while lo = x: #找到小于x的元素，它需要放置到前面去 hi -= 1 arr[lo] = arr[hi] while lo # 合并排序 链表 二叉搜索树的构建 位运算 dict stack/queue def stack_operations(): # initialization stack = [] # 栈的大小 size = len(stack) # 压栈 stack.append(1) # 检查栈是否为空 if stack: # 栈顶 top = stack[-1] # 出栈 stack.pop() math array def list_operations(): # initialization list1 = [3, 1, 2, 4] list2 = list(range(5)) # [*X] equals to list(X) list2 = [*range(5)] #注意这个用法 # append list1.append(5) list1 += [5] list1 += 5, list1.extend([5, 6]) # insert list1.insert(0) # index list1.index(3) # count list1.count(3) # remove list1.remove(3) #remove里面传入的是值，还是下标？ # sort list1.sort(reverse=True) # reverse list1.reverse() #翻转数组 图 贪婪算法 matrix 一般算法题模板 数和链表结合 from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # 先序遍历: root->left->right def preorder_traversal_recursively(self, root: 'TreeNode'): # recursion terminator here # you can check if none when add left and right child, it will decrease one recursion depth, # but you have to check whether root is None outside. if not root: return ''' add current node logic here ''' self.process_logic(root) self.preorder_traversal_recursively(root.left) self.preorder_traversal_recursively(root.right) # 中序遍历: left->root->right def inorder_traversal_recursively(self, root: 'TreeNode'): if not root: return self.inorder_traversal_recursively(root.left) ''' add current node logic here ''' self.process_logic(root) self.inorder_traversal_recursively(root.right) # 后序遍历: left->right->root def postorder_traversal_recursively(self, root: 'TreeNode'): if not root: return self.postorder_traversal_recursively(root.left) self.postorder_traversal_recursively(root.right) ''' add current node logic here ''' self.process_logic(root) # 注意三种遍历的 process_logic 所在的位置 # 递归可以想象成左栈右堆的形式，递归主要使用栈，每一层递归就是朝栈中不断往上叠加，直到满足停止条件再逐层去除，若还有多个递归，就想象成当前层往右扩展出一个，若退出了就回到前一个递归的上一层 字符串 import string # 从字符串的右侧寻找第一个 a 的下标 s.rfind('a') # 字符串中某个字符出现的次数 s.count('a') # 字符串的开头结尾 s.startswith('a') s.endswith('b') # 字符串根据某个规则进行转换 intab = \"aeiou\" outtab = \"12345\" trantab = str.maketrans(intab, outtab) s.translate(trantab) s.ljust(10) #右侧添加填充字符，默认是空格 s.rjust(10) s.center(10) #居中 s.zfill(10) #返回指定长度的字符串，原字符串右对齐，前面填充 0 string.punctuation #所有的标点字符 string.whitespace #所有的空白字符 string.ascii_lowercase #所有的小写字符 string.hexdigits #所有的十六进制字符 string.printable #给出所有的标点符号，数字，ascii_letters和空格 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-15 23:58:57 "},"about_Algorithm/leetbook.html":{"url":"about_Algorithm/leetbook.html","title":"leetbook","keywords":"","body":"动态规划 组合子问题的解，得到原问题的解 特性： 1、在第一次求解子问题的时候，会将 子问题的解保存 后续需要用的时候直接 查表获取，保证每个独立子问题只被计算一次 2、不断 组合、选择 子问题的最优解，最终得到原问题的最优解（前提是该问题的最优解可以由其子问题的最优解组合构成，称为 最优子结构），设计状态转移方程 斐波那契数列（不涉及特性2，因为不需要选择最优组合） [0, 1, 1, 2, 3, 5, 8, ...] 当前数等于前两个数之和 # 暴力递归求第 n 个斐波那契数 def fibonacci(n): if n == 0: return 0 # 返回 f(0) if n == 1: return 1 # 返回 f(1) return fibonacci(n - 1) + fibonacci(n - 2) # 分解为两个子问题求解 # 过程中，子问题出现了重复计算的现象，时间复杂度很高 # 记忆化递归 def fibonacci(n, dp): if n == 0: return 0 # 返回 f(0) if n == 1: return 1 # 返回 f(1) if dp[n] != 0: return dp[n] # 若 f(n) 以前已经计算过，则直接返回记录的解 dp[n] = fibonacci(n - 1, dp) + fibonacci(n - 2, dp) # 将 f(n) 则记录至 dp return dp[n] # 求第 n 个斐波那契数 def fibonacci_memorized(n): dp = [0] * (n + 1) # 用于保存 f(0) 至 f(n) 问题的解 return fibonacci(n, dp) # 应用记忆化递归方法后，递归树中绝大部分节点被剪枝 # 降低了时间复杂度 递归本质上是基于分治思想的 从顶至底 的解法。借助记忆化递归思想，可应用动态规划 从底至顶 求取 f(n) def fibonacci(n): if n == 0: return 0 # 若求 f(0) 则直接返回 0 dp = [0] * (n + 1) # 初始化 dp 列表 dp[0], dp[1] = 0, 1 # 初始化 f(0), f(1) for i in range(2, n + 1): # 状态转移求取 f(2), f(3), ..., f(n) dp[i] = dp[i - 1] + dp[i - 2] return dp[n] # 返回 f(n) # 优化空间复杂度 def fibonacci(n): if n == 0: return 0 # 若求 f(0) 则直接返回 0 a, b = 0, 1 # 初始化 f(0), f(1) for i in range(2, n + 1): # 状态转移求取 f(2), f(3), ..., f(n) a, b = b, a + b return b # 返回 f(n) 子问题包含更小的子问题；具有最优子结构。满足这两点就可以考虑使用动态规划 求解步骤： 1、定义问题的状态：一维 dp 列表，设第 i 个斐波那契数为 dp[i] ； 2、确定初始状态，即已知解：已知第 0 , 1 个斐波那契数分别为 dp[0]=0 , dp[1]=1 ； 3、确定原问题和子问题之间的关系，列出转移方程：后一个数字等于前两个数字之和，即 dp[i]=dp[i−1]+dp[i−2] 4、确定何处停止迭代并返回值：需求取的第 n 个斐波那契数 dp[n] ； Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-09 22:11:46 "},"about_Algorithm/奇妙操作.html":{"url":"about_Algorithm/奇妙操作.html","title":"奇妙操作","keywords":"","body":"奇妙操作 位运算 位运算是一种对二进制数进行操作的运算方式，常用于优化算法和提高代码效率 与运算（&）：同为1则为1，其他为0 可以用来将某些位设置为0，例如将一个数的 最低位清零 可以用 n = n & (n-1)。这个技巧可以用于判断一个数是否为2的幂 例如：n的二进制表示为1000，则n-1的二进制表示为0111，故与运算的结果为0，说明n是2的幂 或运算（|）：有1为1 可以用来将某些位设置为1，例如将一个数的 最低位设置为1 可以用 n = n | 1 异或运算（^）：相同为0，不同为1 可以用来 交换两个数的值，例如a = a ^ b, b = a ^ b, a = a ^ b。此外，异或运算还可以判断两个数是否相等，如果两个数异或结果为0，则说明两个数相等 左移运算（）：可以将一个数的所有位向左移动指定的位数，例如 n 将n的二进制表示左移k位 右移运算（>>）：可以将一个数的所有位向右移动指定的位数，例如 n >> k 将n的二进制表示右移k位 取反运算（~）：可以将一个数的所有位取反，即0变为1，1变为0 判断奇偶性：可以用 n & 1 来判断一个数的奇偶性，如果结果为1，则说明n是奇数，如果结果为0，则说明n是偶数 清除末尾的1：如果n的二进制表示中最右边的值为1，可以用 n = n & (n-1) 来清除它 获取最低位的1：可以用 n & -n 来获取一个数的二进制表示中最右边的1例如：假设我们要获取数字 n = 12 的二进制表示中最右边的1。首先，我们将 n 的二进制表示写出来：n = 12: 1100接下来，我们需要找到最右边的1所在的位置。为了实现这个目标，我们可以使用 n & -n 的运算。其中 -n 是 n 的补码，即 n 的反码加1。我们可以将 -n 的二进制表示写出来：-n = -12: 0011（反码），故补码为：-n = -12: 0100接下来，我们将 n 和 -n 进行按位与运算：n & -n = 1100 & 0100 = 0100 即获取到了 1100 的最右边的1 线段树 维护区间信息，例如：给区间中每一个数加1，或者求和线段树是二叉树，父结点代表区间的和，往下的子结点代表分隔后的不同区间结点的id从1开始，则其左子结点的id是2，右子结点的id是2+1重点是懒标记在线段树中引入懒标记后，更新操作分为两个阶段：下推（Push Down）和上提（Pull Up）。下推阶段发生在需要更新某个节点的子节点时，更新操作不直接应用到子节点，而是将更新信息暂时存储在父节点的懒标记中，表示这个区间需要被更新。上提阶段发生在查询时，当需要用到某个节点的值时，会首先检查该节点的懒标记，如果存在懒标记，就将更新操作应用到当前节点和其子节点，然后清除懒标记。 class Solution: def handleQuery(self, nums1, nums2, queries): n = len(nums1) m = len(queries) seg_tree = SegTree(nums1) total = sum(nums2) ans = [] for i in range(m): if queries[i][0] == 1: l = queries[i][1] r = queries[i][2] seg_tree.reverse_range(l, r) elif queries[i][0] == 2: total += seg_tree.sum_range(0, n - 1) * queries[i][1] elif queries[i][0] == 3: ans.append(total) return ans class SegNode: def __init__(self): self.l = 0 self.r = 0 self.sum = 0 self.lazytag = False class SegTree: def __init__(self, nums): n = len(nums) self.arr = [SegNode() for _ in range(n * 4 + 1)] self.build(1, 0, n - 1, nums) def sum_range(self, left, right): return self.query(1, left, right) def reverse_range(self, left, right): self.modify(1, left, right) def build(self, id, l, r, nums): arr = self.arr arr[id] = SegNode() arr[id].l = l arr[id].r = r arr[id].lazytag = False if l == r: arr[id].sum = nums[l] return mid = (l + r) >> 1 self.build(2 * id, l, mid, nums) self.build(2 * id + 1, mid + 1, r, nums) arr[id].sum = arr[2 * id].sum + arr[2 * id + 1].sum # pushdown函数：下传懒标记，即将当前区间的修改情况下传到其左右孩子结点 def pushdown(self, x): arr = self.arr if arr[x].lazytag: arr[2 * x].lazytag = not arr[2 * x].lazytag arr[2 * x].sum = arr[2 * x].r - arr[2 * x].l + 1 - arr[2 * x].sum arr[2 * x + 1].lazytag = not arr[2 * x + 1].lazytag arr[2 * x + 1].sum = arr[2 * x + 1].r - arr[2 * x + 1].l + 1 - arr[2 * x + 1].sum arr[x].lazytag = False # 区间修改 def modify(self, id, l, r): arr = self.arr if arr[id].l >= l and arr[id].r > 1 if arr[2 * id].r >= l: self.modify(2 * id, l, r) if arr[2 * id + 1].l = l and arr[id].r r: return 0 self.pushdown(id) mid = (arr[id].l + arr[id].r) >> 1 res = 0 if arr[2 * id].r >= l: res += self.query(2 * id, l, r) if arr[2 * id + 1].l Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-16 22:25:44 "},"about_Linux/":{"url":"about_Linux/","title":"Linux 整理","keywords":"","body":"About Linux 常用语句 常见问题 shell脚本 磁盘扩容 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-03 22:34:12 "},"about_Linux/常用语句.html":{"url":"about_Linux/常用语句.html","title":"常用语句","keywords":"","body":"Linux常用语句 一、基本命令 1.1 关机和重启 关机shutdown -h now或者poweroff 重启shutdown -r now或者reboot 1.2 帮助 help命令某指令 --help 命令说明书man 某指令，按q可以退出说明书 二、目录操作命令 2.1 目录切换 cd /，回到根目录cd /usr，切换到/usr文件夹下cd ../，切换到上一级目录cd ~，切换到home目录cd -，切换到上次访问的目录 2.2 目录查看 ls，查看当前目录下的所有目录和文件ls -a，查看当前目录下的所有目录和文件，包括 隐藏文件ls -l 或者 ll，查看当前目录下的所有目录和文件，包含详细信息，例如 权限、owner、group、创建更新时间ls /usr，查看指定的/usr目录下的所有目录和文件 2.3 目录操作 mkdir aaa，在当前目录下创建文件夹aaamkdir /usr/aaa，在/usr目录下创建文件夹aaarm -rf 文件或者目录，删除文件或者目录mv 当前名称 新名称，重命名，也可以用于剪切cp -r 某个文件 新的位置，复制文件到某个位置find /usr/tmp -name 'a*'，查找/usr/tmp 目录下所有以a开头的文件或目录tree，将目录以树形的结构展现出来 三、文件操作命令 3.1 常用命令 新建文件 touch 文件名 删除文件 rm -rf 文件名 修改文件 推荐先下载一个 vim 编辑器： sudo apt update sudo apt upgrade sudo apt install vim 三种模式： command mode 按 Esc 进入 按两次 d，删除整行 x，删除单个字符 / 字符，查询字符 insert mode 按 i/a/o 进入 i，当前光标所在字符的 前面 开始编辑 a，当前光标所在字符的 后面 开始编辑 o，当前光标所在字符的下面 另起一行 开始编辑 last line mode 输入 : 进入 wq!，保存修改并退出 q!，不保存修改直接退出 查看文件 cat 若文件内容过长，则只能显示最后一屏的内容 more 查看文件 可以显示百分比 回车，下一行 空格，下一页 q，退出 less 翻页查看 tail 指定行数或者动态查看 tail -10 文件名，查看文件的后10行 Ctrl + C，退出 3.2 权限修改 形如 - --- --- ---第1位：可以是 -、d、l、b、c、s、p 等等，表示文件类型第2、3、4位：拥有者的权限（user）第5、6、7位：拥有者所在组中，组员的权限（group）第8、9、10位：其他用户的权限（other）rwx：r表示可读，w表示可写，x表示允许执行的权限chmod 700 文件名，给文件修改权限700，表示仅user可读、可写、可执行，将2、3、4位设想成长度为三的二进制数，全为1即7，其他为0 3.3 chmod 和 chown chmod 修改文件（夹）访问权限chown 修改文件（夹）用户名和用户组 四、压缩文件操作 4.1 打包和压缩 Windows的压缩文件的扩展名：???.zip 或者 ???.rarLinux中的打包文件：???.tarLinux中的压缩文件：???.gzLinux中打包并压缩的文件：???.tar.gz一般情况下打包和压缩是一起进行的 tar -zcvf 打包压缩后的文件名 要打包的文件 其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 zip 压缩 apt update && apt install -y zip zip -r mydir.zip mydir/，将 mydir 文件夹中的内容压缩成 mydir.zip 4.2 解压 tar -zxvf 要解压的文件 -C 解压到的位置 其中： x：代表解压 C：指定解压的位置 unzip 解压 unzip 需要解压的zip文件 五、查询命令 5.1 grep ps -ef | grep 某服务，查找指定服务的进程 5.2 find find . -name \"*.log\" -ls，查询当前目录下所有以.log结尾的文件，并显示详细信息find . -type f -name \"*.log\"，查询当前目录下所有以.log结尾的普通文件find . -type d | sort，查询当前目录下所有文件夹，并排序find . -size +100M，查询当前目录下所有大小超过100M的文件find . -perm 600，查询当前目录下所有权限为600的文件 5.3 whereis 用于定位可执行文件、源代码文件、帮助文件例如：whereis ls 5.4 which 在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个例如：which java 六、用户相关 6.1 su 用于用户之间的切换，但是切换前的用户仍旧保持登录状态root用户向普通用户切换不用密码普通用户切换成任何用户都需要密码su - test，切换到test用户su，切换到root用户exit，返回之前的用户 6.2 sudo 是为了所有想使用root权限的普通用户设计的，可以让普通用户临时拥有root权限赋予用户权限：hadoop ALL=(ALL) ALL，允许hadoop用户使用root的所有权限，但是需要输入用户自己的密码hadoop ALL=(NOPASSWD): /bin/ls, /bin/cat，允许hadoop用户使用root权限执行ls和cat，且不需要密码 6.3 新建用户 sudo adduser 新的用户名sudo adduser 新的用户名 sudoreboot若要删除旧的用户sudo deluser 旧的用户名 七、系统服务 service iptables status，查看iptables服务的状态，或者 sudo systemctl status iptablesservice iptables start，开启iptables服务，或者 sudo systemctl start iptablesservice iptables stop，停止iptables服务，或者 sudo systemctl stop iptablesservice iptables restart，重启iptables服务，或者 sudo systemctl restart iptableschkconfig iptables off，关闭iptables服务的开机自启动chkconfig iptables on，开启iptables服务的开机自启动 八、网络管理 8.1 主机名配置 vi /etc/hostname 8.2 IP地址配置 无 8.3 域名映射 用于在通过主机名进行访问时，起到 IP 地址解析的作用vi /etc/hosts添加 IP地址1 主机名1 IP地址2 主机名2 ... 九、定时任务指令crontab的配置 9.1 安装 crontab是Unix和Linux用于设置定时任务的指令通过crontab命令，可以在固定间隔时间，执行指定的系统指令或shell脚本时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合安装：apt install cron启动：service cron start重启：service cron restart停止：service cron stop 9.2 使用 crontab file [-u user]，用指定的文件替代目前的crontabcrontab -l [-u user]，列出用户目前的crontabcrontab -e [-u user]，编辑用户目前的crontab 命令解析 命令：* * * * * command 解释：分 时 日 月 周 命令 第1列表示分钟1～59 每分钟用 * 或者 */1 表示 第2列表示小时0～23（0表示0点） 第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令 实例 先打开定时任务所在的文件： crontab -e 每分钟执行一次date命令 */1 * * * * date >> /root/date.txt 每晚的21:30重启apache。 30 21 * * * service httpd restart 每月1、10、22日的4 : 45重启apache。 45 4 1,10,22 * * service httpd restart 每周六、周日的1 : 10重启apache。 10 1 * * 6,0 service httpd restart 每天18 : 00至23 : 00之间每隔30分钟重启apache。 0,30 18-23 * * * service httpd restart 晚上11点到早上7点之间，每隔一小时重启apache * 23-7/1 * * * service httpd restart 十、其他命令 10.1 查看当前目录 pwd 10.2 进程 ps -ef，查看当前进程kill -9 pid，杀死进程，需要对应的 pid 10.3 网络通信命令 ifconfig 或者 ifconfig | more，查看网卡信息ping IP地址查看与某台机器的连接情况netstat -an，查看当前系统端口netstat -nltp，可以在后面加入 | grep 需要查找的端口号 来进行筛选查找 10.4 关闭防火墙 sudo ufw disable 10.5 清屏 Ctrl + l 10.6 vi的快捷键 首先，处于command mode下，即按下 Esc 键shift + G，光标跳到最后一行shift + Z + Z，保存并退出yy，复制一行dd，删除一行p，粘贴u，撤销 10.7 后台运行 末尾加 &，配合 nohup 使用 10.8 查看进程的cpu和内存占用率 top，高负载(CPU使用率高)的情况一般都会排在最上边 10.9 卸载软件 rpm -aq，可以查看已安装的软件名sudo apt --purge remove 需要卸载的软件名sudo apt clean 10.10 配置环境变量 添加环境变量，可以方便调用指令，否则需要输入完整路径才能使用，例如： export PATH=/x/x/x/miniconda3/bin:$PATH 上述中，右侧的路径可以写多个，以 : 分隔 $PATH 表示求 PATH 变量的值，因为 PATH 环境变量以前可能已经有值，需要保留那些值不影响其他命令的使用 其次当输入了 python 命令时，会从 PATH 环境变量的路径下去找 python 可执行文件，先找到哪个就用哪个，因此前后路径的先后顺序也很重要 最后以上设置的环境变量只在当前 terminal 的上下文中有效 如果希望全局有效，那么需要将 export 命令写入文件： 例如新建并写入文档 myenv.sh export OS_SOMETHING=default 保存后执行 source myenv.sh 查看已有环境变量：env | grep OS、env | grep PATH 10.11 重定向 一文详解 输入重定向 文本或者结果丢给命令，包括 命令 命令 命令 文本 2，将文本 1 作为输入给命令，执行结果输出的文本 2 中 输出重定向 命令 > 文本，命令执行后的 标准输出 写入到文本中（清空原本的） 命令 >> 文本，命令执行后的 标准输出 写入到文本中（追加写入） 命令 2> 文本，命令执行后的 报错信息 写入到文本中（清空原本的） 命令 2>> 文本，命令执行后的 报错信息 写入到文本中（追加写入） 命令 >> 文本 2&>1，命令执行后的 标准输出或者报错信息 写入到文本中（追加写入） 命令 &>> 文本，命令执行后的 标准输出或者报错信息 写入到文本中（追加写入） 总结：双箭头是追加不清空、2是错误信息、2&>1 是固定写法 10.12 关于文件权限 一文详解 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-08-13 11:41:36 "},"about_Linux/常见问题.html":{"url":"about_Linux/常见问题.html","title":"常见问题","keywords":"","body":"Linux常见问题 设置 su 的密码 sudo passwd root 之后会让输入新的密码 查看某内容 something 在文件 filename 中的第几行 grep -rn something filename 系统有多个 python 的情况 Ubuntu 系统一般自带 python2，若下载了 python3 该怎么切换版本呢？1、删除软连接 sudo unlink /usr/bin/python sudo unlink /usr/bin/python3 2、将 python 连接到 python3.8（或者其他版本）sudo ln -s /usr/bin/python3.8 /usr/bin/python或者sudo ln -s /usr/bin/python3.8 /usr/bin/python3 && sudo ln -s /usr/bin/python2.7 /usr/bin/python注意 python 都安装在 /usr/bin 目录里，python 的库安装在 /usr/local/lib/python xx 里面（xx为版本号） 关机方式 不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中推荐关机方式 sync shutdown -h now 重启 reboot 使计算机将在10分钟后关机 shutdown –h 10 git clone 太慢怎么办 重置 git 代理git config --global --unset http.https://github.com.proxy 查看安装了哪些软件 apt list | grep ???dpkg list或者rpm -qadpkg -l 卸载应用 sudo apt-get --purge remove 应用名 防火墙 sudo ufw statussudo ufw enable，开启防火墙sudo ufw disable，关闭防火墙 安装 java sudo apt install openjdk-8-jdk-headless whereis jvm cd /usr/lib/jvm cd java-8-openjdk-amd64/ ls 环境变量设置： vi ~/.bashrc 添加： export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 export JRE_HOME=/usr/lib/jvm/java-8-openjdk-amd64/jre 无法复制粘贴的问题 sudo apt autoremove open-vm-tools sudo apt install open-vm-tools sudo apt install open-vm-tools-desktop 设置子网和主机名 https://zhuanlan.zhihu.com/p/455097916打开VMware编辑中的虚拟网络编辑器，点击更改设置并使用管理员权限VMnet0确认为桥接模式选中VMnet8，选择NAT模式，自行对子网IP进行修改，例如：192.168.10.0，再点击NAT设置，修改网关IP，例如：192.168.10.2，点击确定打开控制面板，点击查看网络状态和任务，点击左侧的更改适配器设置，双击VMnet8，点击属性，双击Internet协议版本4，修改默认网关、首选DNS服务器使其和上面VMware中的一样，备用DNS服务器为8.8.8.8，点击确定打开虚拟机的终端，修改hostname和hosts文件vim /etc/hostnamevim /etc/hosts Ubuntu看这里 sudo vim /etc/netplan/里面的文件 network: version: 2 renderer: NetworkManager ethernets: ens33: #配置的网卡名称 dhcp4: no #dhcp4关闭 dhcp6: no #dhcp6关闭 addresses: [192.168.10.101/24] #设置本机IP及掩码 gateway4: 192.168.10.2 #设置网关 nameservers: addresses: [192.168.10.2, 8.8.8.8] #设置DNS CentOS看这里 sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33 修改BOOTPROTO=static，ONBOOT=yes，添加IPADDR、GATEWAY、DNS1 pip 利用阿里云镜像加速 pip3 install opencv-python -i http://mirrors.aliyun.com/pypi/simple --trusted-host mirrors.aliyun.com Ubuntu 系统的初始配置 sudo apt updatesudo apt upgrade修改 hostname配置固定的IP地址设置中文安装ifconfig，sudo apt install net-tools安装vim，sudo apt install vim 如何实现免密登录？ grep的用法 https://www.runoob.com/linux/linux-comm-grep.html Nginx 安装配置 FTP 安装配置 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-14 22:00:27 "},"about_Linux/shell脚本.html":{"url":"about_Linux/shell脚本.html","title":"shell脚本","keywords":"","body":"shell 脚本 一、shell 简介 shell 脚本是解释型语言（C 语言是编译型语言），是 shell 命令的有序集合 1.1 主要步骤 （1）建立 shell 文件 vi filename.sh 输入：date （2）赋予 shell 文件执行权限 chmod 740 filename.sh 或者 chmod u+x filename.sh （3）执行 shell 文件 ./filename.sh 1.2 shell 变量 （1）用户自定义变量支持创建变量存储数据，但是不支持数据类型，任何赋给变量的值都是字符串 COUNT=1 echo ${COUNT} 设置只读变量： myUrl=\"https://www.google.com\" readonly myUrl 删除变量用： unset COUNT 字符串 单引号，只会原样输出双引号，里面可以有变量，可使用转义字符 - 获取字符串长度 `echo ${#string}` - 截取字符串（注意下标从0开始） `echo ${string:1:4}` 数组 只支持一维数组，但是各个元素的类型可以不一致，可以使用非连续的下标，且没有范围限制 array_name=(value0 value1 value2 value3) echo ${array_name[0]} #获取第一个元素 echo ${array_name[@]} #获取所有元素 关联数组 #!/bin/bash declare -A site #定义一个关联数组site（键值的形式） site[\"google\"]=\"www.google.com\" site[\"runoob\"]=\"www.runoob.com\" site[\"taobao\"]=\"www.taobao.com\" 注意：等号两边不能加空格；通常使用全大写变量 （2）位置变量赋予命令行参数$#，输出参数个数$@，输出所有参数，但是各个参数分开$*，输出所有参数，但是作为一个整体$?，输出前一个命令的结果$$，输出正在执行的进程的 ID 号 （3）预定义变量赋予对应位置的参数${0}、${1}...... #!/bin/bash echo \"Shell 传递参数实例！\"; echo \"执行的文件名：$0\"; echo \"第一个参数为：$1\"; echo \"第二个参数为：$2\"; echo \"第三个参数为：$3\"; $ chmod +x test.sh $ ./test.sh 1 2 3 Shell 传递参数实例！ 执行的文件名：./test.sh 第一个参数为：1 第二个参数为：2 第三个参数为：3 （4）环境变量PATH=...HOME=...IFS=...TERM=... 二、shell 语句 有三大语句：说明性语句、功能性语句、结构性语句 2.1 说明性语句 用于注释 # 这是说明 多行注释 : 2.2 功能性语句 （1）read var从标准输入读入一行，并赋值给 var若标准输入无数据，则会等待，直到数据到来或者程序被终止也可以类似 Python 解包的形式 read var1 var2 var3 （2）expr \\( 10 + 10 \\) \\* 2即计算 (10+10)*2，结果为 40，注意需要有反斜杠作为转义字符，运算符之间要 有空格表达式需要用反引号将表达式围起来 （3）测试语句test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试test \"$answer\" = \"yes\"，检查变量 answer 是否为字符串 yestest $num -eq 18，检查变量 num 的值是否等于 18test -d tmp，检查 tmp 是否是变量名注意 相等为 0，不等为 1，在 shell 语言中 0 代表 true，0 以外的值代表 false 数值测试 -eq，相等，等同于 == -ne，不等 -gt，大于 -ge，大于等于 -lt，小于 -le，小于等于 字符测试 = 相同，注意只有一个等号 != 不相等 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 文件测试 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 ...... 布尔运算符 ! 非，[! False] -a 与，[ $a -lt 20 -a $b -gt 100 ] 等同于 [[ $a -lt 20 && $b -gt 100 ]] -o 或，[ $a -lt 20 -o $b -gt 100 ] 等同于 [[ $a -lt 20 || $b -gt 100 ]] 优先度：! > -a > -o （4）echo、printfecho \"...\" > myfile 显示结果定向至文件若不希望在屏幕上显示输出结果，则可以将输出重定向到 /dev/null：$ command > /dev/nullprintf 功能和 echo 差不多，但是需要自己手动添加换行 \\n语法是 printf 格式 [参数...] 2.3 结构性语句 （1）分支语句 条件语句经常与 test 命令结合使用 #! /bin/bash if [ $# -ne 1 ] #如果输入的参数个数不等于 1 则执行 then # 等同于 if (( $# -ne 1 )) then echo \"usage : $0 filename\" exit fi 配合 else、elif 语句： if condition1 then command1 elif condition2 then command2 else commandN fi 多路分支语句（类似 switch case 语句） #! /bin/bash echo -n \"please choose (yes|no)?\" read R case $R in #注意 in yes | Yes | y | Y | YES) echo \"yes\" ;; #表示 break 跳出 case no | No | n | N | NO) echo \"no\" ;; *) echo \"wrong\" esac （2）循环语句 for 循环 #! /bin/bash for I in `seq 1 2 10` do echo \"$I\" done # 循环输出1到10，且步长为2 do 循环实例：实现拷贝当前目录下的所有文件到 backup 子目录下``` bash ! /bin/bash if [! -d $HOME/backup] then mkdir $HOME/backup fi flist=ls for file in $flist do if [$# = 1] then if [$1 = $file] then echo \"$file found\" exit else cp $file $HOME/backup echo \"$file copied\" fi done echo Backup Completed - while 循环（判断条件为 **假** 时停止） 实例：输入 5 个数，分别判断是什么等级的 ``` bash #! /bin/bash I=0 while [$I -lt 5] do I=`expr $I + 1` echo -n \"input score:\" read $S case `expr $S / 10` in 9 | 10) echo \"A\" ;; 6 | 7 | 8) echo \"B\" ;; *) echo \"C\" ;; esac echo \"$I\" done until 循环（判断条件为 真 时停止） （3）break 和 continue 实例：遇到偶数就跳出循环 #! /bin/bash if [$# -ne 5] then echo \"argument 5\" exit fi for I do if [`expr $I % 2` -eq 1] then echo \"$I\" else break fi done break n，表示跳出 n 层循环continue n，表示跳转到最近 n 层循环的下一轮循环上 三、shell 函数 3.1 基础 必须将函数放在脚本开始部分，其定义格式如下 【function】 函数名 [()] { action; 【return int;】 } funWithReturn echo \"执行上述函数的输出为 $?\" # 【】表示是可选的 3.2 将函数输出传递给变量 value_name=`function_name [arg1 arg2 ...]` 实例： grep_user() { R=`grep \"$1\" /etc/passwd | wc -l` echo $R } echo -n \"input username:\" read USER RET=`grep_user $USER` echo \"----return $RET----\" if [$USER -eq 1] then echo \"$USER exist\" else echo \"$USER not exist\" fi 3.3 获取函数的返回状态 function_name [arg1 arg2 ...] echo $? # 实例 grep_user() { R=`grep \"$1\" /etc/passwd | wc -l` echo $R return $R } echo -n \"input username:\" read USER grep_user $USER RET=$? if [$USER -eq 1] then echo \"$USER exist\" else echo \"$USER not exist\" fi 3.4 变量的作用域 全局作用域：在脚本的任何地方都能够访问该变量 局部作用域：只能在声明变量的作用域内访问 声明格式： local variable_name=value 四、其他 一个 shell 脚本可以包含另一个 被包含的文件不需要可执行权限只需要在调用的脚本里使用 source 被调用的脚本文件名 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-08-13 11:16:28 "},"about_Linux/在线扩容磁盘空间.html":{"url":"about_Linux/在线扩容磁盘空间.html","title":"磁盘扩容","keywords":"","body":"一、磁盘挂载 先在 VM ware workstation 的设置里面增加磁盘的容量，假设扩展了 10GB 的空间 启动虚拟机，打开终端df -TH 查看现有分区挂载情况，查看 需要扩容的文件系统名字，例如：/dev/sda3fdisk -l 查看现有磁盘和分区情况，或者使用命令 lsblk，发现磁盘空间多了 10GB 报错：GPT PMBR size mismatch (73400319 != 125829119) will be corrected by write.执行命令：sudo parted -l然后输入：Fix 输入 fdisk 磁盘路径 会出现一些信息，按照要求输入 p 或者 n，慢点回车，直到显示 分区 x 已设置为 Linux 类型，大小设为 x GiB 输入 wq 回车退出再次输入 fdisk -l 会发现多了一个新的分区，假设为 /dev/sda4 【注意，若仅扩容则不需要执行下面的挂载】挂载操作：假设现在要挂载这个磁盘到新的文件夹 /new 下，输入 mount 分区名 新文件夹名 实现分区挂载到文件夹，例如 mount /dev/sda4 /new 二、分区扩容（常规的 LVM 模式扩容） 没有卷组的话需要先创建卷组 vgcreate 卷组名 空闲分区，例如：vgcreate vg1000 /dev/sda4执行 vgdisplay 查看并记住 VG Name，此时 Free PE 为 0执行 partprobe - inform the os of partition table changes 使分区表生效执行 sudo pvcreate -ff -y /dev/sda4 将刚刚新建的分区初始化为物理卷，以便为 LVM 所用执行 vgextend VGName 新分区名 扩展卷组，例如 vgextend vg1000 /dev/sda4执行 vgdisplay 查看卷组信息，此时 Free PE 有空间了 下面开始扩容lvextend -l +100%FREE 需要扩容的分区名 /dev/sda4，例如 lvextend -l +100%FREE /dev/mapper/centos-root /dev/sda4cat /etc/fstab 查看分区文件系统的类型，是 ext 还是 XFS。ext 类型的写法 resize2fs 需要扩容的分区名；XFS 类型的写法 xfs_growfs 需要扩容的分区名最后确认扩容是否成功 df -lh 三、若需要在根目录扩容 https://blog.csdn.net/xwmrqqq/article/details/109828166 类似的，输入 fdisk 挂载在根目录的分区，例如：fdisk /dev/sda按照要求输入 d 删除原本挂载在根目录的分区，输入 n 重新创建分区输入 p 确认新分区的大小，并输入 wq 保存退出输入 partprobe /dev/sda，通知系统内核分区表的变化输入 resize2fs 挂载在根目录的分区，对文件系统进行扩容最后确认扩容是否成功 df -lh 参考资料 https://blog.csdn.net/qq_48922459/article/details/122229118https://www.cnblogs.com/jaysonteng/p/13443258.htmlhttps://blog.csdn.net/qq_38871173/article/details/121905345https://www.cnblogs.com/daisyyang/p/11005313.html Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-11-26 15:35:58 "},"about_Cloud/":{"url":"about_Cloud/","title":"Cloud","keywords":"","body":"About Cloud 云计算小知识 hadoop小知识 电子书《Hadoop数据分析》 Windows 上的 Hadoop openstack安装 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-24 21:46:56 "},"about_Cloud/云计算小知识.html":{"url":"about_Cloud/云计算小知识.html","title":"云计算小知识","keywords":"","body":" 第 1 章 云计算的定义？ 美国国家标准技术学院 NIST 给出：云计算是一种模型，这个模型可以方便地通过网络访问一个可配置的计算资源（网络、服务器、存储设备、应用程序、服务等等）的公共集。这些资源可以被快速提供且发布，同时最小化管理成本和服务供应商的干预。 第 2 章 CAP 理论？ C，Consistency，一致性 A，Availability，可用性 P，Partition tolerance，分区容错性 分布式计算领域的公认定理。说的是一个分布式系统最多只能同时满足上述三项的两项 第 3 章 云的负载模式？ 时开时停模式 用量迅速增长模式 瞬时暴涨模式 周期性增减模式 云栈与云体 云栈：也叫云平台，在云上面建造的运行环境 云体：云计算的物质基础，云计算所用到的资源合集 二者结合用来进行计算或者处理，即云计算 软件定义的数据中心，及其特点 SDDC（Software Defined Data Center），数据中心的所有基础设施都是虚拟化的，并且能够以一种所要即所得的服务方式来提供 特点是：不需要管理员频繁照看；网络可划分且 IP 地址不冲突；部署负载均衡，测试方便；资源按需分配；能自动修复崩溃且进行记录 第 4 章 什么是虚拟化技术？哪三种类型？ 虚拟化技术是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍 包括：服务器虚拟化、网络虚拟化、桌面虚拟化 全虚拟化和半虚拟化技术的区别？ 全虚拟化，结合了二进制翻译和直接指令执行，不需要硬件辅助或操作系统辅助来虚拟化敏感指令和特权指令 半虚拟化，虚拟机系统和虚拟化软件层通过交互来改善性能和效率 | \\ | 全虚拟化 | 半虚拟化 | | --- | --- | --- | | 虚拟化代价 | 较高 | 较低 | | 未经修改的操作系统（例如 Windows 系统） | 支持 | 不支持 | | 兼容性、可移植性 | 较好 | 较差 | 硬件虚拟化的代表 GPU 虚拟化 FPGA 虚拟化 RDMA 虚拟化 NVM 虚拟化 轻量级虚拟化技术？代表？ 轻量级虚拟化技术是相对于重量级虚拟化而言的。它并没有虚拟出完整的计算机环境，只是虚拟出进程的运行环境；容器之间相互隔离，运行在同一主机系统上 代表：2016年 Windows 容器、2013年 Docker、2008年 LXC、2008年 Solaris Zones 等等 第 5 章 分布式存储的类型？ 针对不同的数据类型，有不同的分布式存储系统 共四类： 分布式文件系统：适合非结构化数据（文本、图片、图像、音频、视频等） 分布式数据库：用于存储大规模的结构化数据（关系数据库中的二维关系表结构，模式和内容是分开的，模式需要先定义） 分布式键值系统：用于存储半结构化数据（例如 HTML 文档，模式和内容没有明显区分，模式不需要预先定义） 分布式表系统：主要存储半结构化数据 第 6 章 软件定义网络的概念？ SDN，是一种新型网络解决方案，将网络资源抽象到虚拟化系统中的 IT 基础架构方法。网络硬件可以集中式软件管理，可编程化，控制与转发分离 控制平面和数据平面？ 控制平面，SDN 控制器所在的平面，通过北向接口与应用平面中的网络应用进行通信。负责配置策略，监控性能 数据平面，由控制平面转发表中的数据包组成 第 7 章 云计算安全技术框架的内容？ 云用户安全目标： 云数据安全与隐私保护 云安全管理 云计算安全服务体系： 云基础设施服务，操作系统、搜索、开发平台、数据管理等等 云基础安全服务，用户身份管理、访问控制、加密、审计等等 云安全应用服务，网页过滤与杀毒应用、网络安全监控、垃圾邮件过滤、DDoS 攻击预警等等（DDoS 攻击，利用恶意程序对一个或多个目标发起攻击，消耗目标服务器性能或网络带宽，从而造成服务器无法正常地提供服务） 第 8 章 什么是持续集成与持续交付？ 持续集成：是一种软件开发的实践方法。要求团队成员经常整合他们的工作成果，每人每天多次提交代码做继承构建 持续交付：是一种软件过程控制方法。以可持续的方式，安全快速地将所有类型的软件变更转化为生产环节下的工作产品交付给用户直接使用 第 9 章 云操作系统的定义？ 构架于服务器、存储、网络等基础硬件资源和单机操作系统、中间件、数据库等基础软件之上，管理海量的基础硬件、软件资源的云平台综合管理系统 云操作系统有哪些功能？ 管理和驱动海量基础硬件，在逻辑上将它们整合成一台服务器 为云应用软件提供统一、标准的接口 管理海量的计算任务，资源调配和迁移 第 10 章 云件的关键技术？ 虚拟化技术：提供运行环境、操作系统、库、组件等 云端渲染交互技术：渲染过程放在云端，交互事件通过网络传到云端 容器技术：轻量级虚拟化技术，启动镜像实例快，占用资源少 媒体流数据压缩技术：降低交互延迟，保证渲染的输出帧质量 终端交互技术：云件的主体运行在云端，终端只需要配备交互平台，浏览器是交互组件首选 ~ 前提是容器技术、GPU 虚拟化技术、5G 网络技术、HTML5 前端交互技术的成熟 第 11 章 AIOps（智能运维）的关键场景与技术 KPI 瓶颈分析 KPI 异常检测 智能诊断 自动修复 事故管理 故障预测 第 12 章 桌面云架构的内容？ 传输协议，协议层 服务层 资源层 安全 第 13 章 软件开发云的概念？ 通过云服务的方式提供一站式云端开发运营（DevOps）平台 传统软件开发云面临的挑战？ 获取基础设施难，基础设施交付周期也长 各种开发和测试的环境需要部署和维护 开发和测试环境不能完全复现生产环境的场景 IT、开发、运维、测试部门割裂 第 14 章 云计算、大数据与人工智能的关系？ 2006年是云计算元年，称为 Cloud1.0。如今的 Cloud2.0 是 ABC（AI、BigData、Cloud）的融合 大数据从属于云计算，是云计算的应用，它需要云计算提供平台，同时也成就了云计算，催生出各种云服务 人工智能的兴起是云计算、大数据演进和成熟的必然结果，拓展了 AI 的应用场景，加快 AI 产业化进程，实现 AI 质的飞跃 三者各司其职，云计算聚焦在 IT 基础设施上，大数据关注于计算能力与存储能力的提升，人工智能的核心是追求更智能化的应用或者具有学习能力的机器 实验部分 实验 1 VirtualBox、VMware Workstation 是桌面虚拟机软件，可以在上面安装 Linux 等操作系统 KVM 是基于内核的虚拟机，内建于 Linux 中，使主机计算机能够运行多个隔离的虚拟环境 Docker 采用轻量级虚拟化技术，支持打包应用以及依赖包到镜像中，然后发布到任何流行的 Linux 或 Windows 操作系统的机器上，也可以实现虚拟化 实验 2 HTCondor 是分布式计算框架，可以进行大吞吐量计算。本质是将一个大的计算任务划分成多个小任务，分配给网络计算集群，最终合并结果 实验 3 Openstack 是开源的部署云的操作平台，可以利用虚拟资源池构建和管理私有云和公共云 实验 4 Hadoop 是开源的分布式系统基础架构，核心是 HDFS 和 MapReduce。HDFS 为海量的数据提供了存储，而 MapReduce 则为海量的数据提供了计算 实验 5 Mininet 是一个轻量级软件定义网络和测试平台，可以模拟一个完整的网络主机、链接和交换机，有助于开发、测试和演示 OpenDaylight 用于管理云网络 通过 Mininet 和 opendaylight 可以创建一个 SDN，通过软件定义网络 实验 6 Node.js 是一个 JavaScript 运行环境，通过在 Docker 环境中部署 Node.js，体验云原生应用开发 DevCloud 是华为公司推出的云上一站式软件实训平台，提供项目管理、代码托管、CloudIDE、代码检查、编译构建等功能 实验 7 Mesos 是开源的集群管理器，通过在多种不同框架之间共享可用资源来提高资源使用率 实验 8 Ganglia 是开源集群监视项目，主要是用来监控系统性能，如：CPU、内存、硬盘利用率，I/O负载、网络流量情况等 Nagios 是一款开源的电脑系统和网络监视工具，能有效监控 Windows、Linux 和 Unix 的主机状态，交换机路由器等网络设置 通过安装 Ganglia 和 Nagios，来监控 hadoop 集群的系统性能 实验 9 使用前面安装的 Openstack 和 KVM 搭建桌面云系统 微助教题目 选择题 云计算的三元认识论 P21 商业模式 计算范式 实现方式 2006年8月，SES 大会上，时任 Google 公司 CEO 施密特提出了云计算这个概念 P2 云计算主要提供的服务 P21 IaaS（基础设施即服务） PaaS（平台即服务） SaaS（软件即服务） 云计算的演进过程不包括：虚拟计算 P6~10 分布式计算的优点 P41 稀有资源可以共享 通过分布式计算可以在多台计算机上平衡计算负载 可以把程序放在最适合运行它的计算机上 分布式计算理论基础 P42~46 ACID 原则 CAP 理论 BASE 理论 分布式计算和并行计算共有的特性：拓展性 P56 分布式系统 P60 流媒体系统 透明计算系统 以太坊系统 ~ 嵌入式系统不是 云的工作负载模式 P78 时开时停模式 用量迅速增长模式 周期性增减模式 瞬时暴涨模式 多层客户机/服务器的计算架构属于：中间层架构 P81 不支持未经修改的操作系统的虚拟化是：半虚拟化 P109 VMM：虚拟机监视器（Virtual Machine Monitor） P106 虚拟化技术涉及的类别 P106 服务器虚拟化 网络虚拟化 桌面虚拟化 软件定义数据中心的特征 P90 不需要人为分配资源 但是仍需要管理员照看、需要划分网络、需要部署测试，只是都变得相对方便简易 属于 SaaS 层次的架构：应用软件 P23 填空题 可以通过（DevStack）工具安装 Openstack P101 Linux 在配置好软件源之后执行 Docker 安装的指令是： $sudo apt-get install docker-ce P127 （虚拟化）是云计算赖以存在的基础和提供的功能的实质 云计算架构中的物质基础是（云体），运行环境称为（云栈） P86 云计算革命性的概念是 IT 作为（服务） P76 分布式环境中不同程度的一致性包括（强一致性；弱一致性；最终一致性） P47 分布式计算就是两个或者多个软件互相（共享信息），这些软件可以在同一台计算机上运行，也可以在通过（网络）连接起来的多台计算机上运行 P41 云计算公共特征的其中两个是（弹性伸缩；快速部署） P14 还有资源抽象、按用量计费、宽带访问 开源技术是云计算的一种方法论，跟这类技术相关的软件类型通常包括（开源软件；自由软件；免费软件） P25 可以按云计算的（部署方式）和（服务类型）来分析现在各种各样的云方案 P15 相对于软件定义的数据中心这一新概念，还有软件定义（计算、网络、存储） P90 分布式系统大概可以分为三类，分布式存储系统、分布式计算系统和（分布式资源管理系统） P58 简答题 NIST给的云计算定义是？ P5 举例来阐述和证明CAP理论。 P44 什么是轻量级虚拟化技术？并列举出两个代表。 P122 云计算的纵向层次系统结构以及其中对应的三层架构模式是？ P23 思考题 如何理解“开源是种方法论”？ P29 对比目前已知的传统虚拟机的差异及优缺点。 云计算的架构是如何进化的？ P80 利用 HTCondor 分析分布式计算的原理和步骤。 综合题 列出各种计算模式并指出其对云计算模式的促进作用。 P6 云计算的原理与技术、开发与营运以及应用与案例对应的内容是？ 前言P2 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-23 22:48:04 "},"about_Cloud/hadoop小知识.html":{"url":"about_Cloud/hadoop小知识.html","title":"hadoop小知识","keywords":"","body":"简介 Hadoop 是一个分布式计算的解决方案，可编写和运行分布式应用，处理大规模数据 Hadoop = HDFS（文件系统，数据存储技术相关）+ MapReduce（数据处理） 开源 适合离线和大规模数据分析，但是不适合对几个记录随机读写的在线事务处理模式 处理半结构化和非结构化数据上，相比关系型数据库其更加灵活 不管任何数据形式最终会转化为key/value，key/value是基本数据单元 版本 Hadoop1.0 Hadoop 版本为 0.20.x、0.21.x，0.22.x 和 1.x 分布式文件系统 HDFS + 分布式计算框架 MapReduce HDFS 由一个 NameNode 和多个 DataNode 组成，MapReduce 由一个 JobTracker 和多个 TaskTracker 组成 Hadoop2.0 Hadoop 版本为 0.23.x 和 2.x 针对 Hadoop 1.0 中的 MapReduce 在扩展性和多框架支持方面的不足，提出了全新的资源管理框架 YARN，它将 JobTracker 中的资源管理和作业控制功能分开，分别由组件 ResourceManager 和 ApplicationMaster 实现 ResourceManager 负责所有应用程序的资源分配，而 ApplicationMaster 仅负责管理一个应用程序 实际应用 facebook 用 Hive 来进行日志分析 淘宝搜索中的自定义筛选也使用的 Hive 以及 Twitter、LinkedIn 上使用 Hive 用于发现您可能认识的人，可以实现类似 Amazon.com 的协同过滤的推荐效果 商品推荐也是，天猫的推荐系统是 Hive 垃圾邮件的识别和过滤，还有用户特征建模 举例 假设现在有一个 100M 大小的数据库备份的 sql 文件，在不导入到数据库的情况下过滤出想要的内容可以怎么做？ 用 linux 的命令 grep 操作，通过正则匹配 通过编程来读取文件，然后对每行数据进行正则匹配 目前上述两种方法都可以轻松应对，但如果是 1G、1T 甚至 1PB 的数据呢，上面的方法就行不通了，毕竟单台服务器的性能总有其上限 有种解决方法就是分布式计算，分布式计算的核心就在于利用分布式算法把运行在单台机器上的程序扩展到多台机器上并行运行，从而使数据处理能力成倍增加 Hadoop 可以很轻易的把 很多 linux 的廉价 PC 组成分布式结点，然后编程人员只需要根据 mapreduce 的规则定义好接口方法，剩下的就交给 Hadoop。它会自动把相关的计算分布到各个结点上去，然后得出结果 Hadoop 首先把 1PB 的数据文件导入到 HDFS 中，然后编程人员定义好 map 和 reduce，也就是把文件的行定义为 key，每行的内容定义为 value，然后进行正则匹配，匹配成功则把结果通过 reduce 聚合起来返回 Hadoop 就会把这个程序分布到 N 个结点去并行的操作，那么原本可能需要计算好几天，在有了足够多的结点之后就可以把时间缩小到几小时之内 腾讯大数据的文章 比如说要获取 /hdfs/tmp/file1 的数据，虽然引用的是一个文件路径，但是实际的数据存放在很多不同的机器上 MapReduce 是第一代计算引擎。Map 阶段各个机器分别处理，Reduce 阶段再将结果进行汇总。虽然好用，但是很笨重 Tez 和 Spark 是第二代。让 Map 和 Reduce 之间的界限更模糊，数据交换更灵活，更少的磁盘读写，以便更方便地描述复杂算法，取得更高的吞吐量 但是 MapReduce 的程序写起来很麻烦，所以有了 Pig、Hive。Pig 是接近脚本方式去描述 MapReduce，Hive 则用的是 SQL。它们把脚本和 SQL 语言翻译成 MapReduce 程序，丢给计算引擎去计算 但是 Hive 在 MapReduce 上跑太慢了，于是 Impala，Presto，Drill 诞生了。牺牲了通用性、稳定性等特性，为了让用户更快速地处理 SQL 任务 为了更加高速的处理，例如不断更新的热搜榜，新的计算模型 Streaming（流）计算出现了。数据流进来的时候就进行处理，很好的东西，但是无法替代上面数据仓库和批处理系统 另外一个重要组件是调度系统。现在最流行的是 Yarn，可以看作是中央管理 Hadoop Distributed File System (HDFS) HDFS 基于 GFS(Google File System) 设计而出 就像很多其他的分布式文件系统一样，HDFS 保存大量数据，并且提供对分布在网络上的许多客户端的透明访问。HDFS 的优势在于通过可靠的、可扩展的方法存储大量的文件 HDFS 通过复制块并在集群中分发副本来确保可靠性。默认的复制因子是三，这意味着每个块在集群上存在三次。即使在机器发生故障时，块级复制也能实现数据可用性 NameNode 和 DataNode 进程可以在一台机器上运行，但 HDFS 集群通常指一台运行 NameNode 进程的专用服务器 + 数千台运行 DataNode 进程的机器 secondary NameNode 用来生成 NameNode 的内存结构的快照，从而降低 NameNode 发生故障时数据丢失的风险 DataNode 发生故障时，NameNode 将复制丢失的块，以确保每个块满足最小复制因子 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-23 22:51:56 "},"about_Cloud/电子书《Hadoop数据分析》.html":{"url":"about_Cloud/电子书《Hadoop数据分析》.html","title":"电子书《Hadoop数据分析》","keywords":"","body":"电子书 Hadoop 数据分析 标签：云计算 基础概念 数据是编程界的“货币” 数据产品 是数据与用于推断或预测的统计算法的结合，是一个从数据中学习、自适应并且广泛适用的系统 数据产品例如：推荐系统、恒温器、无人驾驶汽车、智能电网 典型的分析工作流：采集 → 整理 → 建模/计算 → 报告和可视化 大数据流水线：包括采集、分段、计算和工作流管理这 4 个主要阶段的迭代模型，工作流管理出的有用信息还可能通过反馈流机制作为下一次迭代的输入 数据团队 数据工程师 数据分析师 领域专家 Hadoop 是大数据操作系统 分布式文件系统 HDFS 负载和资源管理器 YARN 批处理 MapReduce 内存计算 Spark 流式计算 Storm SQL Hive 概念： 数据添加到集群后会被分发到各个节点上 数据块大小一般为128MB，跨系统多次复制以提供冗余，提高容错率，保证数据安全 一个大作业被分解为小任务 开发人员专注于数据和计算，不用担心底层的分布式编程细节 什么是守护进程（Daemon） 保护程序/服务的正常运行，当程序被关闭、异常退出等时能够再次启动程序/恢复服务 例如 http 服务的守护进程叫 httpd，mysql 服务的守护进程叫 mysqld 有时候我们需要让我们的程序/服务能不中断地运行，在关闭终端后也能在后台默默运行 除了可以这样：nohup./xxx &，也可以写成 Daemon 程序，例如一个服务器 集群 HDFS 和 YARN 提供 API，使得开发人员不用关注底层的集群管理细节 集群就是运行 HDFS 和 YARN 的一组计算机，每台就是一个节点，[1,+∞) Hadoop 进程是服务，这意味着它们一直在集群节点上运行，接受输入并通过网络传 递输出 一般来说，拥有 20~30 个 worker 节点和单个 master 节点的集群足以在几十太字节的数据集上同时运行多个作业 节点 master 节点 为 Hadoop 的 worker 节点提供协调服务。没有 master 节点，协调就不复存在，也就不可能进行分布式存储或计算 worker 节点 集群中的大多数计算机都属于这类节点。worker 节点运行的服务从 master 节点接受 任务——存储或检索数据、运行特定应用程序。worker 节点通过并行分析运行分布 式计算 HDFS 的 master 服务和 worker 服务 NameNode（master 服务） 用于存储文件系统的目录树、文件元数据和集群中每个文件的 位置，像交警指挥交通一般，将客户端指向正确的 DataNode Secondary NameNode（master 服务） 代表 NameNode 执行内务任务并记录检查点。虽然它叫这个名字，但它并不是 NameNode 的备份 DataNode（worker 服务） 用于 存储和管理 本地磁盘上的 HDFS 块，将各个数据存储的健康状况和状态报告给 NameNode YARN 的 master 服务和 worker 服务 ResourceManager（master 服务） 为应用程序 分配和监视可用的集群资源（如内存和处理器核心这样的物理资源），处理集群上作业的调度 ApplicationMaster（master 服务） 根据 ResourceManager 的调度，协调 在集群上运行的特定应用程序 NodeManager（worker 服务） 在 单个节点 上运行和管理处理任务，报告任务运行时的健康状况和状态 单节点集群 在“伪分布式模式”中，单个机器将运行所有 Hadoop 守护进程，就好像它是集群的一部分，但网络流量是通过本地环回网络接口流动的。这种模式虽然没有发挥出分布式架构的优势，但却是一种完美的开发模式，因为不必为管理几台机器而费心。Hadoop 开发人员通常使用伪分布式环境，该环境通常位于虚拟机内部，通过 SSH 连接虚拟机 HDFS 集中式存储架构 一般用于存储原始输入数据或者计算阶段的中间结果 “数据湖泊”，里面的数据通过一次写入可以多次读取，并创建大量的异构数据用于不同的计算分析 文件块 大文件拆分并分发给其他计算机 每个块都将复制三份（故实际可用磁盘空间比硬件磁盘空间少） 数据管理 NameNode 记录块所在的位置，定位块的位置 Secondary NameNode 执行内务任务，合并日志 YARN Hadoop2 时引入，突破了 MapReduce 作业 / 工作负载管理功能与集群 / 资源管理功能高度耦合的限制 将工作负载管理与资源管理分离 配置伪分布式节点 更新系统软件 $ sudo apt-get update && sudo apt-get upgrade $ sudo apt install vim $ sudo apt install net-tools $ sudo apt install openssh-server 创建 Hadoop 用户 $ sudo addgroup hadoop $ sudo adduser --ingroup hadoop hadoop $ sudo usermod -a -G hadoop student https://blog.csdn.net/liu_dong_kang/article/details/62881788 设置固定 IP 请查看 linux 常见问题中的：设置子网和主机名 配置 SSH ssh-keygen cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys 安装 Java sudo apt install openjdk-8-jdk-headless whereis jvm cd /usr/lib/jvm cd java-8-openjdk-amd64/ ls 环境变量设置： vi ~/.bashrc 添加： export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 export JRE_HOME=/usr/lib/jvm/java-8-openjdk-amd64/jre $ java -version 禁用 IPv6 编辑 /etc/sysctl.conf 文件 $ gksu gedit /etc/sysctl.conf 后将以下内容添加到文件的末尾： # 禁用ipv6 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 重新启动，使用以下命令检查状态 $ cat /proc/sys/net/ipv6/conf/all/disable_ipv6 若输出 1 则成功禁用 安装 Hadoop curl -O http://apache.mirror.com/hadoop-2.5.0/hadoop-2.5.0.tar.gz 前往 ISCAS 镜像网站寻找 hadoop 安装包 解压、修改四个配置文件、生成log文件地址并赋予权限、启动服务的两条命令 常用操作 查看 fs 命令下可用的命令 $ hadoop fs -help 从 本地文件系统 复制莎士比亚全集到 远程的（分布式）文件系统 $ hadoop fs -copyFromLocal shakespeare.txt shakespeare.txt 全写文件路径 $ hadoop fs –put /home/analyst/shakespeare.txt hdfs://localhost/user/analyst/shakespeare.txt /user/analyst/是远程文件系统的主目录 在远程主目录创建文件夹 $ hadoop fs -mkdir ... 列出远程主目录的内容 $ hadoop fs -ls -l 会列出权限、副本数、用户、组、以字节为单位的文件大小（目录为零）、最后一 次修改的日期和时间，以及文件名 将输出通过管道传递给 less 以查看远程文件的内容 $ hadoop fs –cat shakespeare.txt | less 可以通过方向键导航文件，键入 q 退出并退回到终端 仅检查文件的最后 1000 字节 $ hadoop fs –tail shakespeare.txt | less 将整个文件从分布式文件系统传输到本地文件系统 在管道传输的时候使用压缩工具 $ hadoop fs –get shakespeare.txt ./shakespeare.from-remote.txt 管理文件和目录的权限，chmod、chgrp 和 chown 命令 将 shakespeare.txt 的权限更改为 -rw-rw-r--。664 是为权限三元组设置的标志的八进制表示 $ hadoop fs –chmod 664 shakespeare.txt chgrp 和 chown 命令分别更改分布式文件系统上文件的 组和所有者 POSIX 表示可移植操作系统接口（Portable Operating System Interface of UNIX），POSIX 标准定义了操作系统应该为应用程序提供的接口标准 意在期望获得软件可移植性。换句话说，为一个 POSIX 兼容的操作系统编写的程序，应该可以在任何其它的 POSIX 操作系统（即使是来自另一个厂商）上编译执行 Unix设计哲学中有这样子的一条：“舍高效率而取可移植性” 这很容易让人想到那些依靠 虚拟机 支持的跨平台开发语言的 跨平台特性，例如 JAVA，可以说它的跨平台能力是 靠牺牲性能 而换取来的。但遵守 POSIX 标准开发的程序在支持 POSIX 标准的操作系统间运行是不需要依靠类似虚拟机这种中间层的支持的，这就能够在不损失性能的前提下，带来强大的跨平台可移植能力 当然这种理解很美好，但实际上很多兼容 POSIX 标准的操作系统所做的实现是在自身原有的 API 接口的基础之上再封装创建一层 POSIX 兼容层来提供对 POSIX 支持，因此这意味着会占用更多一些的系统资源，但这种操作系统的原生支持（即便是二次封装出来的）相比较依托虚拟机的程序来说性能还是要给力的多的多 MapReduce Python 中 map 和 reduce 函数的伪代码 def map(key, value): # 执行处理 return (intermed_key, intermed_value) def reduce(intermed_key, values): # 执行处理 return (key, output) mapper 操作的副本分发到集群上的每一个节点 map和reduce之间需要shuffle和sort进行协调 具体操作： HDFS 的本地数据以键值对的形式被加载到一个映射过程 mapper 输出零个或多个键值对，将计算所得的值映射到一个特定的键上 基于键对这些键值对进行 sort 和 shuffle 操作，然后将它们传递给 reducer，使 reducer 获得键的所有值 reducer 输出零个或多个最终的键值对，即输出（归约 map 的结果） 单词计数 单词计数应用程序以一个或多个文本文件作为输入，生成一份单词及其频率的列表 # emit是一个执行Hadoop I/O的函数 def map(dockey, line): for word in Line.split(): emit(word, 1) def reduce(word, values): count = sum(value for value in values) emit(word, count) # emit 是一个执行 Hadoop I/O 的函数；也就是说，它将其参数发送到 MapReduce 流水线的下一个阶段，类似于 Python 中的 yield 函数 分析社交网络 查看用户间有哪些共同好友 def map(person, friends): # 键是用户的名称，值是用逗号分隔的朋友列表 for friend in friends.split(\",\"): pair = sort([person, friend]) emit(pair, friends) def reduce(pair, friends): shared = set(friends[0]) shared = shared.intersection(friends[1]) emit(pair, shared) MapReduce 不支持通过单个 map 或 reduce 进行迭代 更复杂的应用程序是通过被称为“作业链”的过程，使用多个 MapReduce 作业 执行单个计算来构建的 MapReduce 的 API 是用 Java 编写的，因此提交给集群的 MapReduce 作业是编译好的 Java 归档（Java Archive，JAR）文件 将 Hadoop 作业编译成一个 JAR 文件 $ hadoop com.sun.tools.javac.Main WordCount.java $ jar cf wc.jar WordCount*.class 这会在当前工作目录中创建一个 wc.jar 文件 作业提交 $ hadoop jar wc.jar WordCount shakespeare.txt wordcounts 作业将执行并输出 mapper 和 reducer 的状态，并且在完成时报告作业完成情况的统计信息。一旦完成，作业的结果将写入 wordcounts 目录 $ hadoop fs –ls wordcounts $ hadoop fs –cat wordcounts/part-00000 | less 列出所有正在运行的作业 $ hadoop job -list 通过 -kill 命令终止某作业 $ hadoop job -kill $JOBID Hadoop Streaming 是 JAR 文件，实用程序 可以指定输入输出的 HDFS 路径参数，还可以指定 mapper、reducer 的可执行程序 注意这里的 Streaming 是指标准的 Unix 流：stdin、stdout、stderr mapper.py #!/usr/bin/env python import sys if __name__ == \"__main__\": for line in sys.stdin: for word in line.split(): sys.stdout.write(\"{}\\t1\\n\".format(word)) # 从 sys.stdin 读取每一行，使用空格拆分该行文本，然后逐行将得到的每个单词和数字 1 写入 sys.stdout，并用制表符将两者分隔 reducer.py #!/usr/bin/env python import sys if __name__ == '__main__': curkey = None total = 0 for line in sys.stdin: key, val = line.split(\"\\t\") val = int(val) if key == curkey: #若等于上一次的 key，就直接在上一次的基础上累加 total += val else: if curkey is not None: sys.stdout.write(\"{}\\t{}\\n\".format(curkey, total)) curkey = key total = val # 注意！！！这里 stdin 是接收从 mapper 输出的、经过排序的逐行输入，故可以如上编程实现 wordcount # 若没有事先排序则是不行的 注意 1、代码在 “ifmain” 块中 在 Python 中，只有脚本作为程序的主入口点运行时，此条件才会被触发，被导入的脚本不会运行该方法。Python 开发人员使用它来判断代码是否在一个库中，或者确保任何执行的代码都在 Python 脚本的底层运行，以方便调试。通过这个语句，可以确保这个块不是导入代码以继承 mapper，如果是则这个块就不会被执行 2、每个 mapper 和 reducer 都视为可执行程序，所以每个 Python 文件都应以 #!/usr/bin/env python 开头 在 CSV 上的计算 数据展示 2014-04-01,19805,1,JFK,LAX,0854,-6.00,1217,2.00,355.00,2475.00 2014-04-01,19805,2,LAX,JFK,0944,14.00,1736,-29.00,269.00,2475.00 mapper.py #!/usr/bin/env python import sys import csv SEP = \"\\t\" class Mapper(object): def __init__(self, stream, sep=SEP): self.stream = stream self.sep = sep def emit(self, key, value): sys.stdout.write(\"{}{}{}\\n\".format(key, self.sep, value)) def map(self): self.status(\"mapping started\") def map(self): for row in self: if row[6] __iter__ 函数的实现使该类成为可迭代的，该函数返回一个生成器（一般通过 yield 语句构造）；该函数如果简单地返回 self，就必须同时实现 next 或 __next__ 方法，这两个方法在迭代完成时抛出 StopIteration。这个类现在可以用于 for 语句，如： for item in Mapper(): print(item) reducer.py#!/usr/bin/env python import sys from itertools import groupby from operator import itemgetter SEP = \"\\t\" class Reducer(object): def __init__(self, stream, sep=SEP): self.stream = stream self.sep = sep def emit(self, key, value): sys.stdout.write(\"{}{}{}\\n\".format(key, self.sep, value)) def reduce(self): for current, group in groupby(self, itemgetter(0)): self.status(\"reducing airport {}\".format(current)) total = 0 count = 0 for item in group: total += item[1] count += 1 self.counter(\"airports\") self.emit(current, float(total) / float(count)) def __iter__(self): for line in self.stream: #异常处理在处理大数据集时至关重要 #一种常用的策略是跳过引发异常的行，因为还有大量的数据需要计算 try: parts = line.split(self.sep) yield parts[0], float(parts[1]) except: continue if __name__ == '__main__': reducer = Reducer(sys.stdin) reducer.reduce() 执行 Streaming 作业 使用 Linux 管道和 sort 命令模拟 Hadoop MapReduce 流水线 $ chmod +x mapper.py $ chmod +x reducer.py 使用 cat 命令输出文件的内容，通过管道将输出从 stdout 传输到 mapper.py 的 stdin，再传输到 sort，然后到 reducer.py，最后将结果打印到屏幕上 $ cat flights.csv | ./mapper.py | sort | ./reducer.py 在集群上执行 Streaming 作业 # 需要将 Hadoop Streaming JAR 提交给作业客户端，并传入自定义的操作符参数 $ hadoop jar $HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-*.jar \\ -input flights.csv \\ -output average_delay \\ -mapper mapper.py \\ -reducer reducer.py \\ -file mapper.py \\ -file reducer.py # -file 选项，它让 Streaming 作业往集群上发送脚本（否则程序无法在节点上找到这些脚本） # 在 Windows 系统上，注意文件格式 hadoop fs -rm -r /user/simpletest/ hadoop jar D:\\hadoop\\hadoop-3.2.3\\share\\hadoop\\tools\\lib\\hadoop-streaming-*.jar -D stream.non.zero.exit.is.failure=false -files file:///D:/jupyterproject/hadoop/mapper.py -files file:///D:/jupyterproject/hadoop/reducer.py -input file:///D:/jupyterproject/hadoop/simpletest.csv -output /user/simpletest/output -mapper \"D:\\python\\python.exe mapper.py\" -reducer \"D:\\python\\python.exe reducer.py\" combiner 因为 mapper 会产生大量的中间数据，这些数据需要经过数据传输进行 shuffle 和 sort，而网络资源有限，大量的数据传输可能会导致作业延迟等等问题。所以 combiner 本质是在数据传输之前做一个局部的 reduce 来减少中间数据 combiner 预先计算每个键的和，减少生成的键值对的数量，从而减少网络流量 partitioner 通过划分键空间将键值分配给每个 reducer，分配会尽量均匀以平衡各 reducer 的工作负载 工作链 可以解决复杂的算法，将它分解为几个较小的 MapReduce 任务。开发人员必须考虑每一步计算怎样 reduce 出中间值——不仅仅是 mapper 和 reducer 之间的中间值，还包括作业之间的中间值 例子：计算 Pearson 相关系数 第一个 MapReduce 作业将计算 n 以及 x 和 y 的平均值 class VariablePairsMapper(Mapper): def map(self): # 计算(x, y)的个数及和 # 输出键是x在vector中的索引 for y, vector in self: for x, i in enumerate(vector): self.emit(i, (1, x, y) ) class PairsMeanReducer(Reducer): def reduce(self): for key, values in self: # 将所有的值加载到内存，这样可以迭代两次 values = list(values) # 计算(x, y)的和及元素的个数 sx, sy, sn = 0 for (n, x, y) in values: sn += n sx += x sy += y # 计算x和y的平均值 xbar = sx / n ybar = sy / n # 发射每一个(x, y)及x和y的平均值 for (n, x, y) in values: self.emit(key, (x, y, xbar, ybar)) 计算协方差和标准差，需要再次传入相同的输入数据，并将第一个作业的输出作为该作业的输入 import math class PearsonMapper(Mapper): def map(self): # 计算x和xbar的差及y和ybar的差 # 发射差的乘积及其平方 for i, (x, y, xbar, ybar) in self: xdiff = x-xbar ydiff = y-ybar self.emit(i, (xdiff*ydiff, xdiff**2, ydiff**2)) class PearsonReducer(Reducer): def reduce(self): for key, values in self: # 计算差乘积的和以及平方的和 sxyd = 0 sxd2 = 0 syd2 = 0 for (xyd, x2d, y2d) in values: sxyd += xyd sxd2 += x2d syd2 += y2d # 发射相关系数 r = sxyd / (math.sqrt(sxd2) * math.sqrt(xyd2)) self.emit(key, r) Spark Spark 主要通过名为弹性分布式数据集（resilient distributed dataset，RDD）的新数据模型实现高速运行，该数据模型在计算时 存储在内存 中，从而避免了昂贵的中间内存计算磁盘写操作。因此，Spark 程序员不是简单地指定 map 步骤和 reduce 步骤，而是在执行某个需要协调的动作（如规约或写入磁盘）之前，指定一系列将应用于输入数据的 数据流转换 DAG 有向无环图，用于描述数据流步骤，步骤相连且单步不重复 Spark 栈 Spark 是一个计算框架，专注于计算而非数据存储，它可以利用 YARN 和 HDFS 进行集群管理和分布式存储 主要组件 Spark SQL Spark Streaming MLlib GraphaX RDD 可以根据转换过程重建、从分布式存储读取写入、高速缓存在worker节点的内存中以快速重用 分布式分析和模式 单个运算只对数据进行多个微小的处理，而要想得到更有意义的结果，必须将这些运算组成一个被称为数据流的分步序列，数据流被描述为有向无环图（DAG） 但是许多算法都不能轻易转换为 DAG，例如在整个计算过程中 维持或更新单个数据结 构 的算法（需要一些共享内存），或者 依赖中间步骤 计算结果的算法（需要中间进程间通 信），引入循环的算法，特别是 循环次数不限的迭代算法，也不容易描述为 DAG 键计算 Web 日志 记录是 Hadoop 大数据计算的典型数据源，因为它们代表每个用户的点击流式数 据，从中可以轻松探究数据的多个方面 # 使用复合键将文本分解为两个每日时间序列，一个用于本地流量，另一个用于远程流量 import re from datetime import datetime # 解析日志记录中的日期时间 dtfmt = \"%d/%b/%Y:%H:%M:%S %z\" # 使用正则表达式解析日志记录 linre = re.compile(r'^(\\w+) \\- \\- \\[(.+)\\] \"(.+)\" (\\d+) ([\\d\\-]+)$') def parse(line): # 使用正则表达式匹配日志记录 match = linre.match(line) if match is not None: # 正则表达式含有分组，能提取日志源、时间戳、 # 请求、状态码和响应字节大小 parts = match.groups() # 解析日期时间，返回日志源、年和天 date = datetime.strptime(parts[1], dtfmt).timetuple() return (parts[0], date.tm_year, date.tm_yday) 理解复合数据的序列化和反序列化。序列化是指将内存中的对象转换成 字节流，使其可以被 写入磁盘或通过网络传输（反序列化是指相反的过程） 简单地使用内置的 str 函数对不可变类型（例如元组）进行序列化 import ast def map(key, val): # 解析复合键，它是一个元组 # literal_eval 函数评估元组字符串得到 Python 元组类型 key = ast.literal_eval(key) # 以字符串写新的键 return (str(key), val) 影响键空间的几种模式 特别是爆炸（explode）、过滤、变换和恒等（identity）模式 键空间变换 直接赋值、复合、分割和 键值换位 爆炸 mapper 针对单个输入键生成多个中间键值对，通过键移位（key shift）和将值拆分为多个部分来实现的 过滤器 mapper 恒等模型 恒等 mapper 通常用于在数据流中执行多个 reduce。当在 MapReduce 中使用恒等 reducer 时，该作业等同于在键空间上进行排序 设计模式 迈向最后一英里 假设我们有一个新闻报道或博文的数据集，现在要预测接下来的 24 小时内的评论数量 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-23 22:54:10 "},"about_Cloud/Windows上的Hadoop.html":{"url":"about_Cloud/Windows上的Hadoop.html","title":"Windows 上的 Hadoop","keywords":"","body":"安装 1、Java 环境，jdk 版本不低于 1.8 下载地址：https://www.oracle.com/java/technologies/downloads/#java8-windows（需要注册 Oracle 账号），也可以在百度网盘上下载jdk下载 2、Hadoop 下载地址：http://archive.apache.org/dist/hadoop/core/ 例如下载 hadoop-3.2.3 这个版本的 注意还要下载在 windows 环境下的第三方包：winutils 3、Spark 下载地址：http://archive.apache.org/dist/spark/ 例如下载 spark-3.1.2-bin-hadoop3.2 这个版本的 配置 1、配置 jdk 的环境变量 打开环境变量界面，在下面的系统变量中新建一个变量 变量名：JAVA_HOME 变量值：jdk 的路径，例如：D:\\java\\jdk1.8 然后双击 Path 变量添加两条 %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 2、配置 hadoop 的环境变量 在系统变量中新建一个变量 变量名：HADOOP_HOME 变量值：hadoop 的路径，例如：D:\\hadoop\\hadoop-3.2.3 然后双击 Path 变量添加 %HADOOP_HOME%\\bin 3、配置 spark 的环境变量 变量名：SPARK_HOME 变量值：spark 的路径，例如：D:\\spark\\spark-3.1.2-bin-hadoop3.2 然后双击 Path 变量添加两条 %SPARK_HOME%\\bin %SPARK_HOME%\\sbin 4、修改 hadoop 的配置文件 来到 D:\\hadoop\\hadoop-3.2.3 路径下，创建 tmp、data 文件夹 进入 D:\\hadoop\\hadoop-3.2.3\\data 路径创建 dfs 文件夹，并进入 dfs 文件夹创建 namenode、datanode 节点存储目录 来到 D:\\hadoop\\hadoop-3.2.3\\etc\\hadoop 路径下 ① 修改：core-site.xml fs.defaultFS hdfs://localhost:50000 hadoop.tmp.dir /D:/hadoop/hadoop-3.2.3/tmp Abase for other temporary directories. ② 修改：hdfs-site.xml dfs.replication 1 dfs.namenode.name.dir /D:/hadoop/hadoop-3.2.3/data/dfs/namenode dfs.datanode.data.dir /D:/hadoop/hadoop-3.2.3/data/dfs/datanode dfs.http.address localhost:50070 dfs.namenode.secondary.http-address localhost:50090 dfs.namenode.secondary.https-address localhost:50091 dfs.datanode.socket.write.timeout 6000000 dfs.socket.timeout 6000000 dfs.datanode.max.transfer.threads 8192 ③ 重命名 mapred-site.xml.template 为 mapred-site.xml，修改： mapreduce.framework.name yarn mapreduce.jobhistory.address localhost:10020 mapreduce.jobhistory.webapp.address localhost:19888 yarn.app.mapreduce.am.env HADOOP_MAPRED_HOME=/D:/hadoop/hadoop-3.2.3 mapreduce.map.env HADOOP_MAPRED_HOME=/D:/hadoop/hadoop-3.2.3 mapreduce.reduce.env HADOOP_MAPRED_HOME=/D:/hadoop/hadoop-3.2.3 ④ 修改：yarn-site.xml yarn.resourcemanager.hostname localhost yarn.nodemanager.aux-services mapreduce_shuffle yarn.nodemanager.aux-services.mapreduce.shuffle.class org.apache.hadoop.mapred.ShuffleHandler yarn.application.classpath %HADOOP_HOME%\\etc\\hadoop, %HADOOP_HOME%\\share\\hadoop\\common\\*, %HADOOP_HOME%\\share\\hadoop\\common\\lib\\*, %HADOOP_HOME%\\share\\hadoop\\mapreduce\\*, %HADOOP_HOME%\\share\\hadoop\\mapreduce\\lib\\*, %HADOOP_HOME%\\share\\hadoop\\hdfs\\*, %HADOOP_HOME%\\share\\hadoop\\hdfs\\lib\\*, %HADOOP_HOME%\\share\\hadoop\\yarn\\*, %HADOOP_HOME%\\share\\hadoop\\yarn\\lib\\* hdfs 负责分布式存储，mapreduce 负责分布式计算，yarn 负责资源调度，基本的（伪）分布式环境初步建立 测试使用 1、格式化 namenode 的 hdfs 目录 hdfs namenode –format 注意删除路径 D:\\hadoop\\hadoop-3.2.3\\data\\dfs\\ 两个文件夹下面的内容 可能遇到的问题：https://blog.csdn.net/chasonsp/article/details/115349728https://blog.csdn.net/weixin_43718641/article/details/117907516https://zhuanlan.zhihu.com/p/140389153 2、启动 hadoop 注意若有 VMware 虚拟机需要先禁用网络 先定位到 sbin 目录 D:\\hadoop\\hadoop-3.2.3\\sbin 输入 start-all.cmd 这时候会弹出 4 个窗口，输入 jps 查看进程情况 浏览器访问 http://localhost:8088/ 查看 hadoop 的启动情况 http://localhost:50070/ 3、hdfs 的使用 在路径 D:\\hadoop\\hadoop-3.2.3\\sbin 下创建文件夹 Hadoop fs –mkdir /user 或者 hdfs dfs –mkdir /user Hadoop fs –mkdir /user/input 上传文件 Hadoop fs –put e:/test.txt /user/input 查看文件内容 Hadoop fs –cat /user/input/test.txt 4、词频计算 Hadoop jar D:/hadoop/hadoop-3.2.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.3.jar wordcount /user/input/ /user/output 查看运行结果 Hadoop fs -ls /user/output/ 注意不需要提前创建 output 文件夹 将输出复制到本地 hdfs dfs -get /user/output 本地路径 Windows 修改用户名： 1、打开控制面板，点击用户账户下的更改账户类型，里面可以更改账户名称 2、然后需要修改 User 目录下的用户目录，有些麻烦，要小心注意Users文件夹的修改 3、cmd 输入 netplwiz，双击用户名进行修改，电脑需要重启 5、停止服务 D:\\hadoop\\hadoop-3.2.3\\sbin\\stop-all.cmd 遇到的问题 https://blog.csdn.net/superice_/article/details/102689227 https://jingyan.baidu.com/article/cdddd41cb0d76f53ca00e144.html @echo off pushd \"%~dp0\" dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum >List.txt dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum >>List.txt for /f %%i in ('findstr /i . List.txt 2^>nul') do dism /online /norestart /add-package:\"C:\\Windows\\servicing\\Packages\\%%i\" pause https://blog.csdn.net/qq_36470475/article/details/115670312 参考链接 https://blog.csdn.net/hawkzy/article/details/83867384 https://blog.csdn.net/luoye4321/article/details/90552674 jdk下载. https://blog.csdn.net/weixin_43252521/article/details/119119646 ↩ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-24 22:02:50 "},"about_Cloud/openstack安装.html":{"url":"about_Cloud/openstack安装.html","title":"openstack安装","keywords":"","body":"一、环境准备 1.1 环境 sudo passwd root sudo ufw disable 1.2 换源 sudo vi /etc/apt/sources.list deb http://mirrors.tencentyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.tencentyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.tencentyun.com/ubuntu/ focal-updates main restricted universe multiverse # deb http://mirrors.tencentyun.com/ubuntu/ focal-proposed main restricted universe multiverse # deb http://mirrors.tencentyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.tencentyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.tencentyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.tencentyun.com/ubuntu/ focal-updates main restricted universe multiverse # deb-src http://mirrors.tencentyun.com/ubuntu/ focal-proposed main restricted universe multiverse # deb-src http://mirrors.tencentyun.com/ubuntu/ focal-backports main restricted universe multiverse sudo apt update sudo apt upgrade 1.3 网络配置 sudo vi /etc/sysctl.conf 取消注释下面这行 net.ipv4.ip_forward=1 sudo sysctl -p sudo vi /etc/network/interfaces auto lo iface lo inet loopback # The primary network interface auto eth0 iface eth0 inet static address 10.0.24.13 network 10.0.24.0 netmask 255.255.255.0 broadcast 10.0.24.255 gateway 10.0.24.1 试试是否可以 ping 通百度 ping baidu.com 1.4 修改主机名和IP映射 注意是用内网映射 sudo vi /etc/hostname 改成 controller，意思即该主机作为控制节点 sudo vi /etc/hosts 注释掉 127.0.1.1 那一行 在 127.0.0.1 localhost 后面加上 controller 然后另起一行添加 对应的IP地址 controller 再重启 reboot 1.5 设置时间服务 sudo apt install chrony sudo vi /etc/chrony/chrony.conf 修改为如下内容： #注意注释掉几个pool，添加server、allow、local # Welcome to the chrony configuration file. See chrony.conf(5) for more # information about usuable directives. # This will use (up to): # - 4 sources from ntp.ubuntu.com which some are ipv6 enabled # - 2 sources from 2.ubuntu.pool.ntp.org which is ipv6 enabled as well # - 1 source from [01].ubuntu.pool.ntp.org each (ipv4 only atm) # This means by default, up to 6 dual-stack and up to 2 additional IPv4-only # sources will be used. # At the same time it retains some protection against one of the entries being # down (compare to just using one of the lines). See (LP: #1754358) for the # discussion. # # About using servers from the NTP Pool Project in general see (LP: #104525). # Approved by Ubuntu Technical Board on 2011-02-08. # See http://www.pool.ntp.org/join.html for more information. #pool ntp.ubuntu.com iburst maxsources 4 #pool 0.ubuntu.pool.ntp.org iburst maxsources 1 #pool 1.ubuntu.pool.ntp.org iburst maxsources 1 #pool 2.ubuntu.pool.ntp.org iburst maxsources 2 #这里是新添加的 server controller iburst allow 0.0.0.0/0 # This directive specify the location of the file containing ID/key pairs for # NTP authentication. keyfile /etc/chrony/chrony.keys # This directive specify the file into which chronyd will store the rate # information. driftfile /var/lib/chrony/chrony.drift # Uncomment the following line to turn logging on. #log tracking measurements statistics # Log files location. logdir /var/log/chrony # Stop bad estimates upsetting machine clock. maxupdateskew 100.0 # This directive enables kernel synchronisation (every 11 minutes) of the # real-time clock. Note that it can’t be used along with the 'rtcfile' directive. rtcsync # Step the system clock instead of slewing it if the adjustment is larger than # one second, but only in the first three clock updates. makestep 1 3 #这里是新添加的 local stratum 10 重启 chrony 服务 sudo service chrony restart 检查是否设置成功 执行 chronyc sources 如果是 ^* 说明配置好了，如果是 ? 说明没有连接服务器 或者执行 timedatectl System clock synchronized 会变成 yes，否则是 no 设置时间同步： sudo dpkg-reconfigure tzdata #选择亚洲上海 sudo apt-get install ntpdate sudo ntpdate cn.pool.ntp.org 1.6 下载OpenStack软件包 sudo add-apt-repository cloud-archive:yoga 安装客户端 sudo apt install python3-openstackclient python3-pip 数据库 sudo apt install python3-pymysql sudo apt install mariadb-server 创建并写入文件 sudo vi /etc/mysql/mariadb.conf.d/99-openstack.cnf 内容如下[mysqld] bind-address = 10.0.24.13 default-storage-engine = innodb innodb_file_per_table = on max_connections = 4096 collation-server = utf8_general_ci character-set-server = utf8 重启数据库 sudo service mysql restart 切换到 root，随后配置一下密码 mysql_secure_installation 消息队列 sudo apt install rabbitmq-server 创建 openstack 用户 sudo rabbitmqctl add_user openstack admin 用户名为 openstack ，密码为 admin 赋予权限 sudo rabbitmqctl set_permissions openstack \".*\" \".*\" \".*\" 文件目录在 /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.2/sbin 缓存 安装 sudo apt install memcached python3-memcache -y 修改配置文件 sudo vi /etc/memcached.conf 将 127.0.0.1 替换为 controller 对应的 IP 地址 重启服务 sudo service memcached restart etcd sudo apt install etcd -y 修改配置文件 sudo vi /etc/default/etcd 内容如下，注意一些需要换成 IP 地址的地方ETCD_NAME=\"controller\" ETCD_DATA_DIR=\"/var/lib/etcd\" ETCD_INITIAL_CLUSTER_STATE=\"new\" ETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster-01\" ETCD_INITIAL_CLUSTER=\"controller=http://10.0.24.13:2380\" ETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://10.0.24.13:2380\" ETCD_ADVERTISE_CLIENT_URLS=\"http://10.0.24.13:2379\" ETCD_LISTEN_PEER_URLS=\"http://0.0.0.0:2380\" ETCD_LISTEN_CLIENT_URLS=\"http://10.0.24.13:2379\" 启动 etcd 服务 systemctl enable etcd systemctl restart etcd 二、OpenStack 2.1 Keystone 进入root 进入 MySQL mysql -uroot -p 输入密码 或者 mysql 不用输入密码 CREATE DATABASE keystone; GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'%' IDENTIFIED BY 'admin'; 注意这里的 IDENTIFIED BY 后面的 admin，意思是设置 MySQL 中 keystone 用户的密码 安装 keystone 组件 sudo apt install keystone 安装一个小工具，方便修改配置文件 sudo apt install git sduo git config --global --unset http.https://github.com.proxy sudo git clone https://github.com/pixelb/crudini sudo apt install crudini 修改配置文件 sudo vi /etc/keystone/keystone.conf [database] \"mysql+pymysql://keystone:上面设置的密码@controller/keystone\" [token] provider fernet 也可以用 crudini： crudini --set /etc/keystone/keystone.conf database connection \"mysql+pymysql://keystone:admin@controller/keystone\" crudini --set /etc/keystone/keystone.conf token provider fernet 填充数据库 su -s /bin/sh -c \"keystone-manage db_sync\" keystone 初始化令牌仓库 keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone keystone-manage credential_setup --keystone-user keystone --keystone-group keystone 创建管理员用户 keystone-manage bootstrap --bootstrap-password admin \\ --bootstrap-admin-url http://controller:5000/v3/ \\ --bootstrap-internal-url http://controller:5000/v3/ \\ --bootstrap-public-url http://controller:5000/v3/ \\ --bootstrap-region-id RegionOne sudo vi /etc/apache2/apache2.conf 往文件中添加 ServerName controller 重启apache，sudo service apache2 restart 注意处在普通用户下，创建一个文件 vi adminrc_keystone，输入内容如下 export OS_USERNAME=admin export OS_PASSWORD=admin export OS_PROJECT_NAME=admin export OS_USER_DOMAIN_NAME=Default export OS_PROJECT_DOMAIN_NAME=Default export OS_AUTH_URL=http://controller:5000/v3 export OS_IDENTITY_API_VERSION=3 source adminrc_keystone 分别创建相应的domain、projects等： openstack project create --domain default --description \"Service Project\" service openstack project create --domain default --description \"Demo Project\" demo openstack user create --domain default --password demo demo openstack role create role_demo openstack role add --project demo --user demo role_demo 最后验证一下 openstack token issue 2.2 Glance CREATE DATABASE glance; GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'%' IDENTIFIED BY 'admin'; apt install glance -y openstack user create --domain default --password-prompt glance 或者 openstack user create --domain default --password admin glance openstack role add --project service --user glance admin openstack service create --name glance --description \"OpenStack Image\" image openstack endpoint create --region RegionOne image public http://controller:9292 openstack endpoint create --region RegionOne image internal http://controller:9292 openstack endpoint create --region RegionOne image admin http://controller:9292 sudo vi /etc/glance/glance-api.conf [database] 1746 # ... connection = mysql+pymysql://glance:admin@controller/glance [glance_store] 3141 # ... stores = file,http default_store = file filesystem_store_datadir = /var/lib/glance/images/ [keystone_authtoken] 4970 # ... www_authenticate_uri = http://controller:5000 auth_url = http://controller:5000 memcached_servers = controller:11211 auth_type = password project_domain_name = Default user_domain_name = Default project_name = service username = glance password = admin [oslo_limit] auth_url = http://controller:5000 auth_type = password user_domain_id = default username = glance system_scope = all password = admin service_name = glance region_name = RegionOne [paste_deploy] 5685 # ... flavor = keystone 处于普通用户下，授予glance用户权限 openstack role add --user glance --user-domain Default --system all reader 填充数据库 su -s /bin/sh -c \"glance-manage db_sync\" glance 重启服务 service glance-api restart 下载镜像 wget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img 上传 glance glance image-create --name \"cirros\" \\ --file cirros-0.4.0-x86_64-disk.img \\ --disk-format qcow2 --container-format bare \\ --visibility=public 可以使用 openstack image list 或者 glance image-list 查看镜像 2.3 Placement CREATE DATABASE placement; GRANT ALL PRIVILEGES ON placement.* TO 'placement'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON placement.* TO 'placement'@'%' IDENTIFIED BY 'admin'; openstack user create --domain default --password admin placement openstack role add --project service --user placement admin openstack service create --name placement --description \"Placement API\" placement openstack endpoint create --region RegionOne placement public http://controller:8778 openstack endpoint create --region RegionOne placement internal http://controller:8778 openstack endpoint create --region RegionOne placement admin http://controller:8778 apt install placement-api crudini --set /etc/placement/placement.conf placement_database connection \"mysql+pymysql://placement:admin@controller/placement\" crudini --set /etc/placement/placement.conf api auth_strategy \"keystone\" crudini --set /etc/placement/placement.conf keystone_authtoken auth_url \"http://controller:5000/v3\" crudini --set /etc/placement/placement.conf keystone_authtoken memcached_servers \"controller:11211\" crudini --set /etc/placement/placement.conf keystone_authtoken auth_type \"password\" crudini --set /etc/placement/placement.conf keystone_authtoken project_domain_name \"Default\" crudini --set /etc/placement/placement.conf keystone_authtoken user_domain_name \"Default\" crudini --set /etc/placement/placement.conf keystone_authtoken project_name \"service\" crudini --set /etc/placement/placement.conf keystone_authtoken username \"placement\" crudini --set /etc/placement/placement.conf keystone_authtoken password admin echo 'succeed to config placement.conf [keystone_authtoken]' su -s /bin/sh -c \"placement-manage db sync\" placement echo 'succeed to fullfill placement database' service apache2 restart echo 'succeed restart apache2' 验证是否配置好 placement-status upgrade check pip3 install osc-placement 2.4 Nova 因为是allinone的模式，所以先执行控制节点，然后再执行计算节点 CREATE DATABASE nova_api; CREATE DATABASE nova; CREATE DATABASE nova_cell0; GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'%' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'%' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON nova_cell0.* TO 'nova'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON nova_cell0.* TO 'nova'@'%' IDENTIFIED BY 'admin'; openstack user create --domain default --password admin nova openstack role add --project service --user nova admin openstack service create --name nova --description \"OpenStack Compute\" compute openstack endpoint create --region RegionOne compute public http://controller:8774/v2.1 openstack endpoint create --region RegionOne compute internal http://controller:8774/v2.1 openstack endpoint create --region RegionOne compute admin http://controller:8774/v2.1 控制节点 apt install nova-api nova-conductor nova-novncproxy nova-scheduler vi /etc/nova/nova.conf [api_database] 1090 connection = mysql+pymysql://nova:admin@10.0.24.13/nova_api [database] 1775 connection = mysql+pymysql://nova:admin@10.0.24.13/nova [default] transport_url = rabbit://openstack:admin@10.0.24.13:5672/ [api] 880 auth_strategy = keystone [keystone_authtoken] 2700 www_authenticate_uri = http://10.0.24.13:5000/ auth_url = http://10.0.24.13:5000/ memcached_servers = 10.0.24.13:11211 auth_type = password project_domain_name = Default user_domain_name = Default project_name = service username = nova password = admin [DEFAULT] my_ip = 10.0.24.13 [vnc] 5373 enabled = true server_listen = 10.0.24.13 server_proxyclient_address = 10.0.24.13 [glance] 2078 api_servers = http://10.0.24.13:9292 [oslo_concurrency] 3767 lock_path = /var/lib/nova/tmp [placement] 4335 region_name = RegionOne project_domain_name = Default project_name = service auth_type = password user_domain_name = Default auth_url = http://10.0.24.13:5000/v3 username = placement password = admin crudini --set /etc/nova/nova.conf api_database connection \"mysql+pymysql://nova:admin@controller/nova_api\" crudini --set /etc/nova/nova.conf database connection \"mysql+pymysql://nova:admin@controller/nova\" crudini --set /etc/nova/nova.conf DEFAULT transport_url \"rabbit://openstack:admin@controller:5672/\" crudini --set /etc/nova/nova.conf api auth_strategy \"keystone\" echo 'succeed to config database ,DEFAULT ,api in nova.conf' crudini --set /etc/nova/nova.conf keystone_authtoken www_authenticate_uri \"http://controller:5000/\" crudini --set /etc/nova/nova.conf keystone_authtoken auth_url \"http://controller:5000/\" crudini --set /etc/nova/nova.conf keystone_authtoken memcached_servers \"controller:11211\" crudini --set /etc/nova/nova.conf keystone_authtoken auth_type password crudini --set /etc/nova/nova.conf keystone_authtoken project_domain_name Default crudini --set /etc/nova/nova.conf keystone_authtoken user_domain_name Default crudini --set /etc/nova/nova.conf keystone_authtoken project_name service crudini --set /etc/nova/nova.conf keystone_authtoken username nova crudini --set /etc/nova/nova.conf keystone_authtoken password admin echo 'succeed to config keystone_authtoken in nova.conf' crudini --set /etc/nova/nova.conf DEFAULT my_ip 10.0.24.13 crudini --set /etc/nova/nova.conf vnc enabled true crudini --set /etc/nova/nova.conf vnc my_ip 10.0.24.13 crudini --set /etc/nova/nova.conf glance api_servers \"http://controller:9292\" crudini --set /etc/nova/nova.conf oslo_concurrency lock_path \"/var/lib/nova/tmp\" echo 'succeed config my_ip ,vnc ,glance in nova.conf' crudini --set /etc/nova/nova.conf placement region_name RegionOne crudini --set /etc/nova/nova.conf placement project_domain_name Default crudini --set /etc/nova/nova.conf placement project_name service crudini --set /etc/nova/nova.conf placement auth_type password crudini --set /etc/nova/nova.conf placement user_domain_name Default crudini --set /etc/nova/nova.conf placement auth_url \"http://controller:5000/v3\" crudini --set /etc/nova/nova.conf placement username placement crudini --set /etc/nova/nova.conf placement password admin echo 'succeed to config placement in nova.conf' su -s /bin/sh -c \"nova-manage api_db sync\" nova echo 'succeed to sync nova api database' su -s /bin/sh -c \"nova-manage cell_v2 map_cell0\" nova echo 'succeed to register cell0 database' su -s /bin/sh -c \"nova-manage cell_v2 create_cell --name=cell1 --verbose\" nova su -s /bin/sh -c \"nova-manage db sync\" nova echo 'succeed to fullfill nova database' su -s /bin/sh -c \"nova-manage cell_v2 list_cells\" nova service nova-api restart service nova-scheduler restart service nova-conductor restart service nova-novncproxy restart 下面是计算节点 apt install nova-compute vi /etc/nova/nova.conf [DEFAULT] transport_url = rabbit://openstack:admin@10.0.24.13 [api] auth_strategy = keystone [keystone_authtoken] www_authenticate_uri = http://10.0.24.13:5000/ auth_url = http://10.0.24.13:5000/ memcached_servers = 10.0.24.13:11211 auth_type = password project_domain_name = Default user_domain_name = Default project_name = service username = nova password = admin [DEFAULT] my_ip = 10.0.24.13 [vnc] enabled = true server_listen = 0.0.0.0 server_proxyclient_address = 10.0.24.13 novncproxy_base_url = http://10.0.24.13:6080/vnc_auto.html [glance] api_servers = http://10.0.24.13:9292 [oslo_concurrency] lock_path = /var/lib/nova/tmp [placement] region_name = RegionOne project_domain_name = Default project_name = service auth_type = password user_domain_name = Default auth_url = http://10.0.24.13:5000/v3 username = placement password = admin crudini --set /etc/nova/nova.conf DEFAULT transport_url \"rabbit://openstack:admin@controller\" crudini --set /etc/nova/nova.conf api auth_strategy keystone echo 'succeed to config database ,api in nova.conf' crudini --set /etc/nova/nova.conf keystone_authtoken www_authenticate_uri \"http://controller:5000/\" crudini --set /etc/nova/nova.conf keystone_authtoken auth_url \"http://controller:5000/\" crudini --set /etc/nova/nova.conf keystone_authtoken memcached_servers \"controller:11211\" crudini --set /etc/nova/nova.conf keystone_authtoken auth_type password crudini --set /etc/nova/nova.conf keystone_authtoken project_domain_name Default crudini --set /etc/nova/nova.conf keystone_authtoken user_domain_name Default crudini --set /etc/nova/nova.conf keystone_authtoken project_name service crudini --set /etc/nova/nova.conf keystone_authtoken username nova crudini --set /etc/nova/nova.conf keystone_authtoken password admin echo 'succeed to config keystone_authtoken in nova.conf' crudini --set /etc/nova/nova.conf DEFAULT my_ip 10.0.24.13 crudini --set /etc/nova/nova.conf vnc enabled true crudini --set /etc/nova/nova.conf vnc server_listen \"0.0.0.0\" crudini --set /etc/nova/nova.conf vnc server_proxyclient_address 10.0.24.13 crudini --set /etc/nova/nova.conf vnc novncproxy_base_url \"http://controller:6080/vnc_auto.html\" echo 'succeed to config vnc in nova.conf' crudini --set /etc/nova/nova.conf glance api_servers \"http://controller:9292\" crudini --set /etc/nova/nova.conf oslo_concurrency lock_path \"/var/lib/nova/tmp\" echo 'succeed to config glance ,oslo_concurrency in nova.conf' crudini --set /etc/nova/nova.conf placement region_name RegionOne crudini --set /etc/nova/nova.conf placement project_domain_name Default crudini --set /etc/nova/nova.conf placement project_name service crudini --set /etc/nova/nova.conf placement auth_type password crudini --set /etc/nova/nova.conf placement user_domain_name Default crudini --set /etc/nova/nova.conf placement auth_url \"http://controller:5000/v3\" crudini --set /etc/nova/nova.conf placement username placement crudini --set /etc/nova/nova.conf placement password admin echo 'succeed to config placement in nova.conf' crudini --set /etc/nova/nova-compute.conf libvirt virt_type qemu service nova-compute restart echo 'succeed to restart nova-compute' 2.5 Neutron 先是控制节点 CREATE DATABASE neutron; GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'localhost' IDENTIFIED BY 'admin'; GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'%' IDENTIFIED BY 'admin'; openstack user create --domain default --password admin neutron openstack role add --project service --user neutron admin openstack service create --name neutron --description \"OpenStack Networking\" network openstack endpoint create --region RegionOne network public http://controller:9696 openstack endpoint create --region RegionOne network internal http://controller:9696 openstack endpoint create --region RegionOne network admin http://controller:9696 选择创建自服务服务网络 apt install neutron-server neutron-plugin-ml2 neutron-linuxbridge-agent neutron-l3-agent neutron-dhcp-agent neutron-metadata-agent crudini --set /etc/neutron/neutron.conf database connection \"mysql+pymysql://neutron:admin@controller/neutron\" crudini --set /etc/neutron/neutron.conf DEFAULT core_plugin ml2 crudini --set /etc/neutron/neutron.conf DEFAULT service_plugins router crudini --set /etc/neutron/neutron.conf DEFAULT allow_overlapping_ips true crudini --set /etc/neutron/neutron.conf DEFAULT transport_url \"rabbit://openstack:admin@controller\" crudini --set /etc/neutron/neutron.conf DEFAULT auth_strategy keystone crudini --set /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_status_changes true crudini --set /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_data_changes true echo 'succeed to config DEFAULT in neutron.conf' crudini --set /etc/neutron/neutron.conf keystone_authtoken www_authenticate_uri \"http://controller:5000\" crudini --set /etc/neutron/neutron.conf keystone_authtoken auth_url \"http://controller:5000\" crudini --set /etc/neutron/neutron.conf keystone_authtoken memcached_servers \"controller:11211\" crudini --set /etc/neutron/neutron.conf keystone_authtoken auth_type password crudini --set /etc/neutron/neutron.conf keystone_authtoken project_domain_name Default crudini --set /etc/neutron/neutron.conf keystone_authtoken user_domain_name Default crudini --set /etc/neutron/neutron.conf keystone_authtoken project_name service crudini --set /etc/neutron/neutron.conf keystone_authtoken username neutron crudini --set /etc/neutron/neutron.conf keystone_authtoken password admin echo 'succeed to config keystone_authtoken in neutron.conf' crudini --set /etc/neutron/neutron.conf nova auth_url \"http://controller:5000\" crudini --set /etc/neutron/neutron.conf nova auth_type password crudini --set /etc/neutron/neutron.conf nova project_domain_name Default crudini --set /etc/neutron/neutron.conf nova user_domain_name Default crudini --set /etc/neutron/neutron.conf nova region_name RegionOne crudini --set /etc/neutron/neutron.conf nova project_name service crudini --set /etc/neutron/neutron.conf nova username nova crudini --set /etc/neutron/neutron.conf nova password admin echo 'succeed to config nova in neutron.conf' crudini --set /etc/neutron/neutron.conf oslo_concurrency lock_path \"/var/lib/neutron/tmp\" echo 'succeed to config oslo_concurrency in neutron.conf' crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 type_drivers \"flat,vlan,vxlan\" crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 tenant_network_types vxlan crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 mechanism_drivers \"linuxbridge,l2population\" crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 extension_drivers port_security echo 'succeed to config ml2 in ml2_conf.conf' crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_flat flat_networks provider crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini securitygroup enable_ipset true crudini --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_vxlan vni_ranges \"1:1000\" echo 'succeed to config ml2_type_* in ml2_conf.conf' # 注意这里的 ens33 crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini linux_bridge physical_interface_mappings \"provider:eth0\" crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan true crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.0.24.13 crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population true crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group true crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver \"neutron.agent.linux.iptables_firewall.IptablesFirewallDriver\" echo 'succeed to config linuxbridge.conf' crudini --set /etc/neutron/l3_agent.ini DEFAULT interface_driver linuxbridge echo 'succeed to config l3_agent.conf' crudini --set /etc/neutron/dhcp_agent.ini DEFAULT interface_driver linuxbridge crudini --set /etc/neutron/dhcp_agent.ini DEFAULT dhcp_driver \"neutron.agent.linux.dhcp.Dnsmasq\" crudini --set /etc/neutron/dhcp_agent.ini DEFAULT enable_isolated_metadata true echo 'succeed to config dhcp_agent.conf' crudini --set /etc/neutron/metadata_agent.ini DEFAULT nova_metadata_host controller crudini --set /etc/neutron/metadata_agent.ini DEFAULT metadata_proxy_shared_secret 123456 echo 'succeed to config metadata_agent.conf' crudini --set /etc/nova/nova.conf neutron auth_url \"http://controller:5000\" crudini --set /etc/nova/nova.conf neutron auth_type password crudini --set /etc/nova/nova.conf neutron project_domain_name Default crudini --set /etc/nova/nova.conf neutron user_domain_name Default crudini --set /etc/nova/nova.conf neutron region_name RegionOne crudini --set /etc/nova/nova.conf neutron project_name service crudini --set /etc/nova/nova.conf neutron username neutron crudini --set /etc/nova/nova.conf neutron password admin crudini --set /etc/nova/nova.conf neutron service_metadata_proxy true crudini --set /etc/nova/nova.conf neutron metadata_proxy_shared_secret 123456 echo 'succeed to config neutron in nova.conf' su -s /bin/sh -c \"neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head\" neutron echo 'succeed to fullfill neutron database' service nova-api restart service neutron-server restart service neutron-linuxbridge-agent restart service neutron-dhcp-agent restart service neutron-metadata-agent restart service neutron-l3-agent restart echo 'succeed to restart services' 计算节点 apt install neutron-linuxbridge-agent crudini --set /etc/neutron/neutron.conf DEFAULT transport_url \"rabbit://openstack:admin@controller\" crudini --set /etc/neutron/neutron.conf DEFAULT auth_strategy keystone echo 'succeed to config DEFAULT in neutron.conf' crudini --set /etc/neutron/neutron.conf keystone_authtoken www_authenticate_uri \"http://controller:5000\" crudini --set /etc/neutron/neutron.conf keystone_authtoken auth_url \"http://controller:5000\" crudini --set /etc/neutron/neutron.conf keystone_authtoken memcached_servers \"controller:11211\" crudini --set /etc/neutron/neutron.conf keystone_authtoken auth_type password crudini --set /etc/neutron/neutron.conf keystone_authtoken project_domain_name Default crudini --set /etc/neutron/neutron.conf keystone_authtoken user_domain_name Default crudini --set /etc/neutron/neutron.conf keystone_authtoken project_name service crudini --set /etc/neutron/neutron.conf keystone_authtoken username neutron crudini --set /etc/neutron/neutron.conf keystone_authtoken password admin echo 'succeed to config keystone_authtoken in neutron.conf' crudini --set /etc/neutron/neutron.conf oslo_concurrency lock_path \"/var/lib/neutron/tmp\" echo 'succeed to config oslo in neutron.conf' # 注意下面的provider:ens33，用ifconfig命令查看一下 crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini linux_bridge physical_interface_mappings \"provider:eth0\" crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan true crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.0.24.13 crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population true crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group true crudini --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver \"neutron.agent.linux.iptables_firewall.IptablesFirewallDriver\" echo 'succeed to config linuxbridge_agent.ini' crudini --set /etc/nova/nova.conf neutron auth_url \"http://controller:5000\" crudini --set /etc/nova/nova.conf neutron auth_type password crudini --set /etc/nova/nova.conf neutron project_domain_name Default crudini --set /etc/nova/nova.conf neutron user_domain_name Default crudini --set /etc/nova/nova.conf neutron region_name RegionOne crudini --set /etc/nova/nova.conf neutron project_name service crudini --set /etc/nova/nova.conf neutron username neutron crudini --set /etc/nova/nova.conf neutron password admin echo 'succeed to config neutron in nova.conf' service nova-compute restart service neutron-linuxbridge-agent restart echo 'succeed to restart services' 验证 openstack extension list --network openstack network agent list 2.6 Horizon apt install openstack-dashboard vi /etc/openstack-dashboard/local_settings.py 126 OPENSTACK_HOST = \"controller\" 399 ALLOWED_HOSTS = ['*'] 112 SESSION_ENGINE = 'django.contrib.sessions.backends.cache' CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', 'LOCATION': 'controller:11211', } } OPENSTACK_KEYSTONE_URL = \"http://%s:5000\" % OPENSTACK_HOST OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True OPENSTACK_API_VERSIONS = { \"identity\": 3, \"image\": 2, \"volume\": 3, } OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = \"Default\" OPENSTACK_KEYSTONE_DEFAULT_ROLE = \"member\" OPENSTACK_NEUTRON_NETWORK = { ... 'enable_router': False, 'enable_quotas': False, 'enable_ipv6': False, 'enable_distributed_router': False, 'enable_ha_router': False, 'enable_fip_topology_check': False, } TIME_ZONE = \"Asia/Shanghai\" 检验安装结果 nova-status upgrade check 使用可视化界面，浏览器访问 http://IP地址/horizon 账号密码即 adminrc_keystone 里面的内容 三、遇到的一些问题 3.1 ifconfig 命令无网络接口 ens33 不是接口不存在，只是接口没有UP。需要先启用网络，启用网络时会调用/sbin/dhclient，于是执行 sudo /sbin/dhclient 即可 3.2 log文件中报错 Failed to create resource provider controller mysql SHOW databases; USE nova-api; SELECT * FROM resource_provider; 数据库中的表resource_provider要是没有任何数据，应该是没有写入成功，所以可能是placement的相关权限出了问题 返回查看安装步骤中，配置文件是否出现错误 3.3 rabbitmq问题 https://blog.csdn.net/qq_41887560/article/details/106194494 注意 /etc/hosts 文件的配置 127.0.0.1 那一行后面需要加上 hostname 127.0.1.1 那一行需要注释掉 重启服务 sudo systemctl restart rabbitmq.server 查看状态 sudo systemctl status rabbitmq.server 3.4 dashboard 登陆认证失败，显示 invalid credentials vi /etc/openstack-dashboard/local_settings.py 修改端口号 3.5 如何创建flavor nova flavor-list nova flavor-create --is-public true boshen_ram_1024_disk_1_vcpus_1 boshen_ram_1024_disk_1_vcpus_1 1024 1 1 nova flavor-delete {name} 3.6 openstack用户管理 openstack user list openstack user delete glance openstack service list openstack service delete 3.7 运行 VNC 灰屏问题 配置防火墙端口 sudo -i sudo apt update sudo apt install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal ubuntu-desktop sudo apt-get install tightvncserver sudo vncserver sudo vi ~/.vnc/xstartup #!/bin/bash export $(dbus-launch) export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER gnome-panel & gnome-settings-daemon & metacity & nautilus & gnome-terminal & # [ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup # [ -r $HOME/.Xresources ] && xrdb $HOME/.Xresources xsetroot -solid grey vncconfig -iconic & x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" & gnome-session & VNCSERVERS=\"2:root\" VNCSERVERARGS[1]=\"-GEOMETRY 800×600\" sudo vncserver -kill :1 #杀掉原桌面进程，输入命令（其中的:1是桌面号） sudo vncserver -geometry 1920x1080 :1 #生成新的会话 下载 VNC viewer，https://www.realvnc.com/en/connect/download/viewer/ 参考文档 https://blog.csdn.net/qq_41037945/article/details/124286616 crudini工具，https://github.com/pixelb/crudini Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-23 22:50:37 "},"about_ForeignTrade/":{"url":"about_ForeignTrade/","title":"外贸记录","keywords":"","body":"About ForeignTrade 业务员学习 开发信内容 快速沟通模板 每日 英语语法问题 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-03 22:35:29 "},"about_ForeignTrade/业务员学习.html":{"url":"about_ForeignTrade/业务员学习.html","title":"业务员学习","keywords":"","body":"关于国际站 上产品链接 key ring 产品名称 2023 Promotional Wholesale 2D PVC Custom Creative New Arrival Variety Mountaineering Car Sedan Key Chains Rings Party Gifts for Kids 产品关键词 Keychain Sponge Doll Car Key Bag Accessories Cute Cartoon 3D Patrick Keychains PVC Silicone Keyring with Wrist Strap Key Chain Wholesale Anime Keychain Cute Cartoon 3D PVC Designer Kids Women Silicon Mini Backpack Key ring Accessories Rubber Key chains HOT wholesale cartoon character Custom Rubber 2D Soft pvc design Keychains customized anime keychain Key Chain via DHL/Fedex shoe charms 产品名称 2023 New Arrival Wholesale PVC Custom Design Cute Kawaii Summer Vacation Sandbeach Surfing Swim Fruit Shoe Charms Decorations Accessories 产品关键词 PVC Fashion Designer 2023 Shoe Charms Cute Cows New Arrival Dairy Cattle Shoe Decoration kawaii Shoe Parts&accessories charms 2023 New Arrival Wholesale PVC Custom Clog football basketball soccer sports team logo Shoe Charms Ornaments Custom Design Hot Sale Cheap Wholesale Anime Cartoon Led Designer Charms For Decorations Animation 自然流量 与自然排名有关，包括关键词的关联度、店铺的权重 关键词的匹配包括 完全（关键词完全拼写出现）、 正向（从左到右匹配）、 逆向、 模糊（客户未完全拼写出或者拼写错误，系统自动联想） 千人千面，买家搜索商品后进行点击，之后会根据点击的产品推荐相关的产品给买家 可能是同类型的，也可能是同一卖家的产品，这个会影响搜索的排名 目前形势是：店铺权重越来越重要，对自然排名的影响很大 P4P流量（付费） 直通车推广的方式越来越多 爆品助推 关键词推广 因为SKA、星等级权重变重、千人千面等出现，自然流量急剧减少 行业流量基本集中在几个主要的关键词上，权重低的排不上首页 P4P算是救命草 活动流量 报名有条件限制，例如商家星等级3星或者以上 但是活动流量是拉开店铺差距的很大一部分因素 点击率 图片、价格信息 年限、星等级、交易额、评分 内页 排版问题 逻辑顺序，客户关注点、产品卖点。。。 标题 先收集关键词 确定核心关键词。注意并不是所有买家的英语都好，关键词不在拼写是否正确，而是要关注它的搜索量 拓展词。产品特点、卖点、属性、使用场景 关键词归类？ 小技巧：若有相近含义的词汇，把多余的放在标题的最后面，提高句子的可读性 图片 搜索主图很关键 但是由于多数选品的卖家产品基本雷同，买家会优先查看价格最低的主图 图片底色不一定是白色 阿里的检测关键点是：靠近产品主体展示，注意不要靠近四周的边框 详情内页 目前搜索框的信息展示没有了企业名字和交易信息，一定程度上使得竞争更加公平 定价需要根据同行的情况定价，可以设置一个高MOQ，定一个优势价格，把客户吸引进来 产品参数如实填写，自定义参数根据客户关注点填写，以吸引客户 产品详情，需要先了解产品、市场、客户 产品的特征、使用场景、卖点 客户关注点是什么？数据需要好看，但是产出实际的业绩更重要 关于起草订单 先填写好客户的收件地址 在产品信息中添加产品 预付款到账后发货 到帐后30个自然日发货 一般选择自有物流 DAP 预付款100% 关于 RFQ 如何报价 首先，复制买家的RFQ标题去搜索，查看需求的商品样式是否合适 计算价格，编写留言。留言内容：公司简介、核心产品、资质认证 公司实力、工艺细节、时间 表达已经理解买家的需求，并能够提供需求的产品 专业的报价内容 诚恳的态度 全方位了解买家的情况：浏览记录、登陆天数、发布时间、金银铜牌 提供价格区间 持续跟进 关于快递 大批量船运 30~35+1天 线下 6~8+1天 10~12+1天 线上 15~18+1天 如何处理客户无应答的情况？ 首先保持联系（注意是联系并不是催单）。但是最多一周联系一次，且邮件的内容不要重复 内容可以是：告知企业动态、介绍新产品、宣布价格调整等等 接下来，对于反复无视邮件的，加一句话“如果我们的邮件打扰到您，请回复空白邮件，我们将会停止发送” 如果客户一直保持沉默，需要积极寻找突破，找机会例如折扣、活动什么的，报个价，打破僵局 了解客户沉默的原因，直接询问对产品是否感兴趣 关于海关数据 海关数据需要注意 时效性注意 退信率，由此可以了解海关数据的客户质量我们出口可能会走货运代理公司，那么客户进口的时候也会出现代理进口的情况。代理进口不是最后真正的买主！所以需要注意 进口代理存在的比例 是多少还要注意 数据的详细度，不能只有公司名字 塑料应用 聚乙烯（PE） 高密度：HDPE，热、电、机械性能更佳 低密度：LDPE， 线性密度：LLDPE，柔韧性、成膜性更佳 聚氯乙烯（PVC） 主要用于下水道管材、人造皮革、雨衣、塑料盒等，不能循环使用，不能用于包装食品 耐热性不好，大概最多80℃，高温容易产生有害物质 成本较低，具有自阻燃的特性 聚丙烯（PP） 品种更多，主要用在豆浆瓶、微波炉餐盒、食品包装、家具 造价成本高 聚苯乙烯（PS） 透明，可用于灯罩、透明杯罐等 PPS、PPO、PA、PC、POM 更多是在汽车、航天、建筑、通讯等领域 丙烯腈-丁二烯-苯乙烯共聚合物（ABS） 物理、机械、热性能杰出 主要用于家电、组合件、配件、玩具、环保商品 PMMA 亚克力，有机玻璃 优秀的抗化学物质，抗风化，视觉清晰度高，印刷附着性好 用于展示的标板、室内用品等等 聚碳酸酯（PC） 坚固但是重量轻，透明清晰，常作为玻璃的替代品 人造橡胶（TPE） 感觉像橡皮擦，有弹性，容易上色 抗撕拉、磨损，抗晒，防海水 可以用来作鞋底 材质 参考耐热温度范围 耐酸性 耐碱性 耐酒精 耐食用油类性 HDPE(高密度聚乙烯) 90~110℃ O O O O LDPE(低密度聚乙烯) 70~90℃ O O O O PVC(聚氯乙烯) 60~80℃ O O O O PP(聚丙烯) 100~130℃ O O O O PS(聚苯乙烯) 70~90℃ O O X X ABS(丙烯-丁二烯-苯乙烯树脂) 70~100℃ O O X O PC(聚碳酸脂) 120~130℃ O X O O PET(聚乙烯对苯二甲酸酯) 60~180℃ O O O O PMMA(压克力) 70~90℃ O O X O PLA(聚乳酸) 50~120℃ O O O O CopolyesterPETG(共聚合聚酯) 65~80℃ O O O O CopolyesterPCT(共聚合聚酯) 80~100℃ O O O O 美耐皿(仿瓷) 110~130℃ O O O O PES(聚醚砜) 195~215℃ O O O O PPSU(聚苯砜) 205~220℃ O O O O O 表示适用，X 表示不适用 塑料编号 01 PET(聚乙烯对苯二甲酸酯)矿泉水瓶、饮料瓶不能循环使用、不要装高温热水 02 HDPE(高密度聚乙烯)洗发水、沐浴露的瓶子该容器不易清洁，不推荐重复使用 03 PVC(聚氯乙烯)装饰材料高温容易产生有害物质，不要装温度高的食物日常生活中的塑料袋带有以下标志才是聚乙烯，否则是 PVC 04 LDPE(低密度聚乙烯)保鲜膜、塑料膜也不耐高温，不要随食物进微波炉 05 PP(聚丙烯)微波炉餐盒，但是注意其盖子的材质可以耐 100℃ 高温 06 PS(聚苯乙烯)快餐盒耐热 60~70℃，不要装过热食物 07 Other, PC(聚碳酸脂)水瓶、奶瓶有争议，需要小心可能会析出双酚 A 其他关键词 词汇含义 Importer（进口商）：指从国外购买商品并将其引入本国市场的商家或公司 Distributor（分销商）：指负责将产品从生产商或供应商那里购买，并将其分销给零售商或其他渠道的公司或个人 Buyer（买家）：指购买商品或服务的个人或公司 Company（公司）：指一个独立的法律实体，由一组人合作组成，从事商业活动 Wholesale（批发商）：指以较低的价格大量购买商品，并将其以较高的价格出售给零售商或其他渠道的商家 Retailer（零售商）：指直接面向消费者销售商品或服务的商家，通常以较高的价格出售商品 Supplier（供应商）：指提供商品、材料或服务给其他公司或个人的公司或个人 外贸 Soho 网络和计算机技术发展催生出的生产方式 smalloffic、homeoffic 在家办公，自己当中介、找工厂、找客户 掮(qian第二声)客 旧指介绍买卖，取得佣金的人 传真 地点对地点，用于传输涉密文件，有法律效力（可能存在争议） 邮件是人对人传输，保密性较弱 外贸单证 合同 发票 装箱单 提单 装船通知 保险单 各种检验项目的证明 原产地证 受益人证明 。。。。。。 HS 和 SIC 编码 HS 是海关编码，国际标准编码，将商品分类 SIC 是标准产业分类代码，美国政府设置的，方便收集描述、分析、数据 OEM、ODM E 指的是 Equipment，有生产机器 D 指的是 Design，除了有能力生产，还可以进行产品的设计 付款方式 https://zhidao.baidu.com/question/58320938.html hhhhhhh 看看就好 https://www.zhihu.com/question/323144916 参考资料 https://www.zhihu.com/question/453390436https://www.zhihu.com/question/460755586/answer/1970198054https://zhuanlan.zhihu.com/p/630559402https://zhuanlan.zhihu.com/p/542922166 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-08 22:31:17 "},"about_ForeignTrade/开发信内容.html":{"url":"about_ForeignTrade/开发信内容.html","title":"开发信内容","keywords":"","body":" 资料 Hello, excuse me. Have you seen any styles you like? span.sometext#test { display: inline-block; padding: 10px; font-weight: bold; font-size: 18px; background: linear-gradient(45deg, #ff0000, #00ff00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } AILILA 成立于 2005 年，位于中国鞋都——晋江，拥有美丽的风景和快速的经济发展。AILILA 拥有 15 台注塑机和 5 条装配线。AILILA 的成功得益于其强大的企业文化精神，遵守商业规则，始终以高质量和有竞争力的价格提供产品，以及最优质的服务。通过完善的企业文化和精神、严格的质量控制以及员工的努力，AILILA 在市场中处于不可撼动的地位。凭借强大的实力和高质量的服务，AILILA 赢得了客户的真诚信任，渴望与国内外经营者建立长期友好的商业关系 提示词 我需要发展客户，给一些潜在客户发送开发营销信。我提供一些信息，然后请您帮我写一封，希望内容专业、可靠且极具吸引力，能够提高客户查看信的概率。您可以适当扩展，字符数的话不要超过 800，谢谢。下面是我提供的一些信息： 公司名：...... 产品：shoe charms、key ring 特性：支持客户定制样式 用途：shoe charms可以用来装饰crocs、装饰bogg bag、收集；key ring可以当作附赠小礼品或者节假日小礼物 关于标题 新产品或者服务： 全新产品推出：解决您的问题 New product launch: solving your problem 创新服务，提升您的业务效率 Innovative services to enhance your business efficiency 解决方案： 您的业务面临的挑战有解决方案吗？ Do you have a solution to the challenges your business is facing? 满足您的需求，让您的生活更轻松 Meet your needs and make your life easier 分享行业事态： 您知道吗？我们的产品正在改变行业 Do you know? Our product is changing the industry 您错过了什么？了解我们的独特优势 What did you miss? Understand our unique advantages 优惠： 仅限您：享受特别优惠折扣 Only for you: Enjoy special discounts 首次购买，立即获得额外福利 First time purchase, immediately receive additional benefits 成功案例： 满意客户的故事：如何实现业务增长 The Story of Satisfying Customers: How to Achieve Business Growth 满足您的需求并提高您的业务成果 Meet your needs and increase your business outcomes 最好鞋花和钥匙扣分开营销 鞋花 尊敬的客户[customer_name]，我们是来自中国福建晋江的一家鞋和鞋饰品的生产商，Ailila，感谢您抽出时间阅读这封邮件，我想为您介绍我们的产品：shoe charms。 【写一下公司简介、规模、成就】 首先，我们生产的 shoe charms 采用 PVC 材质，柔韧不易坏，可以用来装饰 Crocs 和 Bogg bag，shoe charms 的尺寸一般为 3×3cm，也可以同图案款式一样根据客户的需求进行定制。无论您是想增添个人风格，还是追求收集不同款式鞋饰的爱好，我们都能满足您的需求。我相信 Crocs 和 Bogg bag 掀起的时尚潮流会使得 shoe charms 受到广泛关注，迎来非常高的热度。其次，我们在阿里巴巴国际站开设了店铺，提供数千款 RTS 商品，包括 2D 和 3D 款式，同时我们还 提供客制化服务。无论是 Logo、图案还是特定主题，我们都可以根据客户的要求来制作，力争为客户提供高品质、独具创意的产品。最后，我们的产品在 价格方面也很有竞争力。价格区间如下： >= 500 pieces, USD$0.10 per unit >= 1000 pieces, USD$0.08 per unit >= 5000 pieces, USD$0.06 per unit 我们公司库存充足，并且具备自主设计和生产制造的能力，我们拥有多条先进的生产线和经验丰富的工人团队，每天能够生产大量的鞋饰产品，以保证产品的数量和交货时间，满足您的大批量订单需求。如果我们有机会合作，我相信一定程度上可以为您节约采购的资金和时间成本。此外，我们始终坚持 严格的质量控制标准，确保每一件产品都符合客户的期望，竭尽全力为客户提供最好的产品和服务。 【展示客户反馈、产品评价、成功案例】 感谢您抽出时间阅读这封邮件。如果您对我们的产品或服务有任何疑问或需求，请随时回复邮件与我联系。我们期待能够与您建立长期的合作关系，并为您提供优质的产品和满意的服务。祝您一切顺利，[你的名字] Dear [customer_name], We are a footwear and shoe decorations manufacturer from Jinjiang, Fujian, China, Ailila. Thank you for taking the time to read this email. I would like to introduce our product: shoe charms. Firstly, our shoe charms are made of PVC material, which is flexible and durable. They can be used to decorate Crocs and Bogg bags. The standard size of our shoe charms is 3×3cm, but we can also customize them according to customer requirements, including patterns and styles. Whether you want to add a personal touch or pursue a collection of different shoe charms, we can meet your needs. I believe that the fashion trend created by Crocs and Bogg bags will bring widespread attention and high demand for shoe charms. Secondly, we have an online store on Alibaba International, offering thousands of ready-to-ship (RTS) products, including 2D and 3D designs. Additionally, we provide customization services. Whether it's a logo, pattern, or specific theme, we can create products based on customer requirements, aiming to deliver high-quality and creative items. Finally, our prices are highly competitive. The price ranges are as follows: >= 500 pieces, USD$0.10 per unit >= 1000 pieces, USD$0.08 per unit >= 5000 pieces, USD$0.06 per unit We have sufficient inventory and the capability of independent design and manufacturing. With multiple advanced production lines and an experienced team of workers, we can produce a large quantity of shoe charms daily, ensuring the quantity and delivery time to meet your bulk order needs. If given the opportunity to cooperate, I believe we can help you save on procurement costs and time. Furthermore, we adhere to strict quality control standards to ensure that every product meets customer expectations, striving to provide the best products and services. Thanks again for taking the time to read this email. If you have any questions or requirements regarding our products or services, please feel free to reply to this email and contact me. We look forward to establishing a long-term partnership with you and providing you with high-quality products and satisfactory service. Best regards, [Your Name] 钥匙扣 尊敬的客户[customer_name]，我们是来自中国福建晋江的一家鞋和鞋饰品的生产商，Ailila，感谢您抽出时间阅读这封邮件，我想为您介绍我们的产品：key ring。 【写一下公司简介、规模、成就】 首先，我们生产的 key ring 采用 PVC 材质，柔韧不易坏且带有钥匙环，是一款非常实用的产品。广泛应用于俱乐部、店铺等，可以当作促销时的附赠小礼品，用于推广活动，增加客户的忠诚度，又或者作为纪念品，还可以作为节假日的派对小礼物赠予孩子们，这会让钥匙扣更加有意义和特别。其次，我们在阿里巴巴国际站开设了店铺，提供数千款 RTS 商品，包括 2D 和 3D 款式，同时我们还 提供客制化服务。无论是 Logo、图案还是特定主题，我们都可以根据客户的要求来制作，力争为客户提供高品质、独具创意的产品。最后，我们的产品在 价格方面也很有竞争力。价格区间如下： >= 500 pieces, USD$0.12 per unit >= 1000 pieces, USD$0.10 per unit >= 5000 pieces, USD$0.08 per unit 我们公司库存充足，并且具备自主设计和生产制造的能力，我们拥有？？？条先进的生产线和经验丰富的工人团队，每天能够生产大量的产品，以保证产品的数量和交货时间，满足您的大批量订单需求。如果我们有机会合作，我相信一定程度上可以为您节约采购的资金和时间成本。此外，我们始终坚持 严格的质量控制标准，确保每一件产品都符合客户的期望，竭尽全力为客户提供最好的产品和服务。 【展示一下客户反馈、产品评价、成功案例】 感谢您抽出时间阅读这封邮件。如果您对我们的产品或服务有任何疑问或需求，请随时回复邮件与我联系。我们期待能够与您建立长期的合作关系，并为您提供优质的产品和满意的服务。祝您一切顺利，[你的名字] Dear [$name], We are a footwear and shoe decorations manufacturer from Jinjiang, Fujian, China, Ailila. Thank you for taking the time to read this email. I would like to introduce our product: key rings. I have learned that your company is involved in the retail industry. Key ring is a practical and hot commodity, I believe it will be loved by customers in your store. I hope that we can have further discussions and discuss the possibility of cooperation. Firstly, our key rings are made of PVC material, which is flexible, durable, and equipped with a keychain. It is a practical product that is widely used in clubs, shops, etc. It can be used as a promotional giveaway to increase customer loyalty, or as a souvenir. It can also be given as a small gift for parties during holidays, making the key ring more meaningful and special. Secondly, we have an online store on Alibaba International, offering thousands of ready-to-ship (RTS) products, including 2D and 3D designs. Additionally, we provide customization services. Whether it's a logo, pattern, or specific theme, we can create products based on customer requirements, aiming to deliver high-quality and creative items. Finally, our prices are highly competitive. The price ranges are as follows: >= 500 pieces, USD$0.12 per unit >= 1000 pieces, USD$0.10 per unit >= 5000 pieces, USD$0.08 per unit We have sufficient inventory and the capability of independent design and manufacturing. With multiple advanced production lines and an experienced team of workers, we can produce a large quantity of products daily, ensuring the quantity and delivery time to meet your bulk order needs. If given the opportunity to cooperate, I believe we can help you save on procurement costs and time. Furthermore, we adhere to strict quality control standards to ensure that every product meets customer expectations, striving to provide the best products and services. Thanks again for taking the time to read this email. If you have any questions or requirements regarding our products or services, please feel free to reply to this email and contact me. We look forward to establishing a long-term partnership with you. Best regards, [$contacts_name] 吸管 与一次性塑料吸管相比，我们生产的 PET 螺旋吸管可重复使用。我们注重使用者的健康与安全，螺旋吸管采用无毒无害的材质制成，不会对您的健康造成任何负面影响。无论是冷饮还是热饮，螺旋吸管都能完美适应。它的螺旋形状美观大方，能让您更加享受品尝饮品的时刻。为了满足不同客户的需求，我们提供个性化定制服务。您可以根据自己的喜好定制螺旋吸管的颜色、形状，并且可以在顶部添加极具个性化的装饰品，让您的螺旋吸管与众不同。 Dear [customer_name], I hope this email finds you well. We are a footwear and other decorations manufacturer from Jinjiang, Fujian, China, Ailila. Thank you for taking the time to read this email. I would like to introduce our product: spiral straw. Firstly, our spiral straws are exquisite and durable made with PET material. Compared to disposable plastic straws, our PET spiral straws are reusable. We pay attention to the health and safety of users, and the spiral straws are made of non-toxic and harmless materials, which will not have any negative impact on your health. Whether it's cold drink or hot drink, the spiral straw can perfectly adapt. Secondly, we have an online store on Alibaba International, offering many ready-to-ship (RTS) products. Our spiral straw can be a uniquely designed artwork. Its spiral shape is beautiful and generous, allowing you to enjoy the moment of tasting drinks more. In order to meet the needs of different customers, we provide personalized customization services. You can customize the color and shape of the spiral straw according to your preferences, and add personalized PVC decorations at the top to make your spiral straw unique. Finally, our prices are highly competitive. The price range is as follow: >= 1000 pieces, USD$0.20 per unit We have sufficient inventory and the capability of independent design and manufacturing. With multiple advanced production lines and an experienced team of workers, we can produce a large quantity of products daily, ensuring the quantity and delivery time to meet your bulk order needs. If given the opportunity to cooperate, I believe we can help you save on procurement costs and time. Furthermore, we adhere to strict quality control standards to ensure that every product meets customer expectations, striving to provide the best products and services. Thanks again for taking the time to read this email. If you have any questions or requirements regarding our products or services, please feel free to reply to this email and contact me. We look forward to establishing a long-term partnership with you and providing you with high-quality products and satisfactory service. Best regards, [Your Name] 拖鞋 标题：Hello, Interested in 【Footwear/Slippers】 direct sourcing? Could you please give me 2 minutes? 尊敬的客户， 感谢您能抽出时间阅读这封邮件，我了解到贵公司有涉及鞋类贸易的领域 【注意这里可以从客户的公司官网寻找素材，例如他们的核心价值，一些关键标语】，我相信您对我们的产品和服务一定会感兴趣。我们公司是一家专业从事软质塑料系列产品的制造商，晋江艾丽拉鞋服有限公司。作为一家现代化的公司，Ailila集生产和销售于一体，涉及EVA凉鞋、EVA人字拖、帆布鞋、EVA冬季鞋、PVC鞋饰等产品。 今天我想向您介绍的产品是 EVA 拖鞋。EVA材质是一种轻质材料，相比于橡胶、皮革等材料，EVA材质拖鞋更轻便，穿着更加舒适。此外，EVA材质具有较高的耐磨性，能够经受长时间的使用和摩擦而不容易磨损。我们的EVA材质拖鞋的鞋底有特殊的纹路设计，增加了与地面的摩擦力，提高了防滑性能，减少了滑倒的风险。总之，它市场广阔，适合于家庭或者旅行度假使用，为您提供舒适的体验。 作为一家有多年经验的制造商，我们拥有 15 台注塑机和 5 条装配线，以及高素质的员工团队。我们的 EVA 拖鞋有多种款式和颜色可供选择，以满足不同客户的需求。我们注重产品质量，通过严格的质量控制和检测，是中国制造网认证过的供应商。如果我们有机会合作，我们将竭诚为您提供最满意的解决方案，我相信一定程度上可以为您节约采购的资金和时间成本【明确合作的利益】。 最后再次感谢您抽出时间阅读这封邮件。如果您对我们的产品或服务有任何疑问或需求，请随时与我联系。 祝您一切顺利， [你的名字] Dear, Thank you for taking the time to read this email. I have learned that your company is involved in the field of footwear industry. I know your company's goal is to help people find fashionable, comfortable footwear to match people lifestyle. I believe you will be interested in our products and services. Our company is a professional manufacturer of soft plastic series products, Jinjiang Ailila Shoes and Clothing Co., Ltd. As a modern company, Ailila integrates production and sales, covering products such as EVA sandals, EVA flip flops, canvas shoes, EVA winter shoes, PVC shoe accessories, etc. The product I want to introduce to you today is EVA slippers. EVA material is a lightweight material. Compared to materials such as rubber and leather, EVA material slippers are lighter and more comfortable to wear. In addition, EVA material has high wear resistance and can withstand long-term use and friction without being easily worn. Our EVA material slippers have a special pattern design on the sole, which increases friction with the ground, improves slip resistance, and reduces the risk of slipping. In short, it has a broad market and is suitable for family or travel vacations, providing you with a comfortable experience. As a manufacturer with many years of experience, we have 15 injection molding machines and 5 assembly lines, as well as a high-quality team of employees. Our EVA slippers come in various styles and colors to meet the needs of different customers. We focus on product quality and are a certified supplier on Made-in-China, which is achieved through strict quality control and testing. If we have the opportunity to cooperate, we will wholeheartedly provide you with the most satisfactory solution. I believe that to a certain extent, it can save you the cost of procurement and time. Finally, thank you again for taking the time to read this email. If you have any questions or needs about our products or services, please feel free to contact me. Wishing you all the best, Eden 鞋子大类 尊敬的客户， 我代表我们公司向您致以诚挚的问候，感谢您抽出时间阅读这封邮件！我了解到贵公司涉足鞋业，我相信您对我们的产品和服务一定会感兴趣。我们公司是一家专业从事软质塑料系列产品的制造商，晋江艾丽拉鞋服有限公司。作为一家现代化的公司，Ailila集生产和销售于一体，涉及EVA凉鞋、EVA人字拖、帆布鞋、EVA冬季鞋、PVC鞋饰等产品。 我们生产的运动鞋有着卓越的性能和时尚的外观设计。性能方面，特殊缓震中底能够减轻脚部压力，提供舒适的脚感，并帮助消费者在运动中发挥更棒的水平；外观设计方面也是独具匠心，例如夜晚发光设计，特殊鞋面纹路设计等等，让消费者在日常穿搭中也能游刃有余，无论是搭配运动装还是休闲服饰，都能一展消费者的个性和时尚品味。此外，还有EVA拖鞋等等产品。 作为一家有多年经验的制造商，我们拥有 15 台注塑机和 5 条装配线，以及高素质的员工团队。我们注重产品质量，通过严格的质量控制和检测，确保每一双拖鞋都符合国际标准。此外，我们还可以根据客户的需求提供定制服务，包括颜色、尺码等方面的个性化定制。价格方面也是很有竞争力，如果我们有机会合作，我相信一定程度上可以为您节约采购的资金和时间成本。 最后再次感谢您抽出时间阅读这封邮件。如果您对我们的产品或服务有任何疑问或需求，请随时回复邮件与我联系，我们希望听到您的宝贵意见，谢谢。祝您一切顺利，[你的名字] CONTACT US ADD：2nd Floor No.227 Heping North Road, Sucuo, Chendai, Jinjiang, Quanzhou, Fujian, China TEL：+86-595-85635811 FAX：+86-595-85678711 E-MAIL：eden@kaopushoes.com Website: www.aililashoes.com Dear [$name], On behalf of our company, I extend sincere greetings to you! Thank you for taking the time to read this email! I understand that your company is involved in the shoe industry, and I believe that you will be interested in our products and services. Our company is a professional manufacturer of soft plastic series products, Fujian Jinjiang Ailila Shoes and Clothing Co., Ltd, China. As a modern company, Ailila integrates production and sales, covering products such as EVA sandals, EVA flip flops, canvas shoes, EVA winter shoes, PVC shoe accessories, etc. Our sports shoes have excellent performance and fashionable appearance design. In terms of performance, the special cushioning midsole can reduce foot pressure, provide a comfortable foot feel, and help consumers perform better in sports; In terms of appearance design, it is also unique, such as luminous design at night, special shoe upper pattern design, etc., allowing consumers to easily wear and match in daily life. Whether paired with sportswear or casual clothing, it can showcase consumers' personality and fashion taste. In addition, there are products such as EVA slippers. As a manufacturer with many years of experience, we have 15 injection molding machines and 5 assembly lines, as well as a high-quality team of employees. We focus on product quality and ensure that every pair of slippers meets international standards through strict quality control and testing. In addition, we can also provide customized services according to customer needs, including personalized customization of colors, sizes, and other aspects. In terms of price, it is also very competitive. If we have the opportunity to cooperate, I believe it can save you procurement funds and time costs to a certain extent. Finally, thank you again for taking the time to read this email. If you have any questions or needs regarding our products or services, please feel free to reply to this email and contact me. We would love to hear your valuable feedback. Thank you. Best regards, [$contacts_name] CONTACT US ADD：2nd Floor No.227 Heping North Road, Sucuo, Chendai, Jinjiang, Quanzhou, Fujian, China TEL：+86-595-85635811 FAX：+86-595-85678711 E-MAIL：eden@kaopushoes.com Website：www.aililashoes.com 市场信息分享 标题：Sharing 【PVC keychain】 market information with you PVC 钥匙扣作为一种可定制的配饰，可以通过不同的图案、颜色和形状来满足消费者的个性化需求。PVC钥匙扣市场竞争激烈，但也存在着巨大的市场机会。通过提供创新设计、高质量材料和定制化服务，可以在市场中脱颖而出 例如旅游纪念品市场就是一个庞大的市场，人们在旅行时喜欢购买纪念品来纪念他们的旅程。PVC钥匙扣可以作为一种经济实惠且易于携带的纪念品选择，可以印上旅游景点、地标或特色图案 以下是一些在设计、生产和销售PVC鞋饰和PVC钥匙扣方面可能会提供帮助的几点： 1、定制化服务：提供定制化服务可以增加产品的独特性和个性化。通过与客户合作，根据他们的要求设计和生产定制化的PVC鞋饰和钥匙扣，并尝试结合流行元素和时尚趋势，来增加产品的吸引力。 2、材料选择和质量控制：选择高质量的原材料对于生产出优质的鞋饰和钥匙扣至关重要。确保材料具有耐用性、柔软性和环保性，制定严格的质量控制流程和检测标准 3、市场推广和销售渠道：在线上渠道，可以建立自己的品牌网站和社交媒体平台，展示产品的特点和优势，并与潜在客户进行互动。在线下渠道，可以与零售商、旅游景点、旅行社等合作，将产品展示在实体店面或旅游纪念品店中，进一步扩大市场份额 4、客户反馈和售后服务：及时收集客户的问题和反馈，并持续改进产品和服务质量，以建立良好的口碑和品牌形象 很高兴与您分享这些信息，我们公司就是一家专业从事软质塑料系列产品的制造商，晋江艾丽拉鞋服有限公司，生产的产品包括但不限于 PVC 鞋饰等。若有任何问题都可以与我交流，期待您的回复。 祝您一切顺利， [你的名字] Dear, Thank you for taking the time to read this email. I have learned that your company's sales products include key chain. As a customizable accessory, PVC keychains can meet the personalized needs of consumers through different patterns, colors, and shapes. The PVC keychain market is fiercely competitive, but there are also huge market opportunities. For example, the tourism souvenir market is a huge market, and people like to buy souvenirs to commemorate their journey when traveling. PVC keychains can be used as an economical and easy to carry souvenir choice, which can be printed with tourist attractions, landmarks, or distinctive patterns. Here are some points that may be helpful in designing, producing, and selling PVC shoe accessories and PVC keychains: 1. Customized services: Providing customized services can increase the uniqueness and personalization of products. By collaborating with customers, designing and producing customized PVC shoe accessories and keychains according to their requirements, and attempting to combine fashion elements and trends to increase the attractiveness of the products; 2. Material selection and quality control: Choosing high-quality raw materials is crucial for producing high-quality shoe accessories and keychains. Ensure that materials have durability, softness, and environmental friendliness, and establish strict quality control processes and testing standards; 3. Marketing and sales channels: Online channels can establish one's own brand website and social media platform, showcase product features and advantages, and interact with potential customers. Offline channels can collaborate with retailers, tourist attractions, travel agencies, etc. to showcase products in physical stores or souvenir stores, further expanding market share; 4. Customer feedback and after-sales service: Timely collecting customer issues and feedback, and continuously improving product and service quality to establish a good reputation and brand image. I am pleased to share this information with you. Our company is a professional manufacturer of soft plastic series products, Jinjiang Ailila Footwear Co., Ltd. Our products include but are not limited to PVC shoe charms. If you have any questions, feel free to communicate with me. Looking forward to your reply. Wishing you all the best, Eden 重发邮件 尊敬的客户，首先，非常感谢您对我们公司的关注和查看我们的邮件。我们非常重视您的时间和兴趣，并希望能够与您建立起互动和合作的机会。我们理解您可能有很多邮件需要处理，不过我们仍希望您能在空闲之余回复我们的邮件。您在阅读我们的邮件内容之后，若有任何关键信息和价值吸引了您，或者对我们的产品或服务有任何疑问或兴趣，请不要犹豫与我们分享。我们将竭诚为您提供更多详细信息。此外，我们也非常欢迎您分享您的观点、经验或建议。我们相信通过更深入的交流，我们可以共同探讨行业趋势、市场分析等方面的话题，为您提供更多附加价值。最后，我们希望能够与您建立起长期的合作关系，并为您提供卓越的产品和服务。期待您的回复！祝您一切顺利！诚挚地，[您的名字] Dear [customer], First of all, thank you very much for your attention and for viewing our email. We highly value your time and interest, and we hope to have the opportunity to interact and collaborate with you. We understand that you may have many emails to deal with, but we still hope that you can reply to our email when you have some free time. After reading the content of our email, if there are any key information or value that attracts you, or if you have any questions or interest in our products or services, please do not hesitate to share with us. We will be dedicated to providing you with more detailed information. Furthermore, we also welcome you to share your opinions, experiences, or suggestions. We believe that through deeper communication, we can discuss industry trends, market analysis, and other topics to provide you with additional value. Finally, we hope to establish a long-term partnership with you and provide you with excellent products and services. We look forward to your reply! Wishing you all the best! Sincerely, [Your name] Chat 问答 提示词： 我将会发送一封开发信给你，然后需要你帮我指出开发信还有什么不足之处，并说明为什么。如果明白，不用过多的回复，只要回复“好的”即可，谢谢。 。。。。。。 回答：开发信可能存在的几点不足 缺乏 个性化：开发信中没有提及客户的具体需求或兴趣，也没有提到 如何满足 客户的特定要求。个性化是吸引客户的关键之一，因此建议在开发信中提及客户的具体需求，并说明如何满足这些需求。 缺少 证据支持：虽然信中提到了产品的优点和竞争力，但缺乏具体的证据或案例来支持这些说法。为了增加信任度，建议在开发信中提供一些客户反馈、产品评价或成功案例，以证明产品的质量和竞争力。 缺乏关于 公司背景和信誉的介绍：开发信中没有提及公司的背景和信誉，这可能会让客户对公司的可靠性产生疑虑。建议在开发信中简要介绍公司的历史、规模和成就，以增加客户对公司的信任感。 提示词： 帮我用英文翻译一下下面的内容，需要比较专业、商务的英语，谢谢。 提示词： hello，前几天我发送了一封开发信给十来个公海客户，其中有一两个人打开查看了。 我现在应该再发送什么内容能委婉地让他们看到邮件后进行回复？ 或者有什么技巧可以吸引他们与我交流的吗？ 如果可以的话，请你帮我拟写一封用于委婉地激活新客户的邮件。 回答： 个性化的跟进：发送一封个性化的邮件，提醒他们你之前发送的邮件，并询问他们是否有任何问题或需要进一步的信息。 强调价值：在邮件中强调你的 产品或服务的独特价值，以及它们对客户业务的潜在好处。让客户明白与你交流的价值，可能会促使他们回复你。 提供额外资源：分享一些与客户需求相关的有价值的资源，例如 行业报告、案例研究或专家观点。这不仅可以展示你的专业知识，还能够吸引客户与你进一步交流。 创建紧迫感：通过 提供限时优惠或特别的促销活动，创造一种紧迫感，促使客户尽快回复你。 但是需要注意尊重客户的决定，并给予他们足够的时间来考虑和回复你的邮件。 提示词： 请问 PVC shoe charms、PVC keychains 这些有什么行业报告或者专家观点吗？可以展现自己的专业度的内容 回答： 对于 PVC 鞋饰和 PVC 钥匙扣的行业报告和专家观点，可能会比较难找到针对这些具体产品的独立研究或专家评论。这可能是因为这些产品属于较为细分的市场，相关的研究和评论相对较少。 然而，你可以通过以下方式展现自己的专业度和对行业的了解： 行业趋势和市场分析：研究整体的鞋饰市场和钥匙扣市场，了解消费者需求和趋势。这样你可以展示你对整个行业的了解，并将其与你的产品联系起来。 与相关行业的联系：考虑将PVC鞋饰和PVC钥匙扣与其他相关行业联系起来，例如时尚配饰、旅游纪念品等。了解这些行业的趋势和市场情况，可以为你提供更广泛的专业知识，并展示你的综合能力。 基于经验的见解：如果你在这个领域有丰富的经验，可以分享你在设计、生产和销售PVC鞋饰和PVC钥匙扣方面的见解。这样可以展示你的专业度和对产品的深入了解。 客户案例研究：如果你曾经与一些客户合作，可以分享他们的成功案例，并强调你的产品如何帮助他们实现目标。这样可以展示你的专业能力和产品的实际价值。 请记住，虽然可能没有特定的行业报告或专家观点可供参考，但通过深入了解行业趋势和市场需求，以及展示你的专业知识和经验，你仍然可以展现自己的专业度。 提示词： 请你分析一下 PVC shoe charms、PVC keychains 的消费者需求和趋势 回答： PVC 鞋饰和 PVC 钥匙扣作为时尚配饰和个性化物品，具有一定的消费者需求和趋势。以下是一些可能的消费者需求和趋势： 个性化和定制化：现代消费者越来越注重个性化和定制化的产品。PVC鞋饰和PVC钥匙扣可以通过不同的图案、形状、颜色和设计来满足消费者对个性化配饰的需求。 青睐可持续发展：越来越多的消费者关注环境和可持续性问题。因此，PVC鞋饰和PVC钥匙扣制造商可能会受到压力，以确保他们的产品符合环保标准，并使用可持续材料和生产方法。 品牌合作和授权：与知名品牌或IP（知识产权）合作成为一种趋势。消费者可能会更倾向于购买与他们喜欢的品牌或角色相关的PVC鞋饰和PVC钥匙扣。 社交媒体和影响力：社交媒体的兴起使得消费者更容易受到潮流和时尚的影响。PVC鞋饰和PVC钥匙扣制造商可以通过社交媒体平台与消费者互动，增加品牌曝光度和产品销售。 多功能和创新设计：消费者对多功能产品和创新设计的需求不断增加。PVC鞋饰和PVC钥匙扣制造商可以考虑在产品中加入更多的功能和特色，以吸引消费者的兴趣。 旅游纪念品和礼品市场：PVC鞋饰和PVC钥匙扣可以作为旅游纪念品和礼品的选择。这个市场有潜力，因为人们会购买这些产品作为旅行回忆或赠送给朋友和家人。 以上是一些可能的消费者需求和趋势，当然，具体的需求和趋势可能会因地区、目标市场和消费者群体的不同而有所差异。因此，了解目标市场并与消费者进行深入沟通，将有助于更好地把握消费者需求和趋势。 回头整理 未经同意收集个人信息和发送大量邮件行为本身是存在问题的所以有想法是让用户主动提供邮箱信息一般是在自己的网站不断给用户提供一些行业信息等有用的资料，然后促使用户留下邮箱❝ By entering your email, you agree to our Terms& Conditions and Privacy Policy.❞ 访客变顾客的四个阶段：1、Awareness给潜在客户发送折扣券、新产品信息等等2、Interest提供产品或服务的详细信息3、Decision给潜在客户制造销售紧迫感，促使他们尽快做出购买决策4、Action售中售后服务 定时发送邮件，关注时差，在以下时间段：9:00-10:3015:00-16:00尽量避开周一周五 可能需要先验证 邮箱的有效性发送大量无效邮件会使得域名在服务器上的信誉度下降，可能被服务商拉入黑名单，用户就收不到你的开发信其次是会占用发送额度邮箱有效性检测还是有一定必要的，防止重复发送出现问题 避免大段文字介绍自己的公司开头是明确的称谓，避免使用 Dear Sir/Madam根据联系方式的获取途径进行说明如果是某展会上面获得的：It was a pleasure to know you at xxx fair in Country.如果是网上某平台获得的：Noticed you are in the market for ... 或者 Glad to know you are in xxx industry.说明为什么联络：比如介绍公司产品，折扣券发放等等 说明的时候多用数据展示，比如物流很快是多快？比如明确说明时间一般是10天左右 重要的位置字体加粗段与段之间最好空一行，看起来结构更清晰 关于标题 简洁明了，突出重点，内容关联性 直接表明意图：How could we be your possible vendor - Ailila company? Hello, Interested in Footwear/Slippers direct sourcing? Can you give me 2 minutes, please? 问句形式：How to get the durable and comfortable shoes? 形容词加产品，适合小礼品：Great PVC key chains for decoration from Ailila, China 若有活动可以直接表明优惠 关于称呼：（总感觉宏用起来有点问题） Dear： Dear Sir/Madam: My name is Eden, I work with Hyper Global Mega Corp., an industry leader in sophisticated productivity solutions for the ferret farming sector. 关于内容 通用字体，小语种翻译，认真检查 从客户的公司官网寻找素材，例如他们的核心价值，一些关键标语 明确合作的利益 可以以主打产品、市场信息作为标题 少图少链接 避开垃圾邮件的过滤词 行业报告？消费趋势？？市场信息分享，最后在进行一波公司推荐 外贸垃圾邮件标题的可能关键词： \"供应商\"、\"厂家\"、\"批发\" \"采购\"、\"询价\"、\"报价\" \"货物\"、\"运输\"、\"物流\" \"代理\"、\"合作\"、\"合作伙伴\" \"质量\"、\"认证\"、\"检验\" \"报关\"、\"清关\"、\"进口\" \"支付\"、\"结算\"、\"付款\" 回信内容 亲爱的各位 我们对EVA拖鞋或沙滩拖鞋感兴趣。 我们想通知你，每种颜色我们不能订购超过120双。 我们还需要各种各样的款式来介绍我们地区的产品。 如果你方可以接受上述每种颜色的最低数量，我们将要求提供样品。 顺致敬意， 萨米卡拉姆 我注意到您说每种颜色数量不超过120双。请问你们需要的每种颜色的不同鞋码段的数量又是如何呢？ 很抱歉我们公司的每个款式的一个鞋码段的最小起订数量是3600双。您所提出的数量没有达到我们的最小起订量，如果可以的话希望你们可以提高订购量。 如果有任何问题，请随时联系我。期待收到您的回复，谢谢。 Dear Sami Karam, Nice to receive your reply. I noticed that you mentioned that the quantity of each color should not exceed 120 pairs. May I ask what is the quantity of different shoe size range for each color you need? I'm sorry, the minimum order quantity for a shoe size range of each style of shoes in our company is 3600 pairs. The quantity you have proposed has not reached our minimum order quantity. If possible, we hope you can increase the order quantity. If you have any questions, please feel free to contact me. Looking forward to receiving your reply, thank you. Best regards, 你好，Eden 非常感谢您的关注和将我们视为合作伙伴。然而，我们希望选择对环境友好的生产者。因此，我们选择在欧洲国家生产所有产品。 祝你有美好的一天， Zoé d'Angarde Angarde |www.Angarde-shoes.com 非常感谢您的回信，我们理解也尊重你们的选择。不够我仍希望今后能有机会能与你们合作，非常感谢。 Dear Zoé d'Angarde, Thank you very much for your reply. We understand and respect your company's choices. If we have the opportunity to collaborate in the future, please feel free to contact us at any time. Thank you very much. Best regards, Eden 富通天下使用疑问 每次暂存草稿后，再进入编辑，末尾都会多出一个签名，不能识别已存在的签名寻找买家或者进口商的技巧 参考资料 https://zhuanlan.zhihu.com/p/420325233 https://zhuanlan.zhihu.com/p/34613769 https://www.zhihu.com/question/420529806 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-07 18:00:35 "},"about_ForeignTrade/快速沟通模板.html":{"url":"about_ForeignTrade/快速沟通模板.html","title":"快速沟通模板","keywords":"","body":"1、作为业务员，在与客户沟通的时候如何 机智回应买家砍价？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 \"非常感谢您对我们产品的兴趣和支持。考虑到您的需求，我可以为您提供一些额外的价值，比如提供附加服务。这样您可以获得更多的价值，而不仅仅是价格上的优惠。\" \"我们非常重视您的需求，并且希望能够与您达成一个互惠互利的协议。如果您能够接受稍微调整的价格，我们可以为您提供更好的售后服务或者更快的交货时间。这样您不仅能够获得更好的产品，还能够享受到更好的购物体验。\" \"我理解您希望获得最好的价格，但是我们的产品质量和服务是有保证的。如果我们能够达成一个合理的价格，我可以向我的上级请示，看看能否给予您一些额外的优惠。\" 英文 \"Thank you very much for your interest and support in our products. Considering your needs, I can offer you some additional value, such as increasing the quantity of the product or providing additional services. This way, you can get more value, not just a price discount.\" \"We value your needs and hope to reach a mutually beneficial agreement with you. If you can accept a slightly adjusted price, we can provide you with better after-sales service or faster delivery time. This way, you can not only get a better product but also enjoy a better shopping experience.\" \"I understand that you want to get the best price, but our product quality and service are guaranteed. If we can reach a reasonable price, I can consult my superiors to see if we can give you some additional discounts.\" 2、作为业务员，在与客户沟通的时候，客户催促下单，但 产品的库存不多 怎么办？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 非常感谢您对我们产品的关注和支持。我们会尽快处理您的订单。不过目前库存有限，我会尽力为您争取更多的库存。如果您能稍等一下，我会及时与您联系，确认最新的库存情况。 英文 Thank you very much for your interest and support in our products. We will process your order as soon as possible. However, currently, our inventory is limited. I will do my best to secure more inventory for you. If you could wait for a moment, I will contact you promptly to confirm the latest inventory status. 3、作为业务员，在与客户沟通的时候，由于周末导致回复不够及时，如何合理地表示歉意？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 对不起，由于周末的原因，我没有及时回复您的消息。非常抱歉给您带来了不便。 英文 I'm sorry for not responding to your message in a timely manner due to the weekend. I apologize for any inconvenience caused. 4、作为业务员，在与客户沟通的时候，如何 提醒买家尽快付款？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 \"尊敬的客户，感谢您选择我们的产品。为了确保您能尽快收到您的订单，请尽快付款。\" \"亲爱的客户，您的订单已经准备好了。为了避免延迟发货，请尽快完成付款。\" \"亲爱的客户，我们非常期待为您提供优质的服务。为了加快订单处理流程，请您尽快付款。\" 英文 \"Dear customer, thank you for choosing our product. In order to ensure that you receive your order as soon as possible, please make the payment promptly.\" \"Dear customer, your order is ready. To avoid any delays in shipping, please complete the payment as soon as possible.\" \"Dear customer, we are looking forward to providing you with excellent service. To expedite the order processing, please make the payment promptly.\" 5、作为业务员，在与客户沟通的时候，如何 告知买家已经发货？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 亲爱的客户，非常高兴地告诉您，您的订单已经成功发货了！您的商品已经准备好并交给了物流公司。您可以通过订单页面查看物流信息，我们也会尽快提供给您物流追踪号码。请耐心等待，您很快就能收到您心爱的商品了！ 英文 Dear customer, we are delighted to inform you that your order has been successfully shipped! Your items have been prepared and handed over to the logistics company. You can track the shipment progress through your order page, and we will also provide you with a tracking number as soon as possible. Please be patient, and you will receive your beloved items soon! 6、作为业务员，在与客户沟通的时候，如何 委婉地尝试让客户进行商品评论？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 亲爱的客户，感谢您选择我们的商品！我们非常重视客户的反馈和意见，这对我们来说非常重要。如果您对我们的商品感到满意，能否花一点时间给我们留下一份宝贵的评论呢？您的评论将帮助其他客户更好地了解我们的商品，并帮助我们不断提升产品质量和服务水平。非常感谢您的支持和理解！ 英文 Dear customer, thank you for choosing our products! Your feedback and opinions are highly valued by us. If you are satisfied with our products, would you mind taking a moment to leave us a valuable review? Your review will help other customers better understand our products and assist us in continuously improving our product quality and service level. Thank you very much for your support and understanding! 7、作为业务员，在与客户沟通的时候，当买家有购买意向的时候，如何 有成效的使得客户下单？请你给出对应的话术，给出中文和对应的英文。谢谢 中文 亲爱的客户，非常感谢您对我们产品的兴趣！我们非常有信心能够为您提供优质的商品和出色的服务。如果您有任何疑问或需要进一步的信息，我将竭诚为您提供帮助。另外，我们目前正有一项特别优惠活动正在进行中，如果您现在下单，将享受到额外的折扣或者其他优惠。这是一个难得的机会，希望您能抓住它，让我们为您提供最好的购物体验！ 英文 Dear customer, thank you very much for your interest in our products! We are confident in providing you with high-quality goods and excellent service. If you have any questions or need further information, I am here to assist you wholeheartedly. Additionally, we currently have a special promotion running, and if you place an order now, you will enjoy additional discounts or other benefits. This is a rare opportunity, and we hope you can seize it to let us provide you with the best shopping experience! 8、作为业务员，在与客户沟通的时候，当买家有购买意向的时候，如何 联系老客户？请你给出对应的话术，给出中文和对应的英文。谢谢 Dear , I hope this message finds you well. It has been some time since we last connected, and I wanted to reach out and reconnect with you. I wanted to take this opportunity to update you on some exciting developments at our company. I understand that your time is valuable, and I will send our catalog to you to meet your unique needs. Thank you for your attention, and I look forward to the possibility of reconnecting and exploring new avenues of collaboration. Warm regards, [Your Name] 快速接待客人 Hello, I am very glad to serve you. There are 6 style of keychains in this set. The size is about 2~3cm and the thickness is about 4mm. MOQ is 50 pieces = 50pieces USD$0.14 per unit = 500pieces USD$0.12 per unit If you have any questions, please feel free to contact me, thank you.🙂 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-08 09:43:01 "},"about_ForeignTrade/每日.html":{"url":"about_ForeignTrade/每日.html","title":"每日","keywords":"","body":"1、做好每日访客营销在【数据参谋】-【访客详情】（目前已经不行了，只能在首页的客户管理中进行站内营销。之后可以在【商机沟通】-【询价单管理】-【已发送】查看） 推销用例： Hello, I am pleased to introduce our popular products to you. Our shoe charms and keychains are made of PVC material, which is flexible and not easily damaged. Shoe charms have buttons that can be used to decorate Crocs and Bogg bags. Whether it's for adding personal style or based on our hobby of collecting different styles of shoe accessories, we can meet our needs. They can be used as a promotional gift or as a party gift for children during holidays, making them more meaningful and special. Our product is also very competitive in terms of price. I will send you a product catalog, which includes various styles. Thank you very much, if you could check. We look forward to hearing your thoughts! Best regards, Jame 2、做活动，打折扣在【活动中心】-【折扣营销】 3、RFQ 报价最好的时间段是早上九、十点，下午四、五点左右 4、旺旺上面与已有客户持续沟通，但是不要太勤 5、富通天下发送营销信根据目标公司的经营项目进行有针对的营销广交会数据拖鞋钥匙扣重发footwear 6、修改模板对打开过的用户发送重发模板鞋花、钥匙扣、吸管、鞋模板 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-08 09:46:04 "},"about_ForeignTrade/语法问题.html":{"url":"about_ForeignTrade/语法问题.html","title":"英语语法问题","keywords":"","body":"英语中的主语、谓语、宾语、表语和补语 主语（Subject）：主语是句子中执行动作或者被描述的 人、物、事物或概念 谓语（Predicate）：谓语表示主语所执行的 动作、状态或者存在的情况它通常回答了“主语在做什么”或“主语是什么” 宾语（Object）：宾语是句子中 被动作所作用的人、物或概念它通常回答了“动作作用于谁”或“动作作用于什么” 表语（Predicative）：表语是用来 描述主语的状态、特征或身份的成分（注意描述的是主语）它通常位于 系动词后面，与主语构成连系动词结构。例如：She is happy.（她很快乐。）The food smells delicious.（这食物闻起来很美味。） 补语（Complement）：补语用来 补充、说明 或者限定主语、宾语或表语的信息它可以是 形容词、副词、名词、介词短语 等，通常出现在及物动词（如make、elect等）后面 时态 过去完成时（Past Perfect Tense）：用于表示 过去某个时间点之前已经发生 的动作或状态。They had already left when I arrived.（当我到达时，他们已经离开了。）He had studied English for two years before he moved to the United States.（在他搬到美国之前，他已经学习了两年英语。） 一般过去时（Simple Past Tense）：用于表示 过去发生 的动作或状态。I visited my grandparents last weekend.（上周末我去看望了我的祖父母。）She lived in London for five years.（她在伦敦住了五年。） 过去进行时（Past Continuous Tense）：用于表示 过去某一时刻正在进行 的动作。They were watching a movie when I called them.（当我给他们打电话时，他们正在看电影。）He was studying all night for the exam.（他为了考试整夜都在学习。） 现在完成时（Present Perfect Tense）：用于表示过去发生的动作或经历 对现在产生的影响或结果。I have finished my homework.（我已经完成了我的作业。）She has lived in this city for five years.（她在这个城市已经住了五年。） 一般现在时（Simple Present Tense）：用于表示 经常性的动作、习惯、真理 等。I go to school every day.（我每天去学校。）The sun rises in the east.（太阳从东方升起。） 现在进行时（Present Continuous Tense）：用于表示 现在正在进行 的动作。She is studying for her exams.（她正在为考试复习。）They are playing football in the park.（他们正在公园里踢足球。） 一般将来时（Simple Future Tense）：用于表示 将来要发生 的动作或事件，强调未来动作本身。I will travel to Europe next month.（下个月我将去欧洲旅行。）They will have a party on Saturday.（他们将在星期六举办派对。） 将来进行时（Future Continuous Tense）：用于表示 将来某个时间点正在进行 的动作，强调 动作的持续性或者临时性。I will be studying at the library tomorrow evening.（明天晚上我将在图书馆学习。）They will be traveling to Japan next month.（下个月他们将去日本旅行。） 语态 表示动作的执行者和承受者之间的关系常见的语态有主动语态（Active Voice）和被动语态（Passive Voice） 主动语态 用于强调动作的执行者 The cat chased the mouse.（猫追逐着老鼠。） 在这个例子中，主语 \"the cat\" 是动作 \"chased\" 的执行者 被动语态 强调动作的承受者，即主语是动作的承受者或者不知道或不关心动作的执行者是谁的情况下 被动语态的结构是由助动词 \"be\" + 过去分词构成 The mouse was chased by the cat.（老鼠被猫追逐。） 在这个例子中，主语 \"the mouse\" 是动作 \"chased\" 的承受者 条件句 用来表达假设、条件或可能性的句子通常由两个部分组成：主句和从句。主句表达 结果或行动，而从句表达 条件 零条件句（Zero Conditional Sentences） 用于表达普遍真理或科学事实，它们描述的条件和结果总是发生 这类句子的结构是：if + 现在时态，主句现在时态 例如：If you heat water to 100 degrees Celsius, it boils. 一般条件句（First Conditional Sentences） 用于表达可能发生的情况，它们描述的条件和结果在将来是有可能实现的 这类句子的结构是：if + 现在时态，主句将来时态 例如：If it rains tomorrow, I will stay at home. 虚拟条件句（Second Conditional Sentences） 用于表达与现实相反或不太可能实现的条件和结果 这类句子的结构是：if + 过去时态，主句将来完成时态（或情态动词+动词原形） 例如：If I had a million dollars, I would travel around the world. 混合条件句（Mixed Conditional Sentences） 用于表达过去的情况对现在的影响，结合了过去和现在的条件和结果 这类句子的结构是：if + 过去完成时态，主句现在完成时态（或情态动词+ have + 过去分词） 例如：If I had studied harder, I would have passed the exam. 名词性从句 作为一个从句，在句子中充当名词的角色在句子中可以担任主语、宾语、表语或补语帮助我们在句子中引入一个新的主题或提供更多的信息。它们可以使句子更加丰富和有逻辑性 名词性从句通常由连接词引导，常见的连接词有：that, whether, if, who, whom, whose, which, what, when, where, why, how等 主语 What he said is true.（他说的是真的。） Whether we go or not is up to you.（我们去不去由你决定。） 宾语 I don't know where he went.（我不知道他去哪里了。） She asked me what my name was.（她问我叫什么名字。） 表语 Her biggest fear is that she will fail.（她最大的恐惧是她会失败。） The problem is who will take care of the children.（问题是谁会照顾孩子们。） 补语 My hope is that we can find a solution.（我的希望是我们能找到一个解决办法。） The question is whether they will accept the offer.（问题是他们是否会接受这个提议。） 限定词 用来 指示、数量化或限定名词的范围冠词是一种特殊的限定词，用来具体指示名词的范围 不定冠词（a/an） I saw a dog in the park.（我在公园看到了一只狗。） She is an engineer.（她是一名工程师。） 定冠词（the） The book on the table is mine.（桌子上的那本书是我的。） Have you seen the movie \"Titanic\"?（你看过电影《泰坦尼克号》吗？） 指示代词（this, that, these, those） This is my car.（这是我的车。） Those are my shoes.（那些是我的鞋子。） 数量词（some, any, many, few, several, every, each 等） There are some apples in the basket.（篮子里有一些苹果。） Many people attended the concert.（很多人参加了音乐会。） 并列连词和从属连词 并列连词用于连接两个或更多的并列的词、短语或句子，使它们在句子中并列起来常见的并列连词有：and（和）、but（但是）、or（或者）、so（所以）、for（因为） 等I like to read books and watch movies.（我喜欢读书和看电影。）She is smart but lazy.（她很聪明但是懒惰。）You can have tea or coffee.（你可以喝茶或咖啡。） 从属连词用于引导从句，从属连词将从句与主句连接起来，从而在句子中形成从属关系常见的从属连词有：that（那）、if（如果）、because（因为）、although（尽管） 等She said that she would come.（她说她会来。）If it rains, we will stay at home.（如果下雨，我们就待在家里。）He didn't go to the party because he was not feeling well.（他因为身体不舒服所以没去参加聚会。）Although it was raining, they went for a walk.（尽管下雨，他们还是去散步了。） 一些问题 could have done 语法 用来表示过去某个时间或情况下本可以做某事，但实际上没有做。它是\"could\"的 过去完成时态 形式例如：I could have done my homework last night, but I chose to watch TV instead.（我昨晚本可以做作业，但选择看电视了。）She could have taken the earlier train, but she decided to wait for her friends.（她本可以坐早一班火车，但她决定等朋友。）They could have won the game if they had played better in the second half.（如果他们在下半场打得更好，他们本可以赢得比赛。）用来表达遗憾、后悔或对过去的反思。它强调了过去某种可能性或选择，但实际上没有发生。 Thank you very much if you could consider our product 这里为什么使用could而不用can 在这个句子中，使用\"could\"表示一种委婉或客气的请求或建议。\"Could\"在这里相当于\"would\"，用来表示一种可能性或愿意考虑的态度。它传达了一种希望对方愿意考虑的意思，而不是强迫或要求对方做某事。 If given the opportunity to cooperate, I believe we can 。。。。。。 If given 这个表达比 If we have the opportunity。。。。。。 更加委婉，至于为什么 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-08 10:49:37 "},"about_Other/":{"url":"about_Other/","title":"其他","keywords":"","body":"Other Git的使用 关于FGO中的一些角色 部分乐理知识 五十音 bat 语法 Excel 操作 JS 基础 LaTex 整理 Matlab 整理 Docker基础 PS 操作 Redis 整理 RESTful 风格 sd 绘画提示词 计网 百问百答 Gitbook 的安装部署 网站收集 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-17 18:15:55 "},"about_Other/百问百答.html":{"url":"about_Other/百问百答.html","title":"百问百答","keywords":"","body":" ✨计算机小知识 ⭕ cpu 架构 x86 架构芯片制造商：Intel、AMD 公司 x86：32位，Intel 公司率先研发出 x64（x86_64、amd64）：64位，AMD 公司率先研发出 arm 架构芯片制造商：ARM 公司 arm64（aarch64） ⭕ 文件系统、分区、磁盘、挂载点 文件系统（File System）：文件系统是操作系统用于 组织和管理文件 的一种方法它定义了文件和目录的结构，以及文件的存储方式和访问权限常见的文件系统包括ext4、NTFS、FAT32等 磁盘（Disk）：磁盘是用于 存储数据的物理设备它可以是硬盘驱动器（HDD）或固态驱动器（SSD）磁盘通常被划分为一个或多个分区，每个分区可以使用不同的文件系统 挂载点（Mount Point）：挂载点是指将一个 文件系统 连接到 Linux文件树中的特定目录，以便系统可以访问该文件系统中的文件和目录挂载点 是一个空目录，它充当了 文件系统的入口点通过将文件系统挂载到挂载点，我们可以在该目录下访问文件系统中的内容 分区、未分区1、分区（Partition）：分区是 将物理磁盘划分为多个逻辑部分 的过程每个分区可以被视为一个独立的 逻辑磁盘，拥有自己的文件系统分区可以帮助我们更好地组织和管理磁盘空间，使不同的数据可以分开存储一个物理磁盘可以包含多个分区2、未分区（Unpartitioned）： 当磁盘未被分区时，整个磁盘被视为一个单一的逻辑单元未分区的磁盘上 没有文件系统，也无法直接存储数据如果要在未分区的磁盘上存储数据，需要先对其进行分区并创建文件系统 ⭕ Linux 系统的文件解释 https://www.zhihu.com/question/298683851 目录 注释 /bin bin 是 binary 缩写，存放 常用命令 /boot 存放的是 启动 Linux 时使用的一些核心文件，包括一些 连接文件和镜像文件 /dev dev 是 device 的缩写，存放 Linux 的 外部设备 在 Linux 中访问设备的方式和访问文件的方式是相同的 /etc 存放所有的 系统管理 需要的 配置文件和子目录 /home 用户主目录 /lib 存放系统最基本的 动态连接共享库 几乎所有的应用程序都需要用到这些共享库 /lost+found 一般情况下是空的，当系统 非法关机 后，这里就存放了一些文件 /media Linux 会自动识别一些设备，例如 U 盘，识别后 Linux 会把这些设备挂载到这个目录 /root 该目录为系统管理员（超级权限者）的用户主目录 /sbin S 就是 Super User 的意思，这里存放的是 系统管理员 使用的 系统管理程序 /tmp 这个目录是用来存放一些 临时文件 的 /usr 这是一个非常重要的目录，用户的很多 应用程序和文件 都放在这个目录下，类似于 Windows 系统下的 program files 目录 /var 这个目录中存放着不断扩充着的东西 我们习惯将那些 经常被修改的目录 放在这个目录下，例如各种 日志文件 ⭕ VPN 技术 可以参考：https://github.com/yukaiji/buildVpn 选择 Vultr 供应商来购买海外 VPS 服务器，优点在于所有服务器创建成功后开始计费，并且是按照小时来计费的，如果你删除掉服务器将不再计费 目前国内的 VPN 打击特别严厉，很多 VPN 已经被封掉了，我们购买的海外服务器也有可能是被墙掉 IP 或者用一段时间被墙的 需要主脚本，自动搭建 ⭕ 公私钥，加密解密 公钥，对外公开；私钥，只有自己拥有它们成对出现，公钥加密的数据只能用对应的私钥解密，反过来也一样 我手上有一对公私钥，我将公钥分享给好朋友那么好朋友就可以使用公钥加密来向我传输数据，我可以使用私钥解密这样就解决了 安全传输 的问题 那反过来，先用私钥加密，后用公钥解密，这叫做 数字签名例如：我将一些内容用私钥加密，之后发送给好朋友，让他解密看看是否内容一致若一致，就证明了对方身份的正确 以上公私钥加密方法运算很费时，那么QQ是怎么实现安全聊天的呢？例如：我和朋友通过握手来约定使用某个内容作为会话密钥然后使用对称密钥算法（加密解密使用同一个密钥）对聊天内容加密不过实际肯定会上述复杂很多 ⭕ RESTful 风格 REST 是设计原则、约束条件满足 REST 风格的接口叫做 RESTful API 特征 以资源为基础 统一接口 GET---SELECT POST---CREATE PUT---UPDATE PATCH---UPDATE DELETE---DELETE 一个 URI 对应一个资源，反之一个资源可以对应多个 URI 服务器不存放客户端信息 限制条件 Client-Server 分离 无状态 服务端需要回复是否缓存 统一接口，降低耦合 分层系统，Client 不知道连接对象 按需代码，可以将 JS 代码发送到 Server 设计规范 URI = scheme://host:port/path[? query][# fragment] 注意单词小写，字符串连接用中杠 -，URL 的层级不能过深，资源表示用复数 关于 path /version/resource/resourceid 安全性：只读为安全，写为非安全幂等性：执行一次与执行多次的结果是一样的 状态码 1xx 相关信息 2xx 操作成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 测试工具：Postman 格式 form-data，用于上传二进制文件 x-www-form-urlencoded，将表单数据转换为键值对 raw，可以上传任意类型文件，更多的是 JSON ⭕ VS Code 缓存迁移 参考资料https://blog.csdn.net/xbs150/article/details/126425882https://blog.csdn.net/debrnr/article/details/124052103 下载安装若下载很慢，在链接前面加上 https://vscode.cdn.azure.cn/stable/......，加快下载速度 为了防止C盘空间占满，修改扩展和缓存文件的路径【注意，移到其他的盘后，启动可能需要管理员权限】 mklink /D \"C:\\Users\\%username%\\.vscode\\extensions\" \"D:\\VSCodeSystem\\mylinks\\extensions\" mklink /D \"C:\\Users\\%username%\\AppData\\Roaming\\Code\" \"D:\\VSCodeSystem\\mylinks\\Code\" mklink C:\\a D:\\b 在这个命令中，c盘下的a文件夹不用创建，执行命令后会自动生成，d盘下的b文件夹是实际用于存储的位置 删除连接 rmdir /s ... ⭕ 核显、集显 https://zhuanlan.zhihu.com/p/139065355 显卡（Graphics card），又叫 显示适配器控制计算机显示器的画面显示，是必须的配件之一 集成显卡（集显） 集成在主板上面 特点： 价格实惠，兼容性好 没有独立的显存，需要占用系统内存，这会导致 CPU 可用的物理内存减少，一定程度影响电脑性能 升级版本需要更新主板 BIOS（？） 性能比较低 如今基本被核心显卡取代 核心显卡（核显） 属于集成显卡的一种，但是是集成在 CPU 中的 特点： 价格相对便宜，能耗低，性能优于集成显卡 目前智能手机也是采用 CPU 内置 GPU 的核心显卡方案 独立显卡（独显） 前面两个相当于是买主板或者 CPU 送显卡，而独立显卡需要额外购买。它插在主板的 PCI 显卡插槽 特点： 体积大，需要配备单独的散热风扇，性能卓越 ⭕ 原码 反码 补码 https://zhuanlan.zhihu.com/p/118432554 下面假设计算机字长为 8 位 机器数 一个数在计算机中的二进制表示称为它的机器数 其中第一位是符号位 机器数的真值 带有符号位的机器数对应的真正数值 原码 符号位加上真值的绝对值 反码 正数的反码不变；负数的反码在原码的基础上，符号位不变，其余取反 补码 正数的补码不变；负数的补码在反码的基础上 +1 通常反码和补码无法直接看出对应的数值，需要先转换成原码 数值 原码 反码 补码 11 0000 1011 0000 1011 0000 1011 -8 1000 1000 1111 0111 1111 1000 为什么需要这些？？？为什么机器使用的是补码？？？计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂！于是人们想出了 将符号位也参与运算 的方法根据运算法则减去一个正数等于加上一个负数，即：1-1 = 1 + (-1) = 0， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了 如果机器使用原码表示数，并且符号位也参与运算，那么会发现减法运算会出现错误故引入反码，不过使用反码进行减法运算会发现真值部分是对的，但是会出现+0和-0两种表示故引入补码概念，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值钟表往回拨(减法)的结果可以用往前拨(加法)替代所以说 一个数的反码，实际上是这个数对于一个模的同余数。而这个模并不是我们的二进制，而是所能表示的最大值！ ⭕ 计算机的32位和64位 指处理器的数据位数，也就是处理器一次能处理的二进制数据的位数，而不是二进制或十六进制的位数32位处理器可以处理32位的数据，而64位处理器可以处理64位的数据 其次，二进制和十六进制都可以在32位系统中使用。无论是二进制还是十六进制，都可以用来表示32位的数据在这种情况下，二进制需要32位，而十六进制只需要8位例如：0000 0000 0000 0000 0000 0000 0000 11110 0 0 0 0 0 0 f 最后，十六进制的一个位只需要二进制的4位来表示 ⭕ 存储容量 存储器中所包含存储单元的数量称为存储容量，而存储容量的计量基本单位是字节一个字节由8个二进制位组成，用来表示一个字符或一个数据单位 硬盘厂商在计算容量方面通常以1000KB=1MB的方式进行计算，而不是使用二进制的1024KB=1MB。这种差异导致了硬盘容量“缩水” 因此，一个标称为40GB的硬盘在电脑系统中显示的容量可能只有大约38GB左右。这是因为硬盘厂商使用十进制计算容量，而操作系统使用二进制计算容量 ✨面试准备工作 面试前先去了解一下：该公司以及自己所应聘的职位思考：为什么选择这个职位，自己有哪些适合该职位的因素 假设要经过三轮面试1、HR 面试可以问问 公司的制度 等等2、直属领导面试可以问问平时 工作的内容、习惯，业务 相关等等3、用人部门老大面试可以问问这个 职位理想的候选人所应具备的特质、近年来的入职离职率 等等 其他可以问的问题 1、将会进行几轮面试 2、了解一下企业制度与文化 3、询问团队规模 4、询问所在职位的职责与将来的规划 5、了解薪资、福利 6、加班情况，是否双休 7、如果被录用，大概会经过怎样的流程 不过以上也需要看情况使用，面试没有标准答案，有时候要运气向面试官提问时也可以针对他所讲的内容，这样也显得比较 真诚、不套路尽量有区别的提问，重在互相了解，看看职位的适配度 来源：牛客 ✨有趣的算法 ⭕ 推荐算法 🔘 1、基于人口统计学 从用户的基本信息中得到 用户的相关程度对于没有具体标签的利用 聚类 得到类别构建用户画像就是进行 用户信息标签化 🔘 2、基于内容（CB） 抽取物品内在、外在的特征 相似度计算 距离： d(x,y) = \\sqrt{\\sum_{i}(x_{i}-y_{i})^{2}} 余弦相似度： \\cos\\theta = \\frac{a \\cdot b}{|a| \\times |b|} = \\frac{\\sum_{i}x_{i}y_{i}}{\\sqrt{\\sum x_{i}^{2}}\\sqrt{\\sum x_{i}^{2}}} 🔘 3、基于协同过滤（CF） 用户评价矩阵 是一个 稀疏矩阵，主要是利用了近邻的口碑，可用 KNN 基于 K 个邻居的历史偏好数据为当前用户推荐。这是基于 喜欢类似物品的用户可能有相似的偏好 这一推断与 CB 的区别：是通过用户的 历史偏好 来推断用户的相似度，而 CB 和基于人口统计学都是利用 本身的属性特征 基于近邻 包括 Item-CF 和 User-CF 当物品数小于用户数时，使用 Item-CF；反之用户数小于物品数时，使用 User-CF 基于模型 用户评价矩阵 R，用户特征矩阵 P、物品特征矩阵 Q P*Q 的元素与 R 中的元素尽量接近，而 R 中空白的部分即 P*Q 对应的评价预测 可以利用交替最小二乘法、梯度下降法求解矩阵 P、Q ✨政治小知识 ⭕ 国际政治类别 🔘 左派 积极改革 左倾 追求进步，同情劳动人民 “左”倾：带引号的左倾，脱离了社会现实条件，急于求成，轻视敌人力量 右倾 认识落后于实际，过于高估敌人力量，低估革命力量 🔘 右派 维护传统，保守 左翼 提倡社会公平，增加社会福利 右翼 支持自然竞争，反对增加社会福利 法西斯的极右翼主义 日本右翼分子崇尚军国主义 🔘 对比 左派 右派 社会主义 资本主义 集体主义 个人主义 平等 自由 革新 保守 大政府 小政府 世界主义、国际主义 国家主义、民族主义 🔘 参考资料 https://www.163.com/dy/article/HDKNVD690553A8T9.htmlhttps://blog.csdn.net/weixin_37641832/article/details/103474920https://zhuanlan.zhihu.com/p/548302086 ✨其他 ⭕ 关于宗教 https://zhuanlan.zhihu.com/p/594078419 很久以前，中东有一个民族叫犹太人他们周边有着许多强悍的民族：亚述人、埃及人、巴比伦人、波斯人等等后来犹太王国沦陷，犹太人被巴比伦国王绑去在苦难之时，犹太人祈求上帝，希望能派遣一位救世主来拯救犹太民族这个救世主的另一个称呼叫基督这群等待救世主降临的犹太人就是 犹太教 后来出现了一位名叫耶稣的人，他自称是救世主基督这时，有部分犹太教的人相信耶稣就是基督，成立了新的教派：基督教（所以基督教是从犹太教中分出来的） 圣经中有两部分，一部分《旧约》讲的是犹太人和上帝的故事；另一部分《新约》讲的是犹太人和基督的故事 犹太教徒说上帝仅仅是犹太人的上帝，只拯救犹太人；而基督教徒认为上帝会拯救所有人后者明显赢得更多的信徒，当时欧洲最强的罗马帝国也把基督教当作了国教之后罗马帝国版图越来越大，分裂成东、西罗马，宗教也随着分裂出现了各自的教会：西罗马的 天主教，东罗马的 东正教 大概五六百年后，天主教出现腐败，教会通过兜售赎罪券来敛财德国出现了一位教士，抨击天主教会这样的行径，掀起了宗教改革然后涌现出了一些小派别，统称 基督新教，简称新教 天主教 东正教 新教 教皇有最高权力，下面是各级神职人员 没有教皇这种最高权力身份，但有许多牧首，分管各个片区 结构简单，小派别信众聚集 西欧大概率是天主教 东欧大概率是东正教 北欧、美、英、澳大概率是新教 教堂中有许多实体雕塑 教堂中有许多壁画和装饰花纹 教堂很简约，十字架和几排长凳 ⭕ 美联储 美国联邦储备系统，是美国一家 私有中央银行美联储从 美国国会 获得权力职责：制定货币政策、对金融机构进行监管 🔘 美联储加、降息 美元是世界货币，主导着全球金融货币体系、贸易结算体系 降息：通过一级交易商购买美国国债，这样美元就流向了市场，市场上美元变多了，市场利率水平就会下降 加息：向市场抛售大量国债，回收市场上的美元，美元的流动性减少，会使得美元变得稀缺（变得更值钱），购买力会上升，市场利率水平会上升加息的后果：1、对美国经济的影响美元流动性减少，会提高美元融资成本前期，美股会出现下跌跳水的行情后期，由于美元加息会导致资本回流（美元更值钱），早期的债务风险和资产泡沫会被消化掉，实现平稳过渡2、对其他新兴经济体的影响美元升值，意味着本国货币被迫贬值大量资本外流，有些比较脆弱的金融体系和经贸体量，不足以应对美元加息带来的流动性逆转，最终会陷入被动的困境 什么时候会加息？当美国国内经济稳定、充分就业或者通胀失控的时候前期虽然会冲击美股市场，但是后期会吸引大量资本回流，消化掉通胀带来的影响，促进美国经济增长和产能扩张 🔘 参考资料 https://zhuanlan.zhihu.com/p/419390279 ⭕ 暗物质 暗物质是一种假设存在的物质，我们之所以认为宇宙中存在暗物质，是因为观测到的物质和能量无法解释一些天文学现象，如星系旋转速度、星系团的运动以及宇宙微波背景辐射的分布等根据这些观测结果，科学家推测暗物质可能占据了宇宙中大部分的物质 为什么暗物质不可见呢？因为暗物质与电磁辐射几乎没有相互作用，它不会发光、吸收或散射光线，也不与电磁波相互作用，因此无法直接被观测到 科学家目前主要通过间接的方式来研究暗物质例如，他们使用粒子加速器来模拟暗物质的性质，或者在地下实验室中寻找可能与暗物质相互作用的信号这些实验旨在找到暗物质存在的证据，以更好地理解宇宙的组成和演化 ⭕ 摄影问题 https://zhuanlan.zhihu.com/p/134166476 光圈是位于镜头内部的小叶片相互重叠构成的光孔，调整其开闭程度可以调整图像感应器的受光量光圈大小的表示：f/2、f/4、f/8、f/16……。字母后面的数字越小，对应的光圈越大对画面的影响：1、进光量。可以通过光圈来控制照片的亮度或者画面的曝光，光圈越大，进光量越大，照片越亮2、画面景深。背景的虚化程度，光圈越大，景深越浅，背景越模糊 快门是相机用来控制光线照射感光元件时间的装置，也就是决定光线进入相机与否和光线进入相机时长的装置快门单位的是秒，一般用：1s、1/50s、1/100s…这种形式来表示快门速度对画面的影响：1、曝光。快门速度越慢，光线进入相机时间越长，光量越多，照片越亮2、物体形态。慢速快门能将运动物体拍出运动轨迹，而快速快门能定格运动物体 感光度（ISO值）数码相机感光元件对光线的敏感程度，感光度越高，感光元件对光线的敏感度越强用数字表示，比如：100、200、400、800......。数字越大感光度越高对画面的影响：1、曝光。感光度越高，相机感光元件对光线敏感程度越强，照片越亮2、照片画质。随着感光度越来越高，照片上逐渐出现了噪点，画质也变得越来越差。日常拍摄我们都不会用太高的感光度进行拍摄 关于变焦，包括：1、光学变焦。原理和望远镜一样，同通过镜片的移动实现放缩2、数码/数字/无损变焦。单纯通过特殊算法软件实现放大操作3、混合变焦。光学和数码变焦结合使用理论拍摄效果：光学变焦 > 混合变焦 > 数码变焦（不绝对）由于手机不能做太厚，镜头不能太凸出，镜头空间实在有限，无法装入更多焦段的镜片，这就导致光学变焦可支持的焦段极少，能支持5倍光学变焦就不容易。OPPO提出潜望式长焦，借鉴的“潜望镜”上对光的传播线路的改变，让手机相机的传感器不用和镜头处在同一水平线上，而是通过反光镜让光路发生折叠后，进入相机传感器中，好处是能放下多组焦段的镜片，但是也存在结构复杂、占用体积太大，光学防抖制作成本太高等问题 ⭕ 电视机顶盒 机顶盒： IPTV 观看电视台的直播频道，例如 CCTV 等 有时候办理宽带会送 网络电视盒子 知名的有：小米盒子，腾讯极光，当贝盒子等等 等同于没有屏幕的电视，支持安装第三方软件 如果你的电视已经是智能电视机，并且没有卡顿等问题，就不需要机顶盒但是，若机顶盒配置比较高，则能够提供更好的分辨率和解码能力，提升观看体验 ⭕ 阿富汗战争 2001年~2021年 美国、北大西洋公约组织vs阿富汗基地组织、塔利班 前者入侵理由是为了逮捕本·拉登，对九一一事件进行报复行动美军在战争初期就将塔利班政权推翻，并协助阿富汗伊斯兰共和国成立2011年5月，美军发起斩首行动，击毙了基地组织头目本·拉登。之后开始撤出主力部队奥巴马政府2016年底承诺撤军，特朗普政府2020年与塔利班签署多哈和约，最终拜登政府于2021年正式撤军但是在美军撤军之后，塔利班重新占领喀布尔并建立政权 ⭕ 形而上学 属于哲学的范畴，很难定义清楚主要问题：根本上有什么存在？它是什么样的？关注的是基础、前提、成因、第一原因、基本结构形而上学的研究使用先验知识来推演进行，试图对世界结构进行连贯的描述，并且不能有矛盾相比较而言，神学假设神圣以某种形式存在，透过信仰将假设合理化。研究对象包括上帝、神灵、道德标准、宗教经典等等，不深入研究信仰本身的合理性 ⭕ 牛市 熊市 牛市又称为多头市场，是指证券市场上价格走高的市场是因为价格上扬时市场热络，投资人与证券经纪人挤在狭小的证券交易所中，万头攅动，如传统牛市集的圈牛群一般壮观，故戏称之为牛市 熊市又称为空头市场，其相反就是多头市场，指证券市场上价格走低的市场在美国西部拓荒时代，美墨边境的牛仔闲暇时常常比赛马、斗牛，或是抓灰熊来斗牛，围观下注作娱。后来美国人就把熊和牛视为对头动物 ⭕ 泉、漳地图 http://www.cgzdl.com/zhongguo/fujian/ 上边是：德化、永春左边是：安溪中间是：南安右边从上到下是：泉港、惠安、洛江、丰泽右下角是鲤城、晋江、石狮下边是：金门 ⭕ 中央选调、定向选调、常规选调、国省考、事业编、军队文职、央国企、三扶一支 🔘 关于公务员考试 公务员考试 国考 省考（选调生、乡镇公务员） 遴选（已经为公务员，继续向上选拔，这里不做介绍） 国考：中央及直属单位招考 部门例如：公安部、外交部、国税、海关 报名时间：10月下旬 笔试时间：11月下旬~12月上旬 面试：来年3月中旬 省考：各省份的政府、法院、检查院根据地方的需求招考 分为： 联考：3月上旬报名；4月下旬笔试；7月中旬面试 自主命题：北上广苏 考查内容 政治立场 解决问题的能力 行测：在有限时间内解决问题的能力 申论：通过表象看实质的能力 主要流程 报名--初审--笔试--面试--体检--政审--录取 报名：注册；选岗位；报考；资格审核；缴费；打印准考证（选岗位可以查看报考人数，以判断竞争激烈程度） 初审：专业、政治面貌等等，但是主要审核还是在政审环节，也即是说需要通过笔试面试 笔试 行测 国考：100分；135/130道题目；2小时 省考：100/150/200分；100/120/130/135/140道题目；2小时 重点内容：言语理解、判断推理、资料分析 申论 国考：100分；5道题目；3小时 省考：100/150/200分；2~5道题目；2.5/3小时 主要内容：给材料回答问题，小作文（100~500字）+大作文（1000~1200字） 专业知识 某些岗位需要：公安、财务、证券 面试 结构化面试；15分钟 4道题目：自我认知、综合分析、组织协调、人际沟通 考公 考编 行政编制 事业编制 很稳定，有律法保护，一般不会丢掉饭碗 用的国家行政经费 用的国家事业经费 晋升通道明确 晋升面较窄 考取难度大 上岸率较高 一年的考试机会少 考试机会较多 其他注意事项 准备用书：讲义、专项题库、真题、其他工具书 三不限：不限专业、不限应届学历、不限政治面貌，这种岗位一般竞争压力很大，例如100:1的报录比。尽量不选择这种岗位 选岗很重要 考公需要技巧，切忌学究 ⭕ 蓝调 Blues，解作蓝色，音译为布鲁斯，意思是情绪低调，忧郁十九世纪末开始出现的，起源于过去美国黑人的劳动歌曲蓝调音乐强调原创性和即兴性，着重自我情感的宣泄蓝调精神：用乐观的态度面对悲惨的人生 ⭕ 摩尔纹 只是想给PPT拍一张照片，但是为什么会出现摩尔纹？本质上是差拍原理的表现，相机的感光元件的空间频率与影像中条纹的空间频率接近，就会产生波浪型干扰图案的视觉效果，影响观看感受 进一步说明：假设有a、b两组条纹，它们以θ为夹角进行重叠，这将会产生一系列的交点。如果这些交点的距离较短，人眼无法分辨，连接起来就会形成较为明显的摩尔条纹要消除这种干扰，需要在相机的传感器前面使用抗混叠滤镜（低通滤镜），但是图片的分辨率也会下降，需要在摩尔纹和分辨率之间权衡 ⭕ 锡安主义 又称为犹太复国主义，锡安有代指耶路撒冷之意锡安主义支持以色列地重建犹太家园的行为但是近年来也有不少人反对锡安主义，认为以色列的建立使得一些居于当地的巴勒斯坦人失去家园，犹太人反而是侵略者 ⭕ 逆变器 逆变器可以将直流电转换成交流电主要应用于大电流、高电压的场合是工业上常用的电源，可提供超过数千瓦或以上功率的电力为保证发电机的稳定运行，发电机至少需要三个绕组，理论上发电的相数可以更高，但三相最经济，因此世界各国普遍使用三相发电、供电整流器则与之相反 ⭕ 银杏 植物王国的活化石，是世界上现存最古老的树种之一它们始终保留着亿万年前祖先的模样银杏的生命力顽强，主要原因是树干形成层干细胞不进入衰老阶段，并且树体的抗性超强 ⭕ 公元前、公元后（也叫西元前、西元后） 古代西方人把耶稣诞生的那一年称为公元纪年的开始对应着我们历史就是汉平帝登基的那一年 ⭕ 霍去病 西汉名将、军事家、民族英雄先后被封为骠姚校尉、骠骑将军 元狩四年，霍去病和舅舅卫青率兵深入漠北，消灭了匈奴左贤王部主力七万余人。追击匈奴至狼居胥山，并在狼居胥山举行了祭天封礼此战使得“匈奴远遁，漠南无王庭”但是可惜英年早逝，元狩六年，霍去病病逝，年仅二十四岁（猜测是领兵出征的劳累和环境的艰苦） 霍去病用兵灵活，注重方略，不拘古法，善于长途奔袭、快速突袭和大迂回、大穿插、歼灭战卫青、霍去病在对匈奴作战时，并不组织数十万大军打堂堂之阵，而是组织人数不多的数万骑兵长途奔袭，直捣王庭 ⭕ 哥德巴赫猜想 是数论中的未解问题1742年，哥德巴赫写给欧拉的信件中有一个猜想：任一大于2的偶数，都可以表示成两个质数之和 数值验证：截至2014年，数学家已经验证了4×10^18以内的偶数，在所有的验证中，没有发现偶数哥德巴赫猜想的反例 ⭕ 猫和路由器 modem，调制解调器通过以太网缆线连接到互联网 router，路由器多是指 WiFi 路由器路由器通常由多个以太网接口，可以用网线连接多个设备负责把服务器通信的网络型号转发到相应设备市面上很多猫和路由器的一体机 ⭕ 关于社保 🔘 参考资料 https://www.zhihu.com/question/296168327 这上面有举一些报销的例子 🔘 基本划分 职工社保（即五险一金中的五险） 面向上班打工人群，包括 职工养老保险 职工医疗保险 失业保险 生育保险 工伤保险 [!NOTE|style:flat] 劳动法规定，公司必须为员工缴纳社保按照月薪基数和缴纳比例，公司交一部分，我们自己再交一小部分每月缴纳 居民社保 面向没有工作单位的人群，如自由职业者，包括 1、居民养老保险 2、居民医疗保险：缴纳满15年，到达指定年龄后（一般60岁）就可以按月领取养老金 [!NOTE|style:flat] 每年缴纳，所需费用比职工社保少 [!NOTE|style:flat] 五险一金中的一金指：住房公积金用于申请优惠的房贷，可以拿去买房、租房 🔘 医保的一些问题 用于报销住院、看门诊、买药等费用 报销条件 使用广泛、价格偏低的甲类药可以完全报销，价格较高的乙类药按照比例报销； 治疗、检查、手术费按照比例报销；（体检、牙齿矫正不在其内） 普通病房床位可以报销。（VIP病床不可以报销） ⭕ front-end 问题 🔘 css 中的 display inline行内元素 block块状元素 inline-block行内块状元素 span, img, input, button, a, label, ... div, form, ul, canvas, ... 通过css的display设置 inline多个行内元素会排在同一行，直到占满就会换行不能设置width和height，高宽是元素内容的高宽设置margin、padding的top和bottom是无效的 block前后单独换行width、height、margin、padding有效 inline-block设置为inline-block的元素仍是inline，但是其里面的内容是block 🔘 关于 position https://www.jianshu.com/p/de316853060e?appinstall=0 块级元素的 position 属性值 1、static：默认值 2、relative：定位的方式为相对于自身之前的位置 3、absolute：向上一层一层找自己的父元素，谁的 position 属性 不是 static，就以谁为标准进行偏移 如果没有符合的话就只能以 body 的初始位置为基准。但是注意，body 也是块元素，position 默认为 static 要使绝对定位 absolute 生效，必须指定 left、right、top 和 bottom 中的至少一个 ⭕ 浏览器存储 https://bubuzou.com/2020/12/24/browser-store/ 浏览器本地存储了：Cookie、SessionStorage、LocalStorage、IndexedDB 等等其中 Cookie 是用于 维护服务端和客户端的会话状态（例如告知服务端当前客户端的用户的信息）Cookie 通常由 服务端生成，通过 响应头的 Set-Cookie 发送给客户端浏览器而客户端浏览器会将 Cookie 保存在本地，下次请求的时候会带上 会话 Cookie，没有指定过期时间或有效期，浏览器关闭后会自动删除 但是目前浏览器实现了 会话恢复功能，将其存储在 浏览器的内存中 持久性 Cookie，指定了。。。，存储在客户端的 硬盘中 ⭕ js的变量问题 const 用于声明常量，且不希望变量被重新赋值 let 当需要在块级作用域内声明变量，并希望能够重新赋值 避免使用 var，除非有特定的原因需要在函数作用域内声明变量否则建议使用 const 和 let 来提高代码的可维护性和可读性 function example() { var x = 10; // 函数作用域内的变量 if (true) { let y = 20; // 块级作用域内的变量 const z = 30; // 块级作用域内的常量 console.log(x); // 输出：10 console.log(y); // 输出：20 console.log(z); // 输出：30 } console.log(x); // 输出：10 console.log(y); // 报错：y is not defined console.log(z); // 报错：z is not defined } example(); 其实 const 保证的不是变量的值不变，而是保证变量 指向的内存地址所保存的数据不允许改动（即栈内存在的值和地址） JavaScript 的数据类型分为两类：原始值类型和对象（Object类型） 原始值类型（undefined、null、true/false、number、string） 值就保存在变量指向的那个内存地址（在栈中），因此 const 声明的原始值类型变量等同于常量 对象类型（object，array，function等） 变量指向的内存地址其实是保存了一个指向实际数据的 指针，所以 const 只能保证指针是不可修改的，至于 指针指向的数据结构 是无法保证其不能被修改的（在堆中） 重复声明：在同一作用域内多次使用相同的变量名进行声明在 JavaScript 中，使用 var 关键字声明的变量 可以 在同一作用域内重复声明，而使用 let 和 const 声明的变量则 不允许 重复声明 重复声明可能会导致一些问题和不可预测的行为：1、变量被覆盖：如果在同一作用域内多次使用 var 声明同一个变量，后面的声明会覆盖前面的声明，导致变量的值被修改2、变量提升：使用 var 声明的变量存在变量提升的特性，即 变量的声明会被提升到作用域的顶部。如果在同一作用域内多次声明同一个变量，可能会导致变量的 提升行为变得混乱和不可预测3、命名冲突：重复声明可能导致命名冲突，特别是在大型项目中，多个开发人员同时工作时更容易发生。这可能会导致 代码错误和难以调试 的问题所以使用 let 和 const 声明变量有助于提高代码的可读性、可维护性和可靠性。应该尽量避免重复声明变量，尤其是在使用 var 声明变量时更需要注意 ⭕ 浏览器开发者工具介绍 https://blog.csdn.net/zhang_hai_cheng/article/details/126327105 ⭕ 九宫格的拼图技巧 假设有8块拼图，在9个格子中移动1 2 34 5 67 8技巧是先还原好 123 再还原 47 ⭕ 黑马 technology blog https://yun.itheima.com/jishu/c27.html?capid=12 ⭕ manim 数学可视化安装 manim 克隆：git clone https://github.com/leekunhwee/manim.gitMiKTeX：https://miktex.org/downloadffmpeg 安装：https://github.com/BtbN/FFmpeg-Builds/releases注意安装路径中都不要包含中文 测试切换到克隆的 manim 目录下，注意使用对应的虚拟环境的 pythonpython -m manim example_scenes.py SquareToCircle -plpython -m manim example_scenes.py WarpSquare -plpython -m manim example_scenes.py WriteStuff -plpython -m manim example_scenes.py UpdatersExample -pl 参考资料https://zhuanlan.zhihu.com/p/70243739 .note { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; border-radius: 10px; display: inline-block; font-weight: bold; margin: 10px 0px; } .note:hover { animation: gradient-in 0.5s forwards; } .note:not(:hover) { animation: gradient-out 0.5s forwards; } @keyframes gradient-in { 0% { background-color: #f9f9f9; } 20% { background-color: #f5f5f5; } 100% { background-color: #e1e1e1; } } @keyframes gradient-out { 0% { background-color: #e1e1e1; } 80% { background-color: #f5f5f5; } 100% { background-color: #f9f9f9; } } .title1 { font-size: 24px; /* color: #333; */ } .title2 { font-size: 20px; /* color: #555; */ } .title3 { font-size: 16px; /* color: #777; */ } /* .note:hover [class^=\"title\"]{ font-size: 30px; opacity: 0.6; } */ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-02-17 18:15:30 "},"about_Other/Git的使用.html":{"url":"about_Other/Git的使用.html","title":"Git的使用","keywords":"","body":"推荐先看廖雪峰的教程，掌握基本的语句之后有需要再看完整的参考书 git加速：https://blog.csdn.net/B11050729/article/details/132131659 什么是 Git 分布式的版本控制系统方便 管理代码版本，也可以帮助多人协作 上图中各个位置的含义Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 Git 下载安装 下载地址详细安装教程 Git 的配置 注意下面的语句都是在 Git Bash 上面执行的 配置用户名和邮箱 git config --global user.name \"YJJ\" git config --global user.email \"1311906139@qq.com\" 注意如果没有加上 --global 那就只是针对当前仓库，而不是所有仓库 查看当前所有的配置信息 git config --list 设置彩色的 git 输出 git config color.ui true 常用命令 初始化 切换到 D 盘 cd d: 创建一个新的文件夹 learngit mkdir learngit 进入新建的文件夹 cd learngit 查看当前路径 pwd 切换到新的文件夹下，初始化一个 git 仓库，即图中的 Repository git init 查看当前目录下的所有文件，应该有一个 .git 文件夹 ls -ah 文件的提交 将文件添加到暂存区，即 Index/Stage git add 将文件提交到 Repository，-m 参数后的描述是为了便于理解提交内容 git commit -m \"本次提交的相关描述\" 注意可以多次执行上面 git add 操作，最后再执行一次 git commit 状态 查看本地仓库当前的状态，列出所有变更的文件 git status 差异 查看文件修改的地方 git diff 文件名 查看当前文件与本地仓库中的版本之间的不同之处 git diff HEAD -- 文件名 日志 查看提交的日志 git log 进入日志后，下方显示冒号 : ，这时可以输入英文 q 退出 美化日志输出信息 由于 Git 中文件的索引不是文件名，而是 一长串哈希值，所以有时候查看日志界面很混乱，通过以下命令美化 git log --graph --pretty=oneline --abbrev-commit 查看某人的提交记录 git log --author=YJJ 版本回退 回退至上一个版本 git reset --hard HEAD^ 回退至上两个版本 git reset --hard HEAD^^ 回退至上 n 个版本 git reset --hard HEAD~n 回退至指定版本 git reset --hard 版本号 版本号就是那一串哈希值，但不用写全，只取前几位就可以 获取远程仓库上的最新版本，并将主分支 main 指向它 git reset --hard origin/main 历史 查看已执行的命令 git reflog 可以用于查看版本号 撤销修改 工作区的丢弃 git restore 文件名 或者 git checkout -- 文件名 注意 -- 很重要 该语句会使用本地仓库中最新内容替换当前工作区中的文件 暂存区的丢弃 先撤销暂存区的： git restore --staged 文件名 再撤销工作区的： git restore 文件名 删除 删除仓库 rm -rf .git 删除文件 git rm 文件名 相当于 rm 文件名 git add 文件名 远程仓库 创建 SSH Key 先去 C:\\Users\\ 自己的 PC 用户名，看看是否存在 .ssh 这个文件夹，里面是否有 id_rsa 和 id_rsa.pub 这两个文件 如果没有，则执行下面的语句 ssh-keygen -t rsa -C \"自己的邮箱\" 执行后一路回车，暂时不需要设置密码 查看 id_rsa.pub 中的内容 cd ~/.ssh cat id_rsa.pub 再自己手动复制一下内容 设置 Github 注册好 Github 账号 登录后在 Settings 中找到 SSH 设置项中添加新的 SSH Key 设置任意 title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容 关联远程仓库 先在 Github 上面创建一个新的仓库，命名为 learngit，再执行 git remote add origin git@github.com:yjjyjya/learngit.git 或者 git remote add origin https://github.com/yjjyjya/ubuk.git 查看远程仓库信息 git remote -v 删除已关联的远程仓库 git remote rm origin 推送本地仓库的 main 分支到远程仓库 git push -u origin main 这里的 origin 是默认的，可以更改 [!NOTE] 注意第一次推送需要有个 -uGit 会把本地的 main 分支和远程的 main 分支 关联起来，之后的推送或者拉取就可以简化命令 git push origin main 将远程仓库的内容克隆到本地 git clone git@github.com:yjjyjya/learngit.git 或者 git clone https://github.com/yjjyjya/learngit.git 分支 主分支 main 主要用于主线代码的开发新建分支的目的：保证我们主分支继续执行的情况下，能够做一些其它的事情【比如bug修复或是难题攻克】 查看当前的分支有哪些 git branch 创建分支，名为 dev git branch dev 切换到分支 dev git switch dev 或者 git checkout -b dev 创建并切换到分支 dev git switch -c dev 删除分支 dev git branch -d dev 需要 强制删除 时，将 -d 换成 -D 将分支 dev 合并到当前分支 git merge dev 有时候合并失败需要 手动处理 再合并 禁用 fast forward 方法的合并 git merge --no-ff -m \"merge with no-ff\" dev 拉取远程分支的最新内容 git pull 将提交历史整理成直线 git rebase 标签 给某个提交创建带有说明的标签 用 -a 指定标签名，-m 指定说明文字 git tag -a 标签名 -m \"标签的说明信息\" 版本号 查看所有标签 git tag 查看标签信息 git show 标签名 删除本地的标签 git tag -d 标签名 推送一个本地标签到远程仓库 git push origin 标签名 # 一次性把所有标签推送到远程仓库 git push origin --tags 删除一个远程标签 git push origin :refs/tags/标签名 紧急切换 将当前工作区的内容暂存起来且隐藏 git stash 查看隐藏的内容 git stash list 恢复隐藏的内容并删除 stash 的内容 git stash pop 解决 bug 后，同步各分支的内容 git cherry-pick 版本号 图形化 打开 Git GUI或者切换到仓库的路径下，执行 gitk 可能遇到的问题 1、若想要 Git 忽略掉对某个文件的管理 先删除已经托管的文件 git rm -cached 某文件 将该文件写入 .gitignore 文件中 然后 add 再 commit 再 push 到远程仓库即可 2、git push 发生错误 可能本地仓库和远程仓库的 文件有冲突，要先 pull 远端的版本，解决了冲突才能 push git pull origin main / git pull origin main --allow-unrelated-histories 先拉取合并到本地仓库 git push -u origin main 再推送上去 [!NOTE] 建议在新建仓库的时候，不要勾选 README 和 .gitignore 选项，统一由本地生成，这样在建立关联关系的时候就不会有冲突了 3、 .gitignore 文件的书写 .gitignore 文件一般放在代码库的根目录下，但是也可以在其他目录下，支持多个 .gitignore 文件 # 为注释 \\ 为转义字符，可以转义空格 ! 使得文件重新添加进来，不 ignore /doc/frotz/ 只会匹配 doc/frotz 目录，而不会匹配 a/doc/frotz 目录 但是 frotz/ 匹配 frotz 目录以及 a/frotz 目录，等价于 **/frotz 所有路径都是相对 .gitignore 文件所在的路径 * 只能匹配文件和当前目录下的一级目录 foo/* 能匹配到 foo/test.json，foo/bar，但不能匹配到 foo/bar/hello.c，因为 * 匹配不到含有 / 的部分 abc/** 匹配目录 abc (相对于 .gitignore 的路径)下的所有文件 a/**/b 可以匹配 a/b、a/x/b、a/x/y/b 等等 有趣的 Git 闯关练习 https://learngitbranching.js.org/?locale=zh_CN展示答案 show solution选择关卡 levels重置 reset 下面是关卡中常用的语句 git commit 执行一次提交后，产生新的节点 c2 git branch newImage 创建一个名为 newImage 分支 git checkout newImage; git commit 切换到 newImage 分支并进行提交 git checkout -b bugFix 创建并切换到 bugFix 分支 等同于：git branch bugFix; git checkout bugFix git branch -f main C1 强制让 main 分支指向 C1 git checkout 哈希值 绝对引用，切换到对应哈希值的提交上，分离出 HEAD git checkout main^ 等同于 git checkout main~1 相对引用，向上移动一个提交 让 HEAD 指向 main 的上一次提交 git checkout main~; git checkout main^2; git checkout main~2; git checkout o/main 切换到远程分支 o/main，若进行提交，则会变成 HEAD 分离状态，但是实际上 o/main 不会变化 git checkout -b feature C2; git push origin feature 创建一个新的分支 feature 指向哈希值为 C2 的提交，再将本地的 feature 分支推送到远程 git checkout -b foo o/main 设置新的分支 foo 跟踪远程仓库 o/main（原本是本地的main去跟踪） git merge bugFix 将分支 bugFix 合并到当前分支上 git rebase main 使得提交记录清晰，将当前分支复制到 main 分支 git rebase -i HEAD~4 参数-i表示打开交互式的 rebase，在UI界面中可以调整提交的顺序，删除不想要的提交等等 git pull 拉取并合并 git pull = git fetch + git merge git pull --rebase 也是拉取后合并，但是 rebase 的提交记录更加简洁 git push 推送更新到远程仓库，若失败则可能是因为最新提交的 C3 基于远程分支中的 C1，而远程仓库中该分支已经更新到 C2 了。可以先 git fetch; git rebase o/main; git push 拉取最新的进行合并，再上传。但是若需要使得远程仓库也包含修改的分支，则使用 merge 而不是 rebase git push origin foo 推送更新远程的 foo 分支 git push origin foo^:main 将本地的 foo 分支的父提交推送到远程的 main 分支上（支持重命名）；对应的 push 改成 fetch 也是同理的；冒号前后置空可以用来删除分支 cat .git/HEAD 查看 HEAD 指向 git reset HEAD~1 将当前分支回退到 HEAD~1，但是当前分支还在工作区中只是未 add 到暂存区中 git revert HEAD~1 创建与 HEAD~1 相同的新提交，效果相当于撤回，远程分支也就能进行 “撤回” 操作 git cherry-pick 哈希值1 哈希值2 将对应哈希值的提交复制到当前分支进行提交 git cherry-pick C2 C4 git commit -amend 把上一次的 commit 记录去除，修改 commit 信息 git tag v1 C1 建立一个标签 v1，指向提交记录 C1 git describe C1 查看提交的信息 ^数字 可以指定向上移动到某个父提交，git branch 分支名 后面也可以跟上 ^ 指定位置 git clone 远程仓库地址 在本地创建一个远程仓库的拷贝 git fetch 可以理解为单纯的下载远程仓库 git fakeTeamwork foo 3 在远程仓库的 foo 分支上做三次提交 参考资料 https://zhuanlan.zhihu.com/p/30044692https://blog.csdn.net/qq_34519487/article/details/107882290 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-20 21:18:57 "},"about_Other/关于FGO中的角色.html":{"url":"about_Other/关于FGO中的角色.html","title":"关于FGO中的一些角色","keywords":"","body":"尼禄 尼禄·克劳狄乌斯·恺撒·奥古斯都·日耳曼尼库斯公元 37 年~68 年罗马帝国第五位皇帝，欧洲史上著名的暴君是意外而登基为帝。41 年，皇帝卡利古拉遭到刺杀后，近卫军拥立这位克劳狄乌斯家族的中年男子，并受到元老院的承认而继位为罗马皇帝 用人方面眼光独到热爱艺术，是诗人、剧作者、演唱者，还会竖琴演奏在位期间，实施了一系列的改革和建设项目，包括修建剧院、巨大的宫殿和游乐场等 后世对其评价一般都不佳，称之为“嗜血的尼禄”尼禄喜爱奢华，对亲人和臣属残暴，对政敌和异议人士采取了残酷的镇压手段将公元 64 年罗马城市发生大火的责任归咎于基督教徒，大规模公开迫害基督教 尽管他的统治充满争议，但尼禄克劳狄乌斯在罗马历史上仍然是一个备受关注的人物，他的个人故事和统治方式对后来的历史产生了深远的影响 西元纪年和公元纪年没有实质上的区别，指同样的时间系统，用来记录历史上的年份西元纪年是基于基督教的历史观念而来，用于纪念耶稣基督的诞生。西元纪年的起点被认为是公元 1 年，即耶稣基督的出生年份公元纪年则是更加中性的术语，不涉及宗教观念 齐格飞 Siegfried德国叙事诗《尼伯龙根之歌》中的英雄 《尼伯龙根之歌》分为两个部分：1、齐格飞为追求勃艮第公主克林姆希尔德（Kriemhild），加入勃艮第军2、齐格飞之死，妻子克林姆希尔德复仇 齐格飞具有良好的品格，善良正义、光明磊落、温良谦让、深爱妻子诗中，齐格飞与尼伯龙根族战斗获得财宝；击杀恶龙法夫纳，浸沐龙血获得刀枪不入的身体（但是当时背后沾上了椴树叶，那处成为了唯一弱点） 恺撒 盖乌斯·尤利乌斯·恺撒公元前 100 年~公元前 44 年罗马共和国杰出的军事统帅、政治家，史称恺撒大帝 恺撒在军事上展现出了非凡的才能，他击败了高卢蛮族（现在的法国），征服了不列颠（现在的英国），扩大了罗马帝国的领土。为养子屋大维开创罗马帝国打下了良好的基础在政治上，通过巧妙的策略和政治手段，逐渐积累了大量的权力。他与庞培和克拉苏组成前三头同盟，但最终与庞培发生冲突，导致了内战的爆发。恺撒在内战中取得了胜利，成为了罗马的独裁者 恺撒还进行了一系列的改革，包括改革罗马的日历系统（即朱利安历），推动土地改革，减轻贫困阶层的负担等。他还致力于加强罗马帝国的中央集权，但这也引起了一些贵族的不满恺撒的权力和影响力引起了一些人的担忧，最终导致了他的暗杀。他于公元前 44 年被几名贵族暗杀，结束了他的统治 阿蒂拉 真实身份是阿提拉（Attila）公元 406 年~453 年匈奴帝国的国王，也是欧洲历史上著名的游牧民族领袖之一，被称为“上帝之鞭” 阿提拉的军事才能和领导能力使得匈奴帝国迅速扩张，成为了一个庞大的帝国，控制着东欧和西亚的广大领土。他以其强大的军事力量和战略才能而闻名，多次领导军队进行掠夺性的征服和侵略公元 453 年，他在婚礼上去世。他的死亡导致了匈奴帝国的分裂和衰落，不再具备统一欧洲的力量 阿提拉的形象在历史和文学作品中被描绘为一个野蛮、残暴的征服者，但也有一些人将他视为一个英勇的领袖和保护者 吉尔·德·雷 吉尔斯·德·莱斯1404 年~1440 年英法百年战争时期，吉尔斯曾担任陆军高级指挥官，参与并指挥对英军的作战，在这期间，他被任命为法国元帅 在 1428 年的奥尔良战役，和第二年的卢瓦尔河谷扫荡战中均有出色表现巴黎受围攻时，他与贞德并肩作战，贞德被英军处以火刑后的第二年，他击败贝德福德公爵，这一战充分展示了他的军事才华 贞德被俘以后，他退隐于马什库勒和蒂福日的领地埋头研究 炼金术。他希望借血来发现点金术的秘密，大约把 300名以上的儿童折磨致死，后亦因此被施以火刑。他也是西方童话传说中的反派角色“蓝胡子”的现实原型之一 骑士迪昂 迪昂·德·鲍蒙1728 年~1810 年法国史上的一位剑术大师，骑士迪昂 路易十五将迪昂加入其秘密的外交机关，命迪昂将密函交给俄国女皇伊丽莎白一世，以重建法俄之间的外交关系。迪昂完成了他的使命但是战争后期，新俄国女王叶卡捷琳娜宣布法俄同盟无效，法军在与英军的战斗中节节败退，最后还是迪昂窃取英国的军事机密得以与英国进行调停谈判战争结束后，迪昂被授予圣路易十字勋章 迪昂被新王路易十六算计，需终身女装，之后的境遇一直不佳 剑术很棒，曾通过参加剑术比赛赚取外快，五十九岁的迪昂大败伦敦最强剑士 吉尔伽美什 Gilgamesh苏美尔人，乌鲁克第五任君主，统治年间约在公元前27世纪《吉尔伽美什史诗》是目前人类历史上已知的最古老的英雄史诗，是人民群众集体智慧的结晶 史诗在内容上可以分为四部分：1、初期，吉尔伽美什作为乌鲁克君主，他的力量和勇气使他受到人们敬仰和尊崇，但是也因为他的傲慢和专横而受到批评，他施行残酷统治，使得民不聊生。人们祈求上天的拯救，大神阿卢卢创造了半人半兽的勇士恩奇都（Enkidu），其与吉尔伽美什经过激烈的战斗不分胜负，最后二人相互吸引，结为好友2、吉恩二人一起经历了许多冒险。先后战胜了沙漠中的狮子，杀死了杉树林中危害人民的怪物芬巴巴，又共同杀死了残害乌鲁克城居民的“天牛”等等，为人民造福，成为被群众爱戴的英雄3、吉尔伽美什与伊什塔尔（Ishtar）女神发生冲突，导致了他的朋友恩奇都得罪天神阿努，受到死的惩罚。吉尔伽美什怀着极大的悲痛，为寻找永生而踏上了一段长途旅程，最后什么也没有得到4、吉尔伽美什回到乌鲁克城，祈求神的帮助，得以与恩奇都的幽灵对话 吉尔伽美什的故事探讨了人类存在的意义、死亡和永生的主题。他的形象在古代美索不达米亚文化中具有重要的象征意义，并对后来的文学和艺术产生了深远的影响 罗宾汉 Robin Hood英国民间传说中的英雄人物，别名汉丁顿伯爵他武艺出众、机智勇敢，仇视官吏和教士，是一位劫富济贫、行侠仗义的绿林英雄 故事中他效忠于狮心王理查，由于某些原因诺丁汉郡长抢占了罗宾汉家的领地，并且约翰王子企图篡权。罗宾汉在舍伍德森林（Sherwood Forest）集结了一帮绿林好汉，劫富济贫，最终粉碎了约翰王子等人的阴谋 罗宾汉最突出的就是射箭术高超射箭比赛中仍有一个术语叫做“Robin Hood”，意为“射中另一支已射中靶心的箭，并且将箭身一分为二” 12 世纪中叶，罗宾汉的传说在民间流传。法国文豪亚历山大·仲马在前人的基础上创作出了《侠盗罗宾汉》 阿塔兰忒 Atalanta古希腊神话中擅长奔跑的女猎手 阿塔兰忒是伊阿索斯国王的女儿，但是她出生时就被抛弃后面有一群猎人找到并养育她，便成长为了优秀的猎人与众多的英雄一起捕杀了卡吕冬野猪 赛跑结婚：求婚者若能跑赢阿塔兰忒则能与她结婚，否则就得被杀死希波墨涅斯向爱神阿佛洛狄忒求助，爱神给他三颗金苹果，这些苹果都是不可抗拒的让希波墨涅斯丢苹果，阿塔兰忒不得不把它们捡起来，减缓了速度，最终跑赢了阿塔兰忒 尤瑞艾莉 Euryale希腊神话角色，戈尔贡三姐妹之一，是美杜莎的姐姐 海神福耳库斯的女儿，魔身，传闻看见她的眼睛的人就会石化因为拥有不死之躯，珀尔修斯的砍杀无法使其消灭 尤瑞艾莉的形象常被艺术家用于徽章、建筑的装饰物上面 阿拉什 古代波斯的传奇射手伊朗人民心中极具代表性的大英雄 古代波斯和古代图兰之间战争不断，后期和平谈判的时候在地盘的划分上出现了争执最后双方提出一个提案：选出一位勇士登上徳马峰，放出箭矢，箭矢的落地之处即两国的边界线选出的勇士就是阿拉什，古代波斯第一 Archer阿拉什使用特制的弓与箭，拼尽全力将箭射出，但是紧接着他强壮的身体也开始迸裂开承载着他生命的一箭化作了难以直视的流星，飞行了长达 2500 千米，最终抵达阿姆河的河岸，无论波斯还是图兰都把这一切当作了神灵的旨意，接受了这一箭的结果 射箭的那天是夏至，至今仍是伊朗人民一年里最盛大的节日之一，纪念的对象就是阿拉什英雄 库·丘林 CuChulainn欧洲凯尔特神话中爱尔兰光神鲁格的儿子 原名瑟坦特，是一名易怒暴躁的战士在他7岁的时候曾将打铁匠库兰的猛犬杀死，为了补偿这个过失，瑟坦特宣誓暂时代替猛犬守护其主人，此后人们便称他为库林的猛犬，即库丘林成年后向神秘之地的主人斯卡哈学习武艺，在这期间得到了 Gáe Bolg，这把矛在刺中对方后，矛上的 30 根倒刺会将对方开膛破肚 在阿尔斯特的战争中，库丘林在七年里一直支持着居于劣势的阿尔斯特军并且英勇对抗向康诺特发动进攻的三国联合军，他孤军奋战，但是还是成功延滞了联军进攻的脚步并抓住了战争的元凶梅芙 伊丽莎白·巴托里 1560 年~1614 年匈牙利的一位伯爵夫人，但是只是荣誉头衔，没有实权 她是欧洲屈指可数的大地主，但是对财务也会精打细算在民众福利方面，她投入大量资金来振兴国内教育、建立医院和新教学校、资助留学生、保障农民和教会的权益人们对她的评价很高，国王甚至命令自己的女儿也要向她学习 在 1610 年 3 月，首相乔治·图尔索下令调查伊丽莎白·巴托里的案子，理由是怀疑她虐待和谋杀仆人图尔索于 1610 年 12 月 29 日在 恰赫季斯堡 当场逮捕了伊丽莎白和四名被指控为其帮凶的仆人根据图尔索的书信，他的 30 多名手下在伊丽莎白的家中发现了一名死亡的女孩，一名垂死的女孩，一名受伤的妇女和其一群被关押的人，因此伊丽莎白被软禁了 伊丽莎白和她的仆人被捕后，进行了两次审判四个仆人在受到严刑逼供之后被处死，伊丽莎白则被软禁在自己的城堡里，直至去世都没有得到审判 武藏坊弁庆 1155 年~1189 年平安时代末期的僧兵，为 武士道精神 的传统代表人物之一 弁庆在比睿山出家，后改名武藏坊弁庆他曾四处游历，看到往来武士身上有太刀便要求比武，之后败给了源义经（遮那王，也即牛若丸）武藏坊弁庆跟随源义经讨伐平家，后来源义经受到兄长迫害，武藏坊弁庆一路相互最后舍命护主，力战之后仍究寡不敌众。传说弁庆是身中万箭站立而死，即著名的“立往生” 弁庆的七种道具薙刀、铁之熊手、大槌、刺又、大锯、钺和铁棒 FGO 中的武藏坊弁庆不是真的，而是常陆坊海尊常陆坊海尊便与武蔵坊弁庆一起追随源义经在衣川自卫战中，与源义经的数名家臣一起拜求山寺，得到长寿虽然劫后余生但是他也因为抛弃了源义经逃到山中寺庙而自责，后归隐 列奥尼达一世 公元前 ? 年~公元前 480 年列奥尼达这个名字的含义是：像猛狮一样的人他是古希腊的斯巴达国王，为人勇猛异常，每战必身先士卒 在第二次希波战争中，列奥尼达一世任 希腊抗波联军 的陆军统帅，率领约 7000 人镇守北、中希腊之间交通要冲温泉关，旨在阻止 10 余万波斯军南下后因当地希腊人出卖，联军腹背受敌。列奥尼达为保存实力命令联军撤退，自己则率领 300 名斯巴达勇士坚守，与 波斯帝国 的大军殊死搏斗，终因寡不敌众全部壮烈牺牲此即著名的 温泉关战役，其英勇的表现使他成为了古希腊英雄人物之一 罗穆路斯 Romulus公元前 771 年~公元前 716 年罗马神话人物，罗马的第一任王 罗穆路斯拟定了罗马城最初的主要政治制度，组织军队，设立元老院修建了帕拉丁城堡，招募四方外来人口作为罗马公民，来着不拒，不分自由人和奴隶 著名的抢劫妇女事件新建的罗马城有很多壮丁，但是缺少妇女繁衍后代元老院提出派遣使者到相邻诸国通婚，但是都遭到拒绝在一次献祭仪式中，罗马人通过盛大的场面吸引众多邻近村落的人们，士兵用刀剑抢走了百名青年男女之后萨宾大城奎里斯之王 弟提斯 率兵向罗马人问罪，要求交还自己的人民第二年春，萨宾人向罗马发动进攻，战争规模空前后面因为萨宾妇女的祈求，双方停战，萨宾和罗马国合并，共同居住在一起 后面因为对外战争的功绩显赫，罗穆路斯的威望和权势越来越大，开始了一系列的君主专制这让元老院的议员贵族感到不安，之后罗穆路斯神秘失踪了 美杜莎 Medusa古希腊神话中的蛇发女妖，戈尔贡三姐妹之一她有蛇发无蛇身，看见她眼睛者皆会被石化 戈尔贡是蛇女三姐妹的统称1、斯忒诺2、尤瑞艾莉3、美杜莎 雅典娜借给了珀尔修斯一些宝物：赫尔墨斯之靴，穿上可以飞天哈迪斯之帽，戴上可以隐身一个伸缩自如，无法破坏的皮袋一把削铁如泥的宝剑以及雅典娜自己的盾牌 珀尔修斯趁着美杜莎熟睡之际，用宝刀砍下了她的头颅之后美杜莎的头颅被镶嵌在雅典娜的神盾中后世也多将美杜莎绘在盾牌上，有驱邪、恐吓敌人的效果 乔尔乔斯 原型是欧洲神话故事中的圣乔治公元 260 年前后圣乔治是一名罗马骑兵军官，骁勇善战 著名的屠龙故事：有一恶龙威逼城堡的堡主交出其美丽善良的女儿，作为祭品献给它上帝的骑士圣乔治以主之名出现，经过激烈的搏斗，最终将凶残的恶龙铲除一地的龙血逐渐形成一个十字形这个故事影响深远圣乔治是一个基督教的圣人，他的胜利被认为是信仰的胜利，提醒我们信仰和希望的力量，不要畏惧恶势力和挑战圣乔治保护弱者和无辜者的行为也体现了正义的精神 英国国王查理一世（狮心王）在十字军第三次东征的时候亲自率兵，在圣乔治屠龙地的附近取得了一场巨大的胜利从此圣乔治被视为英国的守护圣人设计出 白底红十字 的圣乔治旗，圣乔治十字 也被作为英国军队的纹章英国早期金属钱币中，也常常出现圣乔治屠龙的图案 爱德华·蒂奇 Edward Teach1680 年~1718 年世界航海史著名的海盗爱德华·蒂奇长着一把浓密的络腮胡，有时候会扎成细长的辫子诨号“黑胡子” 当时英国政府默许一些武装民船在海上抢劫过往的外国商船，主要针对的是西班牙商船年轻的黑胡子就是在这样的武装民船上当水手1713年，英西海战落幕，英国成为海上霸主。围绕英、非、南美的三角贸易兴起，为英国带来巨额财富但是武装民船也逐渐大胆，许多水手成为了职业海盗黑胡子有一次在加勒比海遇到一艘法国的贩奴船“协和号”，通过理智判断船上的船员因为瘟疫和断粮毫无生气成功截取了这艘大商船，并重新命名为 安妮女王复仇号之后遇到英国海军，也毫不避嫌，直接与之交战，因为黑胡子自杀性的亡命徒战斗方式惊住了英国海军，最终英国官兵死伤惨重，黑胡子从此名震天下 1718年黑胡子围攻北美的英国殖民地 北卡罗来纳 的查尔斯顿港口，北卡罗来纳总督已经向英国海军寻求援军5月时，黑胡子率领的海盗船在奥克拉库克海湾被英国皇家海军军舰 里姆号及珍珠号 拦截，黑胡子在战斗中被英国海军军官梅纳德所杀从那时起，有关黑胡子下落不明的宝藏就开始流传成无数种说法 布狄卡 Boudica?~公元 60 年或 61 年英格兰东英吉利亚地区 古代爱西尼部落 的王后和女王她领导了不列颠诸部落 反抗罗马帝国 占领军统治的起义 在公元61年左右，布狄卡发动了反抗罗马帝国的起义，起义起因于罗马帝国对其部落的侵略和压迫据历史记载，她的丈夫普里斯塔古斯（Prasutagus）是罗马人的傀儡，罗马帝国试图在其死后吞并爱西尼 布狄卡的起义在开始时取得了一些胜利，她成功地攻占了相当于今天的伦敦（当时的伦敦还只是一个小港口城市）和圣·奥尔本。然而，最终她的起义被罗马军队镇压，她自己也服毒自尽尽管布狄卡的起义失败了，但她的勇气和抵抗精神在不列颠历史中留下了深刻的印记。她被视为不列颠抵抗罗马统治的象征，她的故事也成为了英国民族英雄的一部分 牛若丸 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:07:51 "},"about_Other/一些乐理知识.html":{"url":"about_Other/一些乐理知识.html","title":"部分乐理知识","keywords":"","body":"五线谱是记录音乐的语言五条平行线，线之间叫做【间】 高音谱表：【从下往上】分别叫做第一线，第二线，...，第五线第一线和第二线之间叫做第一间，以此类推 低音谱表：注意是【从上往下】分别叫做第一线，第二线，...，第五线第一线和第二线之间叫做第一间，以此类推 音名 c d e f g a b 简谱音 1 2 3 4 5 6 7 唱名 do re mi fa sol la si C 到 D 是大 2 度（注意不是 1 度） 钢琴中每12个键（包括黑白键）叫做一组中央 c 位于小字一组 高音谱号：也叫 G 谱号，记在五线谱的第二线上 下加一线为中央 c ----------------------- f2(fa) e2(mi) ----------------------- d2(re) c2(do) ----------------------- b1(si) a1(la) ----------------------- g1(sol) 高音谱号标识的位置 f1(fa) ----------------------- e1(mi) 低音谱号：也叫 F 谱号，因为它记在五线谱的第四线上 上加一线为中央 c ----------------------- a(la) g(sol) ----------------------- f(fa) 低音谱号标识的位置 e(mi) ----------------------- d(re) c(do) ----------------------- B(si) A(la) ----------------------- G(sol) 中音谱号：也叫 C 谱号，最中间的部分对准哪一条线，这条线上标出的音就唱 do 升降记号 符号所在的行需要进行升调或者降调 音符名 时值（拍数） 图片 全音符 4拍 二分音符 2拍 四分音符 1拍 八分音符 半拍 十六分音符 1/4 拍 三十二分音符 1/8 拍 ...... 好玩的 可以通过特定的markdown生成对应的谱子：https://markdown.lovejade.cn/?utm_sourece=markdown.lovejade.cn&pid=main-title 参考资料 https://www.zhihu.com/question/25437178https://www.zhihu.com/question/277068980 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-01 16:33:45 "},"about_Other/五十音.html":{"url":"about_Other/五十音.html","title":"五十音","keywords":"","body":"五十音 浊音 （右上角两点或者圆圈） あ ア (a) い イ (i) う ウ (u) え エ (e) お オ (o) か カ (ka) き キ (ki)✅ く ク (ku) け ケ (ke) こ コ (ko) ka->ga さ サ (sa) し シ (shi)✅ す ス (su) せ セ (se) そ ソ (so) sa->za た タ (ta) ち チ (chi)✅ つ ツ (tsu) て テ (te) と ト (to) ta->da な ナ (na) に ニ (ni)✅ ぬ ヌ (nu) ね ネ (ne) の ノ (no) は ハ (ha) ひ ヒ (hi)✅ ふ フ (hu) へ ヘ (he) ほ ホ (ho) ha->ba、pa ま マ (ma) み ミ (mi)✅ む ム (mu) め メ (me) も モ (mo) や ヤ (ya) い ゆ ユ (yu) え よ ヨ (yo) ら ラ (ra) り リ (ri)✅ る ル (ru) れ レ (re) ろ ロ (ro) わ ワ (wa) い う え を ヲ (wo) h (n) 拗音 上述表格中打勾的✅可以分别与 や、ゆ、よ 结合，然后其浊音又可以再结合一次 きや (kya) きゆ (kyu) きよ (kyo) しや (sha) しゆ (shu) しよ (sho) ちや (cha) ちゆ (chu) ちよ (cho) にや (nya) にゆ (nyu) によ (nyo) ひや (hya) ひゆ (hyu) ひよ (hyo) みや (mya) みゆ (myu) みよ (myo) りや (rya) りゆ (ryu) りよ (ryo) ...... ...... ...... Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:32:18 "},"about_Other/bat语法.html":{"url":"about_Other/bat语法.html","title":"bat 语法","keywords":"","body":"推荐还是自己将这些语句进行测试毕竟还是存在很多问题 简介 批处理文件是以 .bat 结尾的文本文件，这个文件的每一行都是一条 DOS 命令大小写不敏感(命令符忽略大小写)文件扩展名为 .bat 或 .cmd可以先创建一个 txt 文件，之后再将后缀修改为 .bat双击该批处理文件，系统就会调用 Cmd.exe 来运行该文件 支持通过 if 和 goto 来控制流程，也可以使用 for 循环但是编程能力远不如 C 语言等编程语言，也十分不规范 C:\\AUTOEXEC.BAT 是每次系统启动时都会自动运行的，可以将每次启动时都要运行的命令放入该文件中 常用语句 参数 系统参数 传递参数 参数下标从 1 开始，通过百分号加数字表示 call test2.bat \"hello\" \"haha\" 在 test2.bat 文件里写: echo %1 (打印 \"hello\"，对应传入的第一个参数) echo %2 (打印 \"haha\") echo %0 (打印 test2.bat) echo %19 (打印 \"hello\"9) 获取当前所在路径 %~dp0，其中 d 为 Drive 的缩写，即为驱动器，磁盘。p 为 Path 缩写，即为路径，目录cd %~dp0 进入批处理文件所在的目录cd %~dp0bin\\ 进入批处理所在目录的 bin 目录 bat 文件中若单行代码太长可以使用 ^ 进行换行shell 脚本中则可以使用 \\ 获取命令帮助 xxx /?例如 ping /? 终止进程 taskkill /f /im ???.exe taskkill /f /im ???.exe 是一个用于终止进程的Windows命令。 /f 参数表示强制终止进程，即无需提示用户确认即可终止进程。 /im 参数后面跟着的是进程的映像名称（Image Name），用于指定要终止的进程。 在命令中的 ??? 部分需要替换为具体的进程映像名称，例如 notepad.exe 或 chrome.exe。 使用 taskkill 命令终止进程需要管理员权限 echo 命令 echo 命令类似于 print 函数，也可以配合重定向符号使用，将输出的内容写入文件中 echo off 使得命令行窗口 在其之后的命令 只显示脚本运行结果，而不会显示每个命令的具体执行过程。用于隐藏命令行窗口中的冗余输出，使输出结果更加简洁@ 符号表示不显示 当前该行 的命令所以常常将二者结合使用：@echo off Goto 命令 goto label指定跳转到 label 标签行，找到标签行后，程序将处理从 下一行开始 的命令label 标签的名字最好是有意义的，字母前必须加个 冒号 : 来表示这个字母是标签经常与 if 配合使用，根据不同的条件来执行不同的命令组 Rem 命令 Rem Message...起到一个 注释 的作用，便于自己和别人理解命令含义 小技巧可以用 :: 代替 rem Pause 命令 会暂停批处理的执行并在屏幕上显示 Press any key to continue... 的提示，等待用户按任意键后继续pause 命令会使程序挂起 Call 命令 调用 另一个 批处理程序，并且 不终止 当前的父批处理程序如果不用 call 而直接调用别的批处理文件，那么执行完那个批处理文件后 将无法返回 当前文件并执行当前文件的后续命令无法在脚本或批处理文件外使用 call例子：call=\"%cd%\\test2.bat\" arg1 arg2 arg3 调用指定目录下的 test2.bat，并传入 3 个参数 注意可以调用自身，但是注意死循环、递归 start 命令 调用外部程序，所有的 DOS 命令 和 命令行程序 都可以由 start 命令来调用 常用参数 MIN 开始时窗口最小化 WAIT 启动应用程序并等候它结束 例子：start /MIN e:\\\"program files\"\\hello\\world.exe arg1 arg2，用于调用某个目录下的 .exe，并传入 2 个参数，且 /MIN 参数使得窗口最小化 注意文件路径名有空格时，就利用双引号 If 命令 if [not] \"某参数\" == \"字符串\" (命令)若某参数等于指定字符串的条件成立，则运行指定命令，否则跳过，运行下一句 if exist 某文件 type 某文件如果存在某文件，则显示它的内容 if [not] errorlevel (命令)若错误码 errorlevel（或称返回码）等于指定的数字，则条件成立，运行指定命令，否则跳过，运行下一句返回值必须按照 从大到小 的顺序排列 if 条件1 (条件1成立时执行的命令) ^ else if 条件2 (条件2成立时执行的命令) ^ else (都不成立时执行的命令)` 注意换行后面的 ^ 比较运算符EQU - 等于 (一般使用“==”)NEQ - 不等于 (没有 “!=”,改用“ if not 1==1 ”的写法)LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于 choice 命令 此命令可以让用户输入一个字符（用于选择），从而根据用户的选择返回不同的 errorlevel（choice的返回值是环境变量errorlevel的值）然后配合 if errorlevel 选择运行不同的命令 例如： choice /c abc /n ::应先判断数值最高的错误码 if errorlevel 3 goto defrag if errorlevel 2 goto mem if errorlevel 1 goto end 并且限定用户只能输入\"a\"、\"b\"、\"c\"这三个选项中的一个当你选择a时，a是第1个选项，所以errorlevel的值为1当你选择b时，b是第2个选项，所以errorlevel的值为2当你选择c时，c是第3个选项，所以errorlevel的值为3 for 命令 主要用于参数在指定的范围内 循环执行命令 skip=n 指在文件开始时忽略的行数m-n 表示一个范围 例子 显示当前目录下所有以 bat 或者 txt 为扩展名的文件名 for %%c in (*.bat *.txt) do (echo %%c) 显示 E 盘 test 目录下所有以 bat 或者 txt 为扩展名的文件名 for /R E:\\test %%b in (*.txt *.bat) do (echo %%b) 显示当前目录下所有包含有 e 或者 i 的目录名 for /D %%a in (*e* *i*) do (echo %%a) 遍历当前目录下所有文件 for /r %%c in (*) do (echo %%c) 产生序列 1 2 3 4 5 for /L %%c in (1,1,5) do (echo %%c) 显示当前的年月日和时间 for /f \"tokens=1-3 delims=-/. \" %%j in ('Date /T') do (echo %%j年%%k月%%l日) for /f \"tokens=1,2 delims=: \" %%j in ('TIME /T') do (echo %%j时%%k分) 读取记事本里的内容 for /f \"delims=\" %%a in (zhidian.txt) do (echo %%a) 把记事本中的内容每一行前面去掉 8 个字符 setlocal enabledelayedexpansion for /f %%i in (zhidian.txt) do ( set atmp=%%i set atmp=!atmp:~8! if {!atmp!}=={} ( echo.) else (echo !atmp!) ) continue、break 命令 例子 for /F [\"options\"] %variable IN (command) DO ( 这里是一些命令 if ... goto continue if ... goto break 这里是一些命令 :continue ::这里打上标签，goto 可以进行跳转，直接进行下一次循环 ) :break ::同理这里打上标签，直接跳出 for 循环 字符串处理 分割字符串 \"%time%\" 显示如：\"11:04:23.03\" (完整的时间\"hh:mm:ss.tt\") :: 注意索引从 1 开始 \"%time:~0,5%\" 显示\"hh:mm\"(即\"11:04\") \"%time:~0,8%\" 显示标准时间格式\"hh:mm:ss\"(即\"11:04:23\"，前8个字符串) \"%time:~3,-3%\"显示\"mm:ss\"(即从第4个开始,截去最后3个的字符串) \"%time:~3%\" 显示\"04:23.03\"(即去掉前3个字符串) \"%time:~-3%\" 显示\".tt\"(即最后3个字符串) 替换字符串 set a=\"abcd1234\" echo %a% ::显示：\"abcd1234\" set a=%a:1=kk% ::替换“1”为“kk” echo %a% ::显示：\"abcdkk234\" 计算字符串长度 写一个 for 循环来计算 set testStr=This is a test string :: 将 testStr 复制到str，str 是个临时字符串 set str=%testStr% :: 标签，用于goto跳转 :next1 :: 判断str是不是空，如果不是则执行下边的语句 if not \"%str%\"==\"\" ( :: 算术运算，使num的值自增1，相当于num++或者++num语句 set /a num+=1 :: 截取字符串，每次截短1 set \"str=%str:~1%\" :: 跳转到next1标签: 这里利用goto和标签，构成循环结构 goto next1 ) :: 当以上循环结构执行完毕时，会执行下边的语句 echo testStr=%testStr% echo testStr的长度为：%num% 字符串合并 没有直接的字符串合并函数 set str1=%str1%%str2% ::(合并 str1 和 str2) 截取字符串时，需要传递参数 setlocal enabledelayedexpansion echo !args:~%num%,-5! ::截取出从第num+1开始到倒数第5个结束的字符串 参考资料 https://www.cnblogs.com/zhaoqingqing/p/4620402.html Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-19 23:52:16 "},"about_Other/Excel操作技巧.html":{"url":"about_Other/Excel操作技巧.html","title":"Excel 操作","keywords":"","body":"参考资料 https://w3schools.cn/excel/index.html 基本知识 Excel 适用领域 数据录入、管理、分析项目管理财务会计 概述 单元格的引用是它的坐标。例如，C4 具 C 列和 4 行两者的交集处字母始终是列，数字始终是行 Shift + F11 创建新的工作表 范围选择使用冒号 : 填充 支持复制、序列、日期、函数填充图标位于单元格的右下角，将鼠标悬停在其上后，鼠标图标会更改为十字单击并按住鼠标左键，拖动并标记要覆盖的范围复制，就是选中一个需要复制的单元格，按照上述操作后进行拖动即可复制序列，则需要fill函数能够理解，例如邻近两个单元格的值分别是1和2，shift选中二者后，再进行上述操作，则可自动填充序列（同样的字母＋数字也是可行的）日期序列，则只要在一个单元格中输入例如：29.07.2021，进行上述填充操作，Excel会自动进行时间的填充函数填充，比如某一列的值等于另外两列之和，在E2中输入公式 \"=B2+C2\"，注意B到E列都需要有列名，双击单元格右下角即可自动根据函数填充 删除单元格 Delete键只会删除单元格中的值，不会删除格式（颜色等） 引用 相对引用示例:A1 绝对引用示例 =$A$1 引用是绝对锁定的示例 =$A1 行仍是相对的示例 =A$1 列仍是相对的 圆括号 () 用于改变操作的顺序使用括号使 Excel 首先计算括号内的数字，然后再计算公式的其余部分使用更高级的公式时，可能需要嵌套括号，我们可以把它看成一个洋葱，它有很多层。Excel会先从内层开始计算 函数 函数名 描述 =IF 根据 TRUE 或 FALSE 条件返回值 =IFS 根据 一个或多个 TRUE 或 FALSE 条件返回值 =AVERAGE 计算平均值（算术平均值） =AVERAGEIF 根据 TRUE 或 FALSE 条件计算范围的平均值 =AVERAGEIFS 根据 一个或多个 TRUE/FALSE 条件计算范围的平均值 =COUNT 对范围内数字的单元格进行 计数 =COUNTA 计算范围内 所有有值的单元格，包括数字和字母 =COUNTBLANK 计算范围内的 空白单元格 =COUNTIF 按指定条件对单元格计数 =COUNTIFS 根据 一个或多个 TRUE 或 FALSE 条件对范围内的单元格进行计数 =MAX 返回范围内的 最大值 =MEDIAN 返回数据的 中间值 =MIN 返回范围内的 最小值 =MODE 查找出现次数最多的数字，返回值是一个数字 =STDEV.P 计算整个 总体 的标准偏差 (Std) =STDEV.S 计算 样本 的标准偏差 (Std) =SUM 将一个范围内的数字 求和 =SUMIF 根据 TRUE 或 FALSE 条件计算范围内值的总和 =SUMIFS 根据 一个或多个 TRUE 或 FALSE 条件计算范围的总和 =VLOOKUP 允许 垂直搜索 表格中的值 =AND 与逻辑运算符，根据两个或多个条件返回 TRUE 或 FALSE =OR 或逻辑运算符，根据两个或多个条件返回 TRUE 或 FALSE =XOR 异或逻辑运算符，根据两个或多个条件返回 TRUE 或 FALSE VLOOKUP 函数允许跨列搜索=VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])函数的不同部分由符号分隔，可以使用逗号或者分号 参数 lookup_value: 需要搜索的值对应的单元格 table_array: 表格范围，即表格的所有单元格 col_index_num: 需要查找的数据列的编号，从左数起 [range_lookup]: 如果是数字，则为 TRUE 或 (1)；如果是文本，则为 FALSE 或 (0) 注意保存用于查找的数据列必须始终在 左侧 数据分析操作 排序 不建议单独对某列进行排序，因为这会破坏总的统计数据之间的关系（只有这列排序了，但是其他列不动） 筛选 其它实用操作 一键求和 Alt + = 可以一键对选中的单元格进行求和 一键插入条形图 Alt + F1 可以一键插入选中单元格的条形图 单元格换行 Alt + Enter 一个单元格中的内容太长或需要换行时使用 快速移动数据 Alt + 左键 可以快速移动选中的单元格 快速生成下拉菜单 Alt + ↓ 带单位数求和 eg. 556箱，600箱……Q=556+600→ Ctrl + E(填充)→Ctrl + H(替换)，Q→ (替换为空)，全部替换Ctrl + E 可以填充序列，Ctrl + H 可以替换 小写金额转大写 选中单元格，右键点击【设置单元格格式】-【特殊】-【中文大写数字】，确定 快速输入√× 设置字体“wingdings 2”，开启大写P→√,O→×,R→□√,S→☒ 批量添加下划线 选中单元格→设置单元格格式→自定义→@*_ →确定 文字随单元格大小变化 选中单元格，右键点击【设置单元格格式】-【对齐】-【缩小字体填充】，确定 图片随单元格大小变化 右击图片，【大小和属性】-属性栏中选择【随单元格改变位置和大小】 快速提取数据 先手动提取一行→Ctrl + ECtrl + E 在 Excel 中通常用于刷新数据 快速拆分数据 先手动拆分一行→Ctrl + E 快速合并数据 先手动合并一行→Ctrl + E 不同长短的姓名对齐 选中单元格，右键点击【设置单元格格式】-【对齐】-【水平对齐】-【分散对齐】，确定 单元格横向变纵向 选中单元格，右键点击【复制】，选中需要粘贴的地方右键点击【转置】 快速删除单元格中的空行 F5 键【定位条件】，选择空值，点击确定右键点击【删除】 快速修改照片底色背景 选中图片来到【图片格式】，点击【删除背景】，用画笔【标记要保留的区域】-【保留修改】，之后点击油漆桶进行颜色的填充 给姓名或文字添加拼音 选中单元格→复制→（Wold文档）粘贴→全选→拼音→确定→复制→（Excel单元格）粘贴 制作下拉列表 选中单元格，菜单栏中的【数据】-【数据验证】-【设置】-【允许】选择序列，【来源】中填入 “选项A,选项B,……”，点击确定 横向快速找不同 选中单元格，Ctrl + \\ 制作合同到期提醒 表选中单元格→输入“=D2-TODAY()”,Ctrl + Enter(回车键)→数字→分类，常规→确定→条件格式，任选一个数据条 快速输入当前日期和时间 日期：Ctrl + ;时间：Ctrl +Shift + ; 制作斜线表头 选中单元格，Ctrl + 1-【字体】-设置好【上、下标及文字大小】【边框】-【斜线】 定制专属二维码 在选项中找到【自定义功能区】，打开【开发工具】，在插入中选择 【BarCode Control】，设置样式即可得到 QR 二维码 自动添加边框 选中单元格，在开始栏中找到【样式】-【条件格式】-【新建规则】【使用公式……的单元格】-【格式】-【添加外边框】 冻结窗格查看 选中单元格，【视图】-【冻结...】 快速单元格的整理美化 选中单元格，Ctrl + T 可以将选中的数据范围转化为表格 设置单元格格式 双引号：需要添加的内容数字占位符：#\"米\"（通常使用#来代表原格式中的数字）零占位符：\"S\"000（数字用0补足三位数，并在最前面添加字母S）空格占位符：??.???（整数两位，小数三位，位数不够以空格补齐）文本占位符：@！（@表示原有的文本内容，在文本后面加上感叹号）千位符：#.##0（使用逗号，并配合#和0，从个位起每3个数字之间有一个逗号） Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:39:38 "},"about_Other/JS基础.html":{"url":"about_Other/JS基础.html","title":"JS 基础","keywords":"","body":"基础知识 为什么学习 JavaScript? HTML 定义了网页的内容CSS 描述了网页的布局JavaScript 控制了网页的行为JS 可以配合 HTML 和 CSS 一起工作 简介 是脚本语言轻量级的编程语言可插入 HTML 页面 用法 Javascript 脚本代码可被放置在 HTML 页面的 和 部分中，要求位于 与 标签之间但是若要外部引用脚本，则将 放在 内即可 输出 JavaScript 没有任何打印或者输出的函数，数据只能通过以下方式显示：1、使用 window.alert() 弹出警告框2、使用 document.write() 方法将内容写到 HTML 文档中3、使用 innerHTML 写入到 HTML 元素4、使用 console.log() 写入到浏览器的控制台 语法 字面量 即固定值 变量 用于存储数据值，用关键字 var 来声明变量 可以在声明的同时赋值，也可以之后再赋值 操作符 例如 = + - * / == != 等 语句 用于向浏览器发出命令，语句用分号分隔（不过用分号来结束语句是可选的） 关键字 JavaScript 有一些保留的关键字，例如 if else float try 等等 注释 单行注释 //，多行注释 /**/ 数据类型 数字，表达式，字符串，数组，对象（类似于 Python 字典）等等 字符串可以使用 单引号或双引号 函数 字母大小写 JavaScript 对大小写敏感 字符集 JavaScript 使用 Unicode 字符集 数据类型 值类型(基本类型)字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol（表示独一无二的值） 引用数据类型（对象类型）对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date） JavaScript 同 Python 一样拥有动态类型 var x; // x 为 undefined var x = 5; // 现在 x 为数字 var x = \"John\"; // 现在 x 为字符串 查看数据类型 var x = \"John\"; typeof x // 返回 string JavaScript 数组 创建名为 cars 的数组 var cars = new Array(); cars[0] = \"Saab\"; //注意下标从 0 开始 cars[1] = \"Volvo\"; cars[2] = \"BMW\"; 或者 (condensed array) var cars = new Array(\"Saab\",\"Volvo\",\"BMW\"); 或者 (literal array) var cars = [\"Saab\",\"Volvo\",\"BMW\"]; Undefined 表示变量不含有值可以通过将变量的值设置为 null 来清空变量当声明新变量时，可以使用关键词 new JavaScript 对象 是拥有属性和方法的数据 ``` js var person = { firstName:\"John\", lastName:\"Doe\", age:50, eyeColor:\"blue\" }; // 访问对象属性 // 实例 1 person.lastName; // 实例 2 person[\"lastName\"]; ``` 函数 函数就是包裹在花括号中的代码块使用关键词 function 且必须是 小写 function myfunction(var1, var2) { // 代码 } // 调用 myfunction(arg1, arg2) 局部 JavaScript 变量在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它只要函数运行完毕，局部变量就会被删除 全局 JavaScript 变量在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它 如果给尚未声明的变量值赋，该变量将被自动作为 window 的一个属性可以通过 window.属性名 访问非严格模式下给未声明变量赋值创建的全局变量是可以删除的？？？ 作用域 作用域是可访问变量的集合在 JavaScript 中, 对象和函数同样也是变量 变量生命周期 在它声明时初始化 局部变量在函数执行完毕后销毁 全局变量在页面关闭后销毁 优先度 局部变量 > 全局变量 > window变量 事件 HTML 事件是发生在 HTML 元素上的事情当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件 常见的 HTML 事件 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 鼠标指针移动到指定的元素上时发生 onmouseout 用户从一个 HTML 元素上移开鼠标时发生 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 字符串 使用内置属性 length 来计算字符串的长度 var txt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; var sln = txt.length; 字符串可以是对象 var x = \"John\" typeof x //返回 String 类型 // 使用 new 关键字将字符串定义为一个对象 var y = new String(\"John\") typeof y //返回 Object 类型 注意最好不要创建 String 对象，它会拖慢执行速度，并可能产生其他副作用 === 为绝对相等，即数据类型与值都必须相等 字符串有相应的属性和方法常见的有获取长度、返回指定位置的字符、连接字符、正则表达式匹配、切片、大小写转换、去除空白字符等等 运算符 和 C 语言类似包括算术运算符、赋值运算符、比较运算符、逻辑运算符、条件运算符注意：如果把数字与字符串相加，结果将成为字符串 条件运算符 variablename = (condition)?value1:value2 若满足括号里面的条件condition，则将value1赋值给变量，反之，用value2赋值 条件语句 if (条件1) { 当条件 1 为 true 时执行的代码 } else if (条件2) { 当条件 2 为 true 时执行的代码 } else { 当条件 1 和 条件 2 都不为 true 时执行的代码 } switch 语句 function myFunction() { var x; var d = new Date().getDay(); //获取今天的日期 switch (d) { case 6:x=\"今天是星期六\"; break; case 0:x=\"今天是星期日\"; break; default: x=\"期待周末\"; //如果匹配不到，则输出default的值 } document.getElementById(\"demo\").innerHTML=x; } for 语句 for (var i=0; i\"; } var person = {fname:\"Bill\",lname:\"Gates\",age:56}; for (x in person) // x 为属性名 { txt = txt + person[x]; } while 语句 while (条件) { 满足条件则执行的代码 } do { 需要执行的代码 } while (条件); //也是一样，满足条件才继续循环 break、continue 语句 类似 C 语言特殊用法：有了 标签，可以使用 break 和 continue 在多层循环的时候控制外层循环 outerloop: for (var i = 0; i 3) { break; } if (i == 2) { break innerloop; } if (i == 4) { break outerloop; } document.write(\"i=\" + i + \" j=\" + j + \"\"); } } // 方便控制跳出内层/外层循环 数据类型 在 JavaScript 中，数组是一种特殊的对象类型。 因此 typeof [1,2,3,4] 返回 object在 JavaScript 中 null 表示 \"什么都没有\"，是只有一个值的特殊类型。表示一个空对象引用在 JavaScript 中，undefined 是一个没有设置值的变量 var x = null; typeof x; //输出 object var y; typeof y; //输出 undefined null === undefined //输出 false，值相同，类型不同 null == undefined //输出 true null 和 undefined 的值相等，但类型不等可以设置为 null 或者 undefined 来清空对象数据类型之间可以进行转换 正则表达式 var patt = /hello/i 其中 /hello/i 是一个正则表达式hello 是一个正则表达式主体 (用于检索)i 是一个修饰符 (搜索不区分大小写) 修饰符 描述 i 对大小写不敏感 g 全局匹配（查找所有匹配而非在找到第一个匹配后停止），贪心？？？ m 多行匹配 var str = \"Hello World!\"; var n = str.search(/hello/i); //输出结果为 0 var txt = str.replace(/world/i, \"你好\"); //进行字符替换 此外还有test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 falseexec() 方法用于检索字符串中的正则表达式的匹配 错误 try { ... //异常的抛出 } catch(e) { ... //异常的捕获与处理 } finally { ... //结束处理，不管是否出现异常都要执行 } this 在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变 在方法中，this 表示该方法所属的对象 如果单独使用，this 表示全局对象 在函数中，this 表示全局对象 在函数中，在严格模式下，this 是未定义的(undefined) 在事件中，this 表示接收事件的元素 var person1 = { fullName: function() { return this.firstName + \" \" + this.lastName; } //不需要设置参数 } var person2 = { firstName:\"John\", lastName: \"Doe\", } person1.fullName.call(person2); // 返回 \"John Doe\" let、const 变量作用域 全局的：在函数外声明的变量 局部的：在函数内声明的变量 let 在 {} 内声明的变量只在其内有效，在 {} 之外不能访问let 无法实现变量提升const 用于声明一个或多个常量，声明时 必须进行初始化使用 const 定义的对象或者数组，可以对其内部的元素进行 修改 JSON JavaScript Object Notation，是用于存储和传输数据的格式，通常用于 服务端向网页传递数据 JSON 语法规则 数据为 键/值 对 数据由逗号分隔 大括号保存对象 方括号保存数组 var text = '{ \"sites\" : [' + '{ \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" },' + '{ \"name\":\"Google\" , \"url\":\"www.google.com\" },' + '{ \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" } ]}'; obj = JSON.parse(text); document.getElementById(\"demo\").innerHTML = obj.sites[1].name + \" \" + obj.sites[1].url; JSON.parse()，用于将一个 JSON 字符串转换为 JavaScript 对象JSON.stringify()，用于将 JavaScript 值转换为 JSON 字符串 void void 关键字，不返回任何值，但是括号内的表达式还是要运行 如 void(alert(\"Warnning!\")) href=\"#\" 与 href=\"javascript:void(0)\" 的区别 # 包含了一个位置信息，默认的锚是 #top 也就是网页的上端 而 javascript:void(0)，仅仅表示一个 死链接 在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id 如果要定义一个死链接，用 javascript:void(0) 异步编程 异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念在我们学习的传统单线程编程中，程序的运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而一个异步过程的执行将不再与原有的序列有顺序关系简单来理解就是：同步按你的代码顺序执行，异步 不按照代码顺序执行，异步的执行 效率更高异步就是从主线程发射一个子线程来完成任务适用于：遇到死循环的时候，防止失去响应，或者读取什么较大的内容或者发送一个请求等等 setTimeout(function () { document.getElementById(\"demo\").innerHTML=\"RUNOOB!\"; }, 3000); es6 知识 用于声明变量的关键字 let 只在所在代码块内有效var 全局范围内有效const 用于声明只读的常量，之后不能修改 for 循环内部很适合用 let 关键字每轮循环，声明的变量都是新的js 引擎内部会记住前一个循环的值 let 声明的变量不能提升var 的则可以，变量在声明之前已经存在 const 声明的时候需要初始化赋值 注意在代码块内，若出现 let 和 const 关键字，会使得所声明的变量在块内是封闭的就算在块外定义过也没用 const 怎么做到使得定义的变量不允许改变？其实是使变量对应的内存地址所保存的数据不允许改变 注意简单类型和复杂类型变量保存值的方式是不同的简单类型的，例如数值、字符串、布尔值等，变量指向的内存地址就是值复杂类型的，例如对象、数组、函数等，变量指向的内存地址是一个指针，这个指针指向的才是真正的值所以，需要注意的是，用const定义复杂类型的变量时，只能保证指针是不变的 解构赋值 数组解构 let [a, b, c] = [1, 2, 3] let [a, [[b], c]] = [1, [[2], 3]]; let [a, , b] = [1, 2, 3]; //a=1, b=3 let [a, ...b] = [1, 2, 3]; //a=1, b=[2,3] let [a, b, c, d, e] = 'hello'; //分别等于对应的字符 // 结构的目标 = 解构的源 // 相当于 Python 的解包 对象解构 let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; let {a = 10, b = 5} = {a: 3}; //a = 3; b = 5; Symbol 关键字 表示独一无二的值 用来作为对象的属性名，保证属性不重名 let sy = Symbol(\"key1\"); let syObject = {}; syObject[sy] = \"hello\"; //注意Symbol作为属性名需要用方括号，不用点号 console.log(syObject); //{Symbol(key1): \"hello\"} 注意Symbol 值作为属性名时，是公有属性，在类的外部可以访问但是不会出现在 for 循环遍历中要读取一个对象的Symbol属性，使用 Object.getOwnPropertySymbols(对象); Map Object Map 键值：字符串/Symbols 键值：任意值 键无序 键有序，先进先出原则 手动计算键值对数 size属性求键值对数 键名可能冲突 不会冲突 var myMap = new Map(); myMap.set(键1, 值1); myMap.set(键2, 值2); // 通过键获取值 值1 = myMap.get(键1); 值2 = myMap.get(键2); // 循环遍历 // .entries() 确保按照键值对的插入顺序进行遍历 for (var [key, value] of myMap.entries()) { console.log(key + \"=\" + value); } myMap.forEach( function(k, v) { console.log(k + \"=\" + v); }, myMap ) myMap.keys() myMap.values() 注意虽然 NaN !== NaN 是 true，但是 NaN 作为 Map 的键却是没有区别的 二维数组可以转为 Map 对象 var myMap = new Map([[键1,值1], [键2,值2]]); // 逆变换 var myArray = Array.from(myMap); 克隆 Map，直接 新Map = new Map(旧Map); 这样会产生新的对象 合并 Map var Map1 = new Map([。。。省略]); var Map2 = new Map([。。。省略]); var merged_map = new Map([...Map1, ...Map2]); // 注意 ... 操作符 // 有相同键的情况下，后出现的值会覆盖过去 Set Set 存储的值是唯一的，可以存储任何类型的值（原始值/对象引用）用于去重、求并集、交集、差集 let mySet = new Set(); mySet.add(1); mySet.add(2); mySet.add(\"hello\"); mySet.add({a:1, b:2}); mySet.has(1); //true 二维数组可以转为 Set 对象 var mySet = new Set([[1, \"hello\", 3]]); // 逆变换 var myArray = [...mySet]; // 注意 ... 操作符 Proxy 对目标对象进行拦截，然后进行某些处理不直接操作对象Proxy对象包括：target、handler let target = { name: 'Tom', age: 24 } let handler = { get: function(target, key, receiver) { console.log('getting '+key); return target[key]; // 不是target.key }, set: function(target, key, value, receiver) { console.log('setting '+key); target[key] = value; } } let proxy = new Proxy(target, handler) proxy.name // 实际执行 handler.get proxy.age = 25 // 实际执行 handler.set // 有点像Python的class中的init方法和类中定义的方法 函数 当存在某些参数赋予了默认值的时候，不允许使用同名参数 赋予参数null值是有效的 不定参数 function (...values){ 。。。 } // 不确定参数个数的时候可以使用 ... // 例如不知道传入的列表中有多少元素 箭头函数 // 参数 => 函数体 var f = (a,b) => a+b; // 等同于 var f = function(a,b){ return a+b; } 维护 this 的上下文 // 回调函数 var Person = { 'age': 18, 'sayHello': function () { setTimeout(function () { console.log(this.age); }); } }; var age = 20; Person.sayHello(); // 20 var Person1 = { 'age': 18, 'sayHello': function () { setTimeout(()=>{ console.log(this.age); }); } }; var age = 20; Person1.sayHello(); // 18 对比： var Person = { 'age': 18, 'sayHello': ()=>{ console.log(this.age); } }; var age = 20; Person.sayHello(); // 20 // 此时 this 指向的是全局对象 var Person1 = { 'age': 18, 'sayHello': function () { console.log(this.age); } }; var age = 20; Person1.sayHello(); // 18 // 此时的 this 指向 Person1 对象 箭头函数里面没有 this 对象，this 是外层的 this 对象 class 实现更像面向对象的写法 本质是function class example{ // constructor（构造函数）相当于init函数 constructor(a){ this.a = a; // 默认范围实例对象this，也可以自己指定 } // 静态方法 static sum(a, b) { console.log(a+b); } // 原型方法 minus(a,b){ console.log(a-b); } } // class也可以是匿名的 注意类不会提升，访问前就要定义好类中的方法不需要function关键字方法之间不需要分号 instanceof 查看两个对象的类型是否相同 // 类的实例化，必须new关键字 new myc1 = example(); new myc2 = example(); // 注意 myc1 和 myc2 是共享原型方法的 // 获取实例的原型对象 Object.getPrototypeOf(myc1) 封装 class Example1{ constructor(a, b) { this.a = a; this.b = b; } get a(){ console.log('getter'); return this._a; } set a(a){ console.log('setter'); this._a = a; } } let exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法 console.log(exam1._a); // 1, 可以直接访问 继承，extends关键字 class Father { test(){ return 0; } static test1(){ return 1; } } class Child extends Father { constructor(){ super(); //只能在子类的constructor函数中 } } class Child1 extends Father { constructor(){ super(); // 调用父类普通方法 console.log(super.test()); // 0 } static test3(){ // 调用父类静态方法 return super.test1+2; } } Child1.test3(); // 3 模块 %accordion% 每一个模块内声明的变量都是局部变量 %accordion% /*-----export [test.js]-----*/ let myName = \"Tom\"; let myAge = 20; let myfn = function(){ return \"My name is\" + myName + \"! I'm '\" + myAge + \"years old.\" } let myClass = class myClass { static a = \"yeah!\"; } export { myName as name1, myAge, myfn, myClass } // 使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口 /*-----import [xxx.js]-----*/ import { name1, myAge, myfn, myClass } from \"./test.js\"; //不管出现几次，只会执行一次 console.log(myfn());// My name is Tom! I'm 20 years old. console.log(myAge);// 20 console.log(myName);// Tom console.log(myClass.a );// yeah! %/accordion% 高级编程 PromiseGeneratorasync 参考资料 https://www.runoob.com/js/js-tutorial.html Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 11:09:57 "},"about_Other/LaTex整理.html":{"url":"about_Other/LaTex整理.html","title":"LaTex 整理","keywords":"","body":"几个概念 Tex：一种具有编译和排版功能的基础语言，类似于 C 语言LaTeX：是 Tex 的扩展，有许多宏包，功能更加丰富TexLive：Tex 语言的编辑器，操作没那么便利Texstudio：相当于 TexLive 套上一个外壳，不过编辑起来更加方便 主要公式 主要内容 \\begin{document} \\end{document} 摘要 \\begin{abstract} \\end{abstract} \\section{这里写标题} \\subsection{这里写小标题} 注意这个会自动对标题进行标号 绘制三线表，即只有三条线的表格 \\begin{table}[!htbp] \\setlength{\\tabcolsep}{3mm} \\begin{tabular}{ccccc} \\toprule[1.5pt] 符号 & 含义 \\\\ \\midrule[1pt] $S_{i}$ & i=1，2，3分别为当日可分配的医用品，消耗品，日用品的总量 \\\\ $[x_{i1},x_{i2},x_{i3}]$ & 三者分别代表第i个灾区，每人每日实际收到的医用品，消耗品，日用品的数量 \\\\ $c_{i}$ & 从所有灾区中划分的第i个灾区 \\\\ $R$ & 模糊相似矩阵 \\\\ $c_{ij}$ & 第i个灾区中第j个受灾指标 \\\\ $a$ & 灾区每人每日医用品平均使用量 \\\\ $b$ & 灾区每人每日消耗品品平均使用量 \\\\ $c$ & 灾区每人每日日用品平均使用量 \\\\ \\bottomrule[1.5pt] \\end{tabular} \\end{table} 公式 \\begin{equation} \\alpha_{i}=\\frac{P_{ih}+P_{iw}\\times2}{P_{i}},i=(B_{1},B_{2},B_{3}\\cdots,B_{10}) \\label{1} \\end{equation} \\cref{1}，表示对 label 为 1 的公式进行引用 图片 \\begin{figure}[!h] \\centering \\includegraphics[width=1.1\\textwidth]{图1} \\caption{模糊相似矩阵} \\end{figure} matlab 代码块 \\begin{lstlisting}[language=matlab] \\end{lstlisting} 关键字 \\keywords{}空格 \\quad换行 \\par 向量求导法则 参考资料：https://zhuanlan.zhihu.com/p/273729929假设向量 x 为：\\vec{x} = [x_{1}, x_{2}...x_{n}]^{T}矩阵 $A_{n \\times n}$ 为常数矩阵 1、常数求导\\frac{\\partial c}{\\partial x} = 0 2、公式\\frac{\\partial x^{T}a}{\\partial x} = \\frac{\\partial a^{T}x}{\\partial x} = a\\frac{\\partial x^{T}x}{\\partial x} = 2x\\frac{\\partial x^{T}Ax}{\\partial x} = Ax+A^{T}x\\frac{\\partial a^{T}xx^{T}b}{\\partial x} = \\frac{\\partial x^{T}ab^{T}x}{\\partial x} = ab^{T}x + ba^{T}x 矩阵求导法则\\frac{\\partial a^{T}Xb}{\\partial x} = ab^{T}\\frac{\\partial a^{T}X^{T}b}{\\partial x} = \\frac{\\partial b^{T}Xa}{\\partial x} = ba^{T}\\frac{\\partial a^{T}XX^{T}b}{\\partial X} = \\frac{\\partial X^{T}ab^{T}X}{\\partial X} = ab^{T}X + ba^{T}X \\begin{aligned}\r \\frac{\\partial a^{T}X^{T}Xb}{\\partial X} = \\, & \\frac{\\partial a^{T}(X^{T})(X^{T})^{T}b}{\\partial (X^{T})^{T}} \\\\\r = \\, & (\\frac{\\partial a^{T}(X^{T})(X^{T})^{T}b}{\\partial X^{T}})^{T} \\\\\r = \\, & (ab^{T}X^{T}+ba^{T}X^{T})^{T} \\\\\r = \\, & Xba^{T}+Xab^{T} \\\\\r \\end{aligned} 可以注意一下上面等式的写法 推荐网站 环境搭建在线编辑在线编辑配合Markdown Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:36:43 "},"about_Other/Matlab整理.html":{"url":"about_Other/Matlab整理.html","title":"Matlab 整理","keywords":"","body":"常用内容 数值数据类型 浮点型 single 单精度 double 复数型 real 实部 imag 虚部 数据的输出格式 format 命令 format + long 可以提高精度，但不影响存储 常用数学函数 exp() 求 e 的几次幂 sin(角度，如 pi/2)、sind(弧度，如 45) 三角函数 abs() 求绝对值、复数的模、ASCII码值 取整函数 round 四舍五入 ceil 向上取整 floor 向下取整 fix 去掉小数部分 isprime() + find() 找素数 rem(A，2) 表示对矩阵A除2后取余 find() 函数返回的是符合条件的元素下标 eval() 即执行括号里的命令 变量的管理 who 查看变量 whos 详细的信息 save mydata a x 创建内存变量文件 load mydata 装入内存变量文件 矩阵 矩阵的建立 同一行用逗号或者空格分开，不同行用分号分开 小矩阵可以拼接成大矩阵 实部矩阵和虚部矩阵可以构成复数矩阵 冒号表达式 a = 0:1:5 则 a = 0 1 2 3 4 5 结构矩阵 a(1).x1 = 10; a(1).x2 = 'liu'; a(1).x3 = [11,21; 34,78]; 即矩阵 A 的其中一个分量 a(1) 的三个元素分别定义，同理 a(1).x1 = 12; a(1).x2 = 'wang'; a(1).x3 = [34,191; 27,578]; 单元矩阵 与一般矩阵类似，只是矩阵元素由大括号括起来 矩阵元素的引用 如 A(3, 2) 表示 A 矩阵第三行第二列的元素 A = [1,2,3; 4,5,6]; 则 A(3) = 2 冒号表达式获得子矩阵 end 运算符表示某一维的末尾元素下标 A([1,4], 3:end) 表示取矩阵 A 的第一和四行，第三列到最后一列的所有元素 中括号可用于删除矩阵的元素 如 A([:, [2,4]]) = [] 表示删去矩阵 A 所有行中的第二和四列，构成一个新矩阵 常见矩阵 zeros() 全零矩阵 ones() 全一矩阵 eye() 对角线为 1 的矩阵 rand() 生成 (0，1) 区间均匀分布的随机矩阵 randn() 生成标准正态分布随机矩阵服从 N(0,1) magic() 魔方矩阵，数独乌龟矩阵 vander() 范德蒙德矩阵 hilb() 希尔伯特矩阵 compan() 伴随矩阵 pascal() 帕斯卡矩阵 矩阵变换 reshape(A, m, n) 可改变矩阵 A 的形状 A(:) 表示把矩阵 A 的每一列元素堆叠起来成为一个列向量 diag(A) 提取矩阵 A 的对角线元素，生成列向量 diag(V) 由列向量 V 生成对角矩阵 triu(A) 提取矩阵 A 的主对角线及以上元素 tril(A) 提取矩阵 A 的主对角线及以下元素 .' 转置 ' 共轭转置，即转置后取各元素的复共轭 rot90(A, k) 将矩阵 A 按逆时针方向旋转 90° 的 k 倍 fliplr(A) 对矩阵 A 实施左右翻转 flipud(A) 对矩阵 A 实施上下翻转 inv(A) 求方阵 A 的逆 矩阵求值 det(A) 求方阵 A 的行列式值 rank(A) 求矩阵 A 的秩 trace(A) 求矩阵 A 的迹，即主对角线的元素和 norm(V, 2) 计算向量 V 的 2-范数，对于矩阵也类似 norm(V, 1) 计算向量 V 的 1-范数，对于矩阵也类似 norm(V, inf) 计算向量 V 的 ∞-范数，对于矩阵也类似 cond(A, 2) 计算矩阵 A 在 2-范数下的条件数 cond(A, 1) 计算矩阵 A 在 1-范数下的条件数 cond(A, inf) 计算矩阵 A 在 ∞-范数下的条件数 矩阵的特征值和特征向量 eig(A) 可以求矩阵 A 的全部特征值和对应的特征向量 稀疏矩阵 A = sparse(S) 将矩阵 S 转化为稀疏存储方式的矩阵 A S = full(A) 将矩阵 A 转化为完全存储方式的矩阵 S 运算符 基本算术运算 加减运算 乘法运算 除法运算 乘方运算 点运算：(各自下标的元素进行运算) .* ./ .\\ .^ 例如：x = 0.1:0.3:1; y = sin(x).*cos(x); 表示分别求出 x 为 0.1、0.4、0.7、1 下的 y 值 关系运算 、>、、>=、==、~= 逻辑运算 & 与、| 或、~ 非 字符串 字符串表示 a = 'hello' 也可以构成字符串矩阵 字符串比较是引号内各字符的比较，返回 0 或 1 strcmp(s1, s2) 比较字符串 s1 和 s2 是否相等 strncmp(s1, s2, n) 比较字符串 s1 和 s2 的前 n 个字符是否相等 strcmpi(s1, s2) 忽略大小写，比较字符串 s1 和 s2 是否相等 strncmpi(s1, s2, n) 同理 findstr(s1, s2) 返回 s2 在 s1 中的开始位置 strrep(s1, s2, s3) 将字符串 s1 中的所有 s2 都替换成 s3 结构语句 顺序结构程序 input() 数据的输入 disp() 数据的输出 pause(填秒数) 程序的暂停 if 语句 if。。。end if。。。else。。。end if。。。elseif。。。elseif。。。end switch 语句 switch。。。case。。。case。。。otherwise。。。end for 语句 for。。。end 可以配合 continue 或者 break while 语句 while。。。end 函数 函数文件的定义与调用 定义 function [输出形参表] = 函数名(输入形参表) 注释说明部分 函数体语句 调用 [输出实参表] = 函数名(输入实参表) 可以递归调用 匿名函数 f = @(x,y)x^2+y^2 则 f(3, 4) = 25 g = @sin 则 g(pi/2) = 1 函数的参数与变量 nargin 输入实参的个数 nargout 输出实参的个数 局部变量，只在特定过程或函数中才可以访问 全局变量，全程有效 global a 绘图 二维曲线 linspace(a, b, n) 函数 在区间 [a, b] 生成 n 个数，即把区间 [a, b] 进行 n-1 等分 plot(x, y) 函数 按照坐标 x,y 画图 当 x 是复数向量时 cx = x+y*i 或者 cx = complex(x,y); plot(cx) x, y 是同型矩阵的时候也可以画图，曲线条数即矩阵的 列数 颜色：'r', 'g', 'b', 'w', 'k'... 线型：'-', ':', '-.', '--'... 数据点标记：'*', 'o', 's', 'p', '^'... 不同线型或者颜色可以在同一个坐标内绘制，plot(x1,y1,'r-', x2,y2,'g:', x3,y3,'kp') fplot() 函数 例如 fplot(@(x) sin(1./x), [0,0.2], 'b') 画的是区间 0~0.2 上 sin(1/x) 的图像 绘图的辅助 title(' ') 添加标题，可以使用 LaTex 格式控制符，可以改颜色改字体 xlabel(' ') 添加 x 轴说明 ylabel(' ') 添加 y 轴说明 text(x, y, 说明) 在图像周围的某个坐标位置添加注释 gtext(说明) 有个十字准星来确定说明放置的位置 legend('', '') 添加图例 axis([]) 坐标范围的控制 axis equal 横纵坐标采用等长刻度 axis square 产生正方形坐标系 axis auto 使用默认设置 axis on/off 显示/取消坐标轴 grid on/off 添加/取消网格线box on/off 添加/取消边框hold on/off 图形保持/不保持subplot(m, n, p) 窗口分割，m*n 个绘图区，p 是当前的活动区 其他形式的二维图形 对数坐标图 semilogx(x, y) semilogx(x, y) loglog(x, y) 极坐标图 polar(θ, ρ) 统计图 条形图 bar(x, y, style)，x,y 是坐标，style 包括 group、stack barh() 直方图 hist() rose() 玫瑰图 扇形图 pie() 面积图 area() 散点图 scatter() stairs() 阶梯图 stem() 杆图 矢量图 compass() 罗盘图 feather() 羽毛图 quiver() 箭头图 三维曲线 plot3(x, y, z) 类似二维的 fplot3() 画参数方程的图，输入各坐标定义的函数 三维曲面 生成平面网格数据 利用矩阵运算 利用 meshgrid 函数：[X, Y] = meshgrid(x, y)，X、Y 为矩阵用来存储网格点坐标，参数 x、y 为向量 绘制三维曲面 mesh(x, y, z, c) c 用来指定颜色 meshc 带等高线 meshz 带底座 fmesh() surf(x, y, z, c) surfc 带等高线 surfl 带光照效果 fsurf() 标准三维曲面 [x, y, z] = sphere(n) [x, y, z] = cylinder(R, n) peaks() contour() 等高线 图形修饰处理 视点处理 view(az, el)，az 为方位角，el 为仰角 色彩处理 cmap = colormap() 三维图表面的着色处理：shading faceted、shading flat、shading interp 图形的裁剪，可以将需要裁剪的部分数值设置为 NaN 描述统计 数据统计分析 max() 求向量或矩阵最大元素，包含复数也可以，还可以取得元素的序号 min() 求向量或矩阵最小元素 mean() 求算术平均值 median() 求中值 sum() 求和 prod() 求积 cumsum() 累加和 cumprod() 累计积 std() 计算标准差 corrcoef() 计算相关系数，可以返回一个矩阵的相关系数矩阵，也可以计算两个向量之间的相关系数 sort() 排序函数，默认升序 ascend 多项式 多项式计算 表示形式：如 n 次多项式 p(x) 用稀疏向量 [an,an-1,...,a1,a0] 表示 注意：对应次数的系数由高到低排列，若有系数为 0，则用 0 补上 conv(P1, P2) 两个多项式相乘，其中 P1、P2 分别是两个多项式的系数向量[Q, r] = deconv(P1, P2) 两个多项式相除，其中 P1、P2 分别是两个多项式的系数向量，返回的 Q 是商，r 是余数；由上有 P1 = conv(Q, P2) + rpolyder() 多项式求导polyval(p, x) 多项式求值，x 带入多项式中求值polyvalm(p, x) 同理，不过要求 x 为方阵roots(p) 多项式求根，p 为多项式的系数矩阵 拟合 数据插值 一次插值 x = [。。。]; y = [。。。]; x1 = 0: ? : ?; y1 = interp1(x,y,x1,'method'); plot(x1, y1) 其中 method 的取值： linear 线性插值 nearest 最近点插值 pchip 分段三次 Hermite 插值 spline 三次样条插值 二次插值函数 interp2() 曲线拟合 x = [。。。]; y = [。。。]; plot(x,y,'*'); p = polyfit(x,y,?); polyval(p,?) %预测 plot(x,y,'*', x,polyval(p,x)); 以上插值和拟合都属于函数逼近的方法，可以进行数据估算 不同的是实现方法，结果形式不同，侧重点，应用场合 微积分、优化 数值微分 diff() 计算向前差分 数值积分 [l, n] = quad(被积函数名，定积分上下限，积分精度，是否展现积分过程) 基于自适应辛普森方法 [l, n] = quadl() 基于自适应 Guass-Lobatto 方法 l = intergral(被积函数名，定积分上下限) 基于全局自适应积分方法 [l, err] = quadgk(被积函数名，定积分上下限) 基于自适应高斯-克朗罗德方法 l = trapz(x, y) 基于梯形积分法 还有求多重定积分的方法。。。 非线性方程求解 fzero() 求单变量非线性方程的根 fsolve() 非线性方程数值求解 函数极值的计算 无约束最优化问题 fminbnd fminsearch fminunc 有约束最优化问题 fmincon 常微分方程数值求解 solver() ode..() 其他 符号对象 syms 形式如 syms a b c d diff(f, x) 符号函数的导数 int(f, x) 符号函数的积分 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:36:21 "},"about_Other/Docker基础.html":{"url":"about_Other/Docker基础.html","title":"Docker基础","keywords":"","body":"基本知识 Docker 是一种容器化技术，可以 将应用程序及其依赖项打包成一个独立的容器，是一个开源的软件部署解决方案Docker 本身是跨平台的，可以在 Linux、Windows 和 macOS 等操作系统上运行但是，使用 Docker 部署的项目需要基于 Linux 系统。这是因为 Docker 容器是 基于 Linux 内核的虚拟化技术，它利用了 Linux的命名空间和控制组 等特性来实现隔离和资源管理因此，如果使用 Docker 来打包和部署项目只能在 Linux 系统上运行 镜像、容器、仓库 仓库中集中存放各种镜像文件 有镜像才能创建对应的容器 需要在容器中运行代码 Docker 简化了运维工程师的工作，进行集群部署的时候就不需要一台一台地安装所需的环境Docker 部署只需要创建一个镜像，安装好环境，再复制到集群的各个机器上，快捷并且保证了部署的一致性 使用 Docker 的好处 手动部署项目的时候我们通常会先把代码上传到服务器、然后安装相关依赖、配置环境、最后启动项目。通常这些过程都需要我们手动敲入命令，每次部署的时候都需要重新敲一遍而 docker 做的工作就是将这些 命令记录下来，在部署的时候再逐个执行上述过程与自己写个部署脚本没有什么区别但是 docker 还能够保证每次运行的 环境都是一致的，并且 与宿主机的环境进行隔离 Windows 下载安装 https://docs.docker.com/desktop/install/windows-install/ Dockerfile 怎么写？ docker 会根据 Dockerfile 来构建环境并生成一个 镜像，最后通过运行镜像来完成项目部署 1、FROMFROM 用来指定基础镜像。可以理解为所需要的的操作系统 # 比如下面这行代码就指定了带有 python 环境的镜像 # 我们可以在构建好的镜像中直接使用 python 而不需要额外安装 FROM python:3.6 2、MAINTAINER # 指定了 Dockerfile 的作者，或者说维护者 # 可填可不填 MAINTAINER yourname 3、ENV # 用来设置环境变量 ENV PRODUCTION_ENV 1 4、ADD用来向镜像中添加我们需要的文件，比如配置文件、代码、资源文件等等 ADD ./database.ini /root #路径是 Dockerfile 所在目录的相对路径 ADD ./src /root ADD http://www.baidu.com /root #路径也可以使用 URL ADD code.tar /root #tar 压缩包的话会被自动解压成目录 5、COPYCOPY 的功能和 ADD 相似不过 COPY 不能用 URL 只能复制本地的文件到镜像中，并且不会自动解压 tar 压缩包 6、EXPOSE声明容器中要使用的端口，仅仅做声明，没有实际作用 EXPOSE 80 EXPOSE 80 8080 7、ENTRYPOINT容器启动 时执行的命令，并且不会被 docker run 的参数覆盖如果指定了多个 ENTRYPOINT 只有最后一个会被执行 ENTRYPOINT [\"可执行文件\", \"参数1\", \"参数2\"] ENTRYPOINT 命令 参数1 参数2 8、WORKDIR指定工作目录，后续的所有命令都会在这个目录下面执行 9、RUNRUN 表示要执行的命令 WORKDIR /root/project RUN pip isntall -r requirements.txt #安装依赖 10、VOLUME声明容器中的挂载点，在运行的时候通过 -v 绑定到宿主机目录，注意需要提供完整的目录路径 实践 先来创建一个项目，目录结构如下 httpServer/ │ log/ │ http.py └─ Dockerfile 编写 Dockerfile # 指定带有 python 3.6 环境的镜像 FROM python:3.6 # 作者 MAINTAINER geebos # 将当前目录所有文件添加到要构建的镜像中 COPY . /root/httpServer # 声明容器中的 /root/httpServer/log 目录为挂载点 VOLUME /root/httpServer/log # 设置工作目录 WORKDIR /root/httpServer # 绑定端口 EXPOSE 8000 # 设置启动命令 ENTRYPOINT python http.py 构建镜像 首先运行 docker build -t http-server:1.0 . 构建镜像其中 -t http-server:1.0 指定了镜像的名字和版本号为 http-server:1.0 然后运行 docker run -id -v d:/dockerTest/httpServer/log:/root/httpServer/log \\ -p 8000:8000 --name http-server-container http-server:1.0 来启动容器，其中：-d 表示后台启动-v d:/dockerTest/httpServer/log:/root/httpServer/log 绑定挂载目录-p 8000:8000 指定端口映射--name http-server-container 指定容器的名称为 http-server-container 启动之后我们可以访问 http://127.0.0.1:8000访问之后查看 d:/dockerTest/httpServer/log/log.txt 中会发现我们的请求记录被保存到宿主机上了 可以使用 docker exec -it http-server-container /bin/bash 进入到容器内部 常用 docker 命令 在镜像之上启动容器 docker build：构建镜像 常用格式：docker build -t 镜像名 Dockerfile所在路径 示例：dcoker build -t image-name . docker run：基于镜像启动容器 常用格式：docker run -id -t --name 容器名 镜像名/镜像ID 示例：docker run -id -t --name container-name image-name docker ps：显示所有容器信息 docker stop：停止容器运行 docker start：重新运行一个已停止的容器 docker rm：删除容器，删除之前要先确保容器已经停止运行。可以指定多个容器 示例：docker rm container-name docker images：显示所有镜像信息 docker rmi：删除镜像，删除之前要确保没有基于该镜像的容器存在。可以指定多个镜像 示例：docker rmi image-name/image-id docker exec：在容器中执行命令 示例：docker exec -it container-name /bin/bash。这命令可以启动容器内的 bash 参考资料 https://zhuanlan.zhihu.com/p/385852508https://docker-practice.github.io/zh-cn/install/ubuntu.html Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-14 22:08:23 "},"about_Other/PS操作.html":{"url":"about_Other/PS操作.html","title":"PS 操作","keywords":"","body":"概述 Photoshop 是 Adobe 公司开发的图形图像处理和编辑软件 应用领域：平面设计、UI设计、商业精修、创意合成、摄影后期、插图绘画等等 三个重要节点：1990年发布、2003年creative suite、2013年creative cloud 常用快捷键 新建 Ctrl + N 新建图层 Ctrl + Shift + N 打开 Ctrl + O 提高软件运行效率 Ctrl + K 存储 存储 Ctrl + S 存储为 Ctrl + Shift + S 导出为 Ctrl + Alt + Shift + W 关闭 关闭 Ctrl + W 全部关闭 Ctrl + Alt + W 撤销 Ctrl + Z 重做 Ctrl + Shift + Z 界面认识 顶部菜单栏顶部下方选项栏底部状态栏左侧工具栏右侧选项卡中间工作区内部画布 分辨率 ppi，像素/英寸像素/厘米 图片格式 JPEG，同一个图层上没有透明像素，内存小，压缩速度快GIF，动态图，文件-导出-存储为Web格式-选择gif格式PNG，无背景清洗原图，周围存在透明像素PSD，PS制作修改源文件 常见颜色模式 位图模式，只用黑白两种颜色表示像素灰度模式，由黑白灰表示像素RGB模式，电子屏幕计算颜色CMYK模式，油墨印刷计算颜色，颜色相对RGB变黯淡，色域不一样LAB模式，理论上包括了人眼可以看到的所有的色彩，L是明度（本身的明亮程度，而不是光照强度），A是深绿-灰-亮粉，B是深蓝-灰-黄注：位图又称为点阵图或者栅格图像，由像素组成 颜色填充 基础 色相，三原色、混合颜色 饱和度，颜色中掺入的黑色的多少，黑色越多颜色越黯淡 明度，颜色中掺入的白色的多少，白色越多颜色明亮 拾色器 图标是两个正方形叠在一起 前面的正方形设置前景色，Alt + Del 后面的正方形设置背景色，Ctrl + Del 重置默认前、背景色，前黑后白，D 互换前、背景色，X bit 数值越大，颜色越丰富，画面越细腻 选区 选区：黑白相间选区工具：所有可以创建选区的工具可以用于抠图、修图、调色、合成关键是需要精准只能对选区内部进行编辑【添加到选区】，可以一次取很多的区域，简称加选，Shift【从选区减去】，简称减选，Alt全选选区，Ctrl + A取消选区，Ctrl + D反选选区，Ctrl + Shift + I【选择】-【修改】-【扩展/收缩】使用【羽化】功能时，需要先调节羽化的参数，再进行选区，或者Shift + F6【选择】-【变换选区】，通过按住Shift或者Alt或者旋转，更加灵活载入选区，Ctrl + 鼠标左键，点击右侧的图层缩览图复制选区，Ctrl + J 视图调整 【视图】-【校样颜色】，原本RGB打印的时候CMYK，Ctrl + Y【视图】-【色域警告】，非常鲜艳的部分会变成灰色，说明这部分打印出来显示会有问题，Ctrl + Shift + Y【视图】-【像素长宽比】，改变像素的形状抓手工具，空格 + 鼠标左键放大缩小，Alt + 滚轮，或者 Ctrl + 空格 + 鼠标左键【视图】-【按照屏幕大小缩放】，Ctrl + 0调整屏幕模式，Tab或者F显示额外内容，参考线 Ctrl + H，标尺 Ctrl + R【视图】-【对齐】，在选区接近参考线的时候会有吸附功能锁定参考线，Ctrl + Alt + ; 窗口菜单 【窗口】-【排列】【窗口】-【工作区】-【复位基本功能】 图层编组 Ctrl + G排列移动图层 Ctrl + 【 或者 Ctrl + 】合并图层，但是保留原本的 Ctrl + Alt + Shift + E自由变换 Ctrl + T 参考资料 https://www.bilibili.com/video/BV17d4y1t7or?p=2 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:35:54 "},"about_Other/Redis整理.html":{"url":"about_Other/Redis整理.html","title":"Redis 整理","keywords":"","body":"基本命令 启动服务端和客户端 redis-server --service-startredis-cli -h 127.0.0.1 -p 6379 关闭客户端 redis-server --service-stop 字符串 set mykey helloworldget mykeygetrange mykey 0 5type mykeygetset mykey 23333del mykey 哈希 hmset mysite name \"tjhd\" url \"https://tjhd.com\" visitors 10hkeys mysitehlen mysitehget mysite namehgetall mysitehexists mysite visitorshset mysite visitors 100hdel mysite visitorshsetnx mysite visitors 100 列表 lpush mylist sqllpush mylist mysqllpush mylist postgresqllrange mylist 0 10llen mylistlset mylist 0 sqlserver 集合 元素都是唯一的sadd myset mongodbsadd myset db2sadd myset db1smembers mysetscard myset 获取集合的成员数 有序集合 zadd mysortedset 1 qingtongzadd mysortedset 2 baiyinzadd mysortedset 3 huangjinzadd mysortedset 4 bojinzadd mysortedset 5 zhuanshizrange mysortedset 0 10 withscoreszrem mysortedset qingtongzrange mysortedset 0 10 withscoreszcard mysortedsetzrank mysortedset zhuanshi HyperLogLog 比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5基数估计就是在误差可接受的范围内，快速计算基数pfadd myhll redispfadd myhll redispfadd myhll mongodbpfadd myhll mysqlpfcount myhll 发布订阅 发送者（在Redis术语中称为发布者）发送消息，而接收者（订阅者）接收消息需要开启两个客户端 第一个作为接收者： subscribe mychannel 第二个作为发布者： publish mychannel \"test\" publish mychannel \"hello world\" publish mychannel \"thank you\" 事务 MULTI 用来组装一个事务EXEC 用来执行一个事务DISCARD 用来取消一个事务WATCH 用来监视一些 key，一旦这些 key 在事务执行之前被改变，则取消事务的执行将一系列的语句放入缓存队列中，然后一起执行 面试题 https://redis.com.cn/redis-interview-questions.html 什么是Redis？ Redis(Remote Dictionary Server)是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API 的 非关系型数据库 传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式，而分布式一般遵循 CAP 定理 Redis支持的数据类型 Redis 可以存储键和不同类型的值之间的映射。键的类型只能为字符串，值常见有五种数据类型：字符串、列表、集合、散列表、有序集合 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？ 持久化就是 把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失 Redis 提供了两种持久化方式:RDB（默认） 和AOF RDB： rdb是Redis DataBase缩写 本质是内存和磁盘交互 功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数 AOF: Aof是Append-only file缩写 本质是服务端和磁盘交互 每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作 aof写入保存： WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件 SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中 用途 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库 计数器 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量 缓存 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率 会话缓存 可以使用 Redis 来统一存储多台应用服务器的会话信息 全页缓存（FPC） 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面 查找表 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源 分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现 其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:35:15 "},"about_Other/sd绘画提示词.html":{"url":"about_Other/sd绘画提示词.html","title":"sd 绘画提示词","keywords":"","body":"提示词 prompt 语法 推荐使用英语 不同的提示词用逗号 , 隔开 同一关键词混合多要素时用 |，例如 red|blue hair 赋予提示词权重，例如 (1girl:1.1),(long hair:1.21) 渐变 a girl with long [white:yellow:16] hair，迭代前16步为白发，之后提示词变为黄色头发 a girl with long [white:yellow:0.5] hair，总的迭代步数的前一半为白发，之后提示词变为黄色头发 交替使用中括号中的提示词，例如 [cow|horse|cat|dog] in a field 逗号前后允许有 空格 或者 换行 建议 用换行将不同类的词分开，方便随时调整 画质词 (masterpiece:1.331), best quality, 描述词 (1girl:1.1),(long hair:1.21) 关键词控制在 75个（100个）以内 越关键的词，越往前放 相似的同类，放在一起 只写必要的关键词 反向提示词 Negative prompt 用文字描述你不想在图像中出现的东西AI 大致做法就是1、对图片进行去噪处理，使其看起来更像你的提示词2、对图片进行去噪处理，使其看起来更像你的反向提示词（无条件条件）3、观察这两者之间的差异，并利用它来产生一组对噪声图片的改变4、尝试将最终结果移向前者而远离后者5、一个相对比较通用的负面提示词设置 lowres,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,worst quality,low quality,normal quality,jpeg artifacts,signature,watermark,username,blurry,bad feet, 提示词编写 tips 前摇 masterpiece,best quality,official art,extremely detailed CG unity 8k,wallpaper,highly detailed,illustration 人物 人设、身体、服装、饰品等等 背景 时间、天气、季节、建筑、场地等等 B 站搜索 元素宝典，有参考案例 其他基础 名词 文件名 路径 备注 大模型或者底模型 ckpt D:\\stable-diffusion-new\\models\\Stable-diffusion embeddings pt D:\\stable-diffusion-new\\embeddings 可以识别某个特定的角色 Hypernetwork pt D:\\stable-diffusion-new\\models\\hypernetworks 指定画风 DreamBooth LoRA 存放路径 1、使用插件 D:\\stable-diffusion-new\\extensions\\sd-webui-addtional-networks\\models\\lora2、不使用插件 D:\\stable-diffusion-new\\models\\lora 一般用于角色训练 插件安装 github上下载后手动安装，插件存放目录 D:\\stable-diffusion-new\\extensions\\ 模型训练 https://www.bilibili.com/video/BV1ss4y1s7ta/?spm_id_from=333.999.0.0&vd_source=f17bac2fc1c6cdda2557b1601f2c6413 步骤1、复制训练图片，在 stable-diffusion 根目录下创建新的文件夹 train 用于存放训练图片。例如我现在有几十张的梵高大师画作的图片，然后创建目录 D:\\stable-diffusion-new\\train\\fangao，接着在该目录下再创建文件夹 \\fangao_in 和 \\fangao_out，再把图片都粘贴到 \\fangao_in 目录下2、执行图像预处理。注意勾选使用 deepbooru 生成文字说明3、创建 Dreambooth 模型，生成的文件在 D:\\stable-diffusion-new\\models\\dreambooth 下 参考资料 https://www.tjsky.net/tutorial/488https://blog.csdn.net/m0_37857300/article/details/127445588https://www.imgtp.com/ Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-24 21:31:41 "},"about_Other/计算机网络.html":{"url":"about_Other/计算机网络.html","title":"计网","keywords":"","body":"一、计算机网络概述 1.1 计算机网络的分类 按照作用范围分类 1、广域网（WAN） 2、城域网（MAN） 3、局域网（LAN） 按照网络使用者分类 1、公用网络 2、专用网络 1.2 计算机网络的层次结构 7 层物理层，负责实现通信的光电物理特性数据链路层，负责相邻节点之间的数据通信网络层，数据路由，决定数据在网络中的路径传输层，负责端到端的网络通信会话层，负责建立、维护、重连通信会话表示层，负责数据处理，编码解码、加密解密应用层，负责提供接口和服务 上述 7 层结构也叫 OSI 体系结构相应的有一个TCP/IP的 4 层模型，对比如下 OSI 七层网络模型 TCP/IP 四层概念模型 基本数据单位 对应网络协议 应用层 应用层 数据报文 HTTP、FTP 等 表示层 Telnet 会话层 SMTP、DNS 等 传输层 传输层 段 TCP、UDP 等 网络层 网络层 分组、IP 数据报 IP、ICMP 等 数据链路层 网络接口层 数据帧、比特 PPP 等 物理层 IEEE 等 1.3 层次结构设计的基本原则 各层之间相互独立、完全解耦？？？每层需要一定的灵活性 1.4 计算机网络的性能指标 速率，bps即bit/s，每秒多少比特（1字节=8比特=8位 / 1Byte=8bit）时延，包括：发送、传播、排队、处理4种时延往返时间RTT，数据报文在端到端通信中来回一次的时间 二、物理层 2.1 作用 连接不同的物理设备，传输比特流该层为上层协议提供了一个传输数据的可靠的物理媒体确保原始的数据可在各种物理媒体上传输 2.2 设备 中继器（Repeater，也叫放大器） 同一局域网的再生信号 两端口的网段必须同一协议 集线器 同一局域网的再生、放大信号（可看作多端口的中继器） 半双工，不能隔离冲突域也不能隔离广播域 信道 是往一个方向传输信息的媒体，一条通信电路包含一个发送信道和一个接受信道 通信信道类别 单工：只能一个方向通信，没有反方向反馈的信道 半双工：双方都可以发送和接受信息，但不能同时发送也不能同时接收 全双工：双方都可以同时发送和接收 三、数据链路层 3.1 概述 数据链路层是第 2 层，在第 1 层物理层提供的服务的基础上，向第 3 层网络层提供服务数据链路层在不可靠的物理介质上为网络层提供可靠的传输 作用 物理地址寻址 数据的成帧 流量控制 数据的检错 重发 基本数据单位为帧 封装成帧 数据前后加上首部和尾部，它们是特定的控制字符 透明传输 特定的控制字符若出现在了数据内部而不是首尾部怎么办？ 没事，透明传输机制会在控制字符前面加上转义字符 主要协议：以太网协议 重要设备 网桥 交换机 3.2 差错检测 方法 奇偶校验码 当出错两位时，检测不到错误 循环冗余校验码CRC 根据传输或保存的数据而产生固定位数校验码 具体检测过程省略 3.3 最大传输单元 MTU 数据帧的长度受到MTU的限制，并不是无限大的 3.4 以太网协议 以太网协议 一种局域网技术，应用于数据链路层 用于完成相邻设备的数据帧传输 以太网的特点 数据速率快 硬件价格便宜，网络造价成本低 以太网帧结构 结构 占用字节数 目的地址（MAC地址） 6 字节 源地址（MAC地址） 6 字节 类型（标识上层协议） 2 字节 帧数据（封装的上层协议的分组） 46 ~ 1500 字节 CRC（循环冗余码） 4 字节 所以，以太网帧最短为 64 字节（以太网帧除了数据部分 6+6+2+4=18 字节，数据最短 46 字节） MAC 地址 也叫物理地址或者局域网地址 每一个设备都拥有唯一的 MAC 地址，比如你的计算机或者手机都是如此 共 48 位 == 6 字节 通常采用十六进制表示法，每个字节表示一个十六进制数，用 - 或 : 连接起来 MAC 广播地址：FF-FF-FF-FF-FF-FF 四、网络层 具体功能 寻址和路由选择 连接的建立、保持和终止等 数据交换技术是报文交换（基本上被分组所替代）：采用储存转发方式 4.1 IP协议 虚拟互联网络的产生 实际的计算机网络错综复杂 物理设备通过使用 IP 协议，屏蔽了物理网络之间的差异 当网络中主机使用 IP 协议连接时，无需关注网络细节 可以想象成IP协议构成了计算机之间通信的黑盒子 IP协议 是TCP/IP的核心协议 仅仅提供不可靠、无连接的传送服务 与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP 主要功能 无连接数据报传输 数据报的路由选择 差错控制 其中，版本指IP协议的版本，占4位，如IPv4和IPv6；首部位长度表示IP首部长度，占4位；IP数据报总长度，占16位，最大数值位2^16=65535；生存时间表示IP数据报文在网络中的寿命，占8位；上层协议表明IP数据所携带的具体数据是什么协议的，如TCP、UDP 4.2 IP 协议的转发流程 通过查询路由表来发现下一跳 4.3 IP 地址的子网划分 总长度位 32 位，即 4 字节 \\ A类 B类 C类 D类 E类 构成 8网络号 + 24主机号 16网络号 + 16主机号 24网络号 + 8主机号 用途 用于标识网络中的主机或路由器 作为组广播地址 地址保留 \\ A类 B类 C类 前缀长度 8位 16位 24位 前缀 0xxxxxxx 10xxxxxx.xxxxxxxx 110xxxxx.xxxxxxxx.xxxxxxxx 最小网络号 0 (00000000) 128.0 (10000000.00000000) 192.0.0 (11000000.00000000.00000000) 最大网络号 127 (01111111) 191.255 (10111111.11111111) 223.255.255 (11011111.11111111.11111111) 子网数量 2^7 2^14 2^21 最小主机号 0.0.0 0.0 0 最大主机号 255.255.255 255.255 255 主机数量 2^24 2^16 2^8 4.4 网络地址转 NAT 技术 用于多个主机通过一个公有IP访问互联网的私有网络减缓了IP地址的消耗，但是增加了网络通信的复杂度 NAT 工作原理（作IP地址替换） 从内网出去的IP数据报，将其IP地址替换为NAT服务器拥有的合法的公共IP地址，并将替换关系记录到NAT转换表中 从公共互联网返回的IP数据报，依据其目的的IP地址检索NAT转换表，并利用检索到的内部私有IP地址替换目的IP地址，然后将IP数据报转发到内部网络 用自己的话来说就是：通过NAT转换表，发出去时候私有IP转换成公共IP，收进来的时候目的IP转换成私有IP 4.5 ARP 协议与 RARP 协议 ARP（Address Resolution Protocol）地址解析协议 为网卡（网络适配器）的IP地址到对应的硬件地址提供动态映射 可以把 网络层32位地址 ---> 数据链路层MAC48位地址 即插即用，一个ARP表是自动建立的，不需要系统管理员来配置 RARP（Reverse Address Resolution Protocol）逆地址解析协议 是 ARP 的逆过程 可以把 数据链路层MAC48位地址 ---> 网络层32位地址 4.6 ICMP 协议 ICMP（Internet Control Message Protocol）网际控制报文协议可以报告 错误信息或者异常情况，ICMP报文封装在IP数据报当中 应用 Ping：网络故障的排查 Traceroute：可以探测IP数据报在网络中走过的路径 4.7 网络层的路由 路由算法的要求 正确的完整的 在计算上应该尽可能是简单的 可以适应网络中的变化 稳定的公平的 自治系统AS 指处于一个管理机构下的网络设备群 AS内部网络自治管理，对外提供一个或多个出入口 其中自治系统内部的路由协议为内部网关协议，如RIP、OSPF等；自治系统外部的路由协议为外部网关协议，如BGP 静态路由：人工配置，难度和复杂度高 动态路由 1、【链路状态】路由选择算法 LS 向所有隔壁路由发送信息收敛快；全局式路由选择算法，每个路由器计算路由时，需构建整个网络拓扑图；利用 Dijkstra算法 求源端到目的端网络的最短路径 2、【距离-向量】路由选择算法 DV 向所有隔壁路由发送信息收敛慢、会存在回路；基础是 Bellman-Ford 方程（简称B-F方程） 4.8 内、外部网关协议 内部 RIP（Routing Information Protocol）路由信息协议 位于 应用层 基于距离-向量的路由选择算法，较小的AS（自治系统），适合小型网络 报文封装进 UDP 数据报 特性 采用跳数来度量路径（每个路由器维护自身到其他每个路由器的距离记录） 费用定义在源路由器和目的子网之间 网络直径被限制为不超过15跳 和隔壁交换所有的信息，30主动一次（广播） OSPF（Open Shortest Path First）开放最短路径优先协议 位于 网络层 基于链路状态的路由选择算法（即Dijkstra算法），较大规模的AS，适合大型网络 报文直接封装在IP数据报 优点 安全 支持多条相同费用路径 支持区别化费用度量 支持单播路由和多播路由 分层路由 外部 BGP（Border Gateway Protocol）边际网关协议 位于 应用层 是运行在AS之间的一种协议，寻找一条好路由。首次交换全部信息，以后只交换变化的部分 BGP封装进TCP报文段 五、传输层 第一个端到端，即主机到主机的层次 传输层的任务 根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输 处理端到端的差错控制和流量控制问题 在这一层，信息传送的协议数据单元称为段或报文 网络层只是根据网络地址将源结点发出的数据包传送到目的结点而传输层则负责将数据可靠地传送到 相应的端口 主要协议 TCP协议（Transmission Control Protocol）传输控制协议 UDP协议（User Datagram Protocol）用户数据报协议 重要设备：网关 使用不同的端口来标记不同的网络进程，其中端口 port 使用 16 比特位表示，故端口可能的范围为 [0, 65535] 常见协议占用的端口 FTP HTTP HTTPS DNS TELNET 21 80 443 53 23 5.1 UDP协议 UDP首部 + UDP数据报 = IP数据报的数据部分 特点 无连接协议 不能保证可靠的交付数据 面向报文传输的 没有拥塞控制 首部开销很小 首部：8字节=64位，源端口、目的端口、UDP长度、校验和各16位 数据字段：应用数据 5.2 TCP协议 TCP首部 + TCP数据报 = IP数据报的数据部分 功能 对应用层报文进行分段和重组 面向应用层实现复用与分解 实现端到端的流量控制 拥塞控制 传输层寻址 对收到的报文进行差错检测（首部和数据部分都检错） 实现进程间的端到端可靠数据传输控制 特点 面向连接的协议 面向字节流的协议 一个连接有两端，即点对点通信 提供可靠的传输服务 提供全双工通信（每条TCP连接只能一对一） TCP标记 含义 URG Urgent，紧急位，紧急数据 ACK Acknowlegement，确认位，使得确认号生效 PSH Push，推送位，把数据交付给应用层 SYN Synchronization，同步位，发送连接请求 FIN Finish，终止位，释放连接 RST Reset，重置位，重新建立连接 5.3 可靠传输 不可靠传输信道在数据传输中可能发生的情况：比特差错、乱序、重传、丢失 基于不可靠信道实现可靠数据传输采取的措施 差错检测：利用 编码 实现数据包传输过程中的比特差错检测 确认：接收方 向 发送方 反馈 接收状态 重传：发送方 重新发送 接收方没有正确接收的数据 序号：确保数据 按序 提交 计时器：解决数据丢失问题 可靠传输协议 停止等待协议 是最简单的一种，但是该协议对信道的利用率不高 连续ARQ（Automatic Repeat reQuest）自动重传请求 滑动窗口+累计确认，大幅提高了信道的利用率 但是在某些情况下，重传的效率并不高，会重复传输部分已经成功接收的字节 TCP协议使用滑动窗口实现流量控制，让发送方发送速率不要太快 5.4 拥塞控制 \\ 流量控制 拥塞控制 范围 点对点的通信量 考虑整个网络，全局性 使用到的方法 滑动窗口 慢启动+拥塞避免算法 慢开始、拥塞避免 【慢开始】拥塞窗口从1指数增长 到达阈值时进入【拥塞避免】，变成+1增长 【超时】，阈值变为当前拥塞窗口cwnd的一半（不能 再从【慢开始】，拥塞窗口从1指数增长，依此类推 快重传、快恢复 发送方连续收到3个冗余ACK，执行【快重传】，不必等计时器超时 执行【快恢复】，阈值变为当前cwnd的一半（不能 5.5 TCP连接的握手 三次 为什么需要三次握手？ 第一次握手：客户发送请求，此时服务器知道客户能发 第二次握手：服务器发送确认，此时客户知道服务器能发能收 第三次握手：客户发送确认，此时服务器知道客户能收 握手过程 第一次：客户向服务器发送连接请求段，建立连接请求控制段（SYN=1），表示传输的报文段的第一个数据字节的序列号是x，此序列号代表整个报文段的序号（seq=x）；客户端进入 SYN_SEND （同步发送状态） 第二次：服务器发回确认报文段，同意建立新连接的确认段（SYN=1），确认序号字段有效（ACK=1），服务器告诉客户端报文段序号是y（seq=y），表示服务器已经收到客户端序号为x的报文段，准备接受客户端序列号为x+1的报文段（ack_seq=x+1）；服务器由LISTEN进入SYN_RCVD （同步收到状态） 第三次:客户对服务器的同一连接进行确认.确认序号字段有效(ACK=1),客户此次的报文段的序列号是x+1(seq=x+1),客户期望接受服务器序列号为y+1的报文段(ack_seq=y+1);当客户发送ack时，客户端进入ESTABLISHED 状态;当服务收到客户发送的ack后，也进入ESTABLISHED状态;第三次握手可携带数据 四次 握手过程 第一次：客户向服务器发送释放连接报文段，发送端数据发送完毕，请求释放连接（FIN=1），传输的第一个数据字节的序号是x（seq=x）；客户端状态由ESTABLISHED进入FIN_WAIT_1（终止等待1状态） 第二次：服务器向客户发送确认段，确认字号段有效（ACK=1），服务器传输的数据序号是y（seq=y），服务器期望接收客户数据序号为x+1（ack_seq=x+1）;服务器状态由ESTABLISHED进入CLOSE_WAIT（关闭等待）； 客户端收到ACK段后，由FIN_WAIT_1进入FIN_WAIT_2 第三次:服务器向客户发送释放连接报文段，请求释放连接（FIN=1），确认字号段有效（ACK=1），表示服务器期望接收客户数据序号为x+1（ack_seq=x+1）;表示自己传输的第一个字节序号是y+1（seq=y+1）；服务器状态由CLOSE_WAIT 进入 LAST_ACK （最后确认状态） 第四次：客户向服务器发送确认段，确认字号段有效（ACK=1），表示客户传输的数据序号是x+1（seq=x+1），表示客户期望接收服务器数据序号为y+1+1（ack_seq=y+1+1）；客户端状态由FIN_WAIT_2进入TIME_WAIT，等待2MSL时间，进入CLOSED状态；服务器在收到最后一次ACK后，由LAST_ACK进入CLOSED 为什么客户机发送方需要在最后等待 2 个MSL（Max Sagment Lifetime）？ 最后还有报文需要确定 确保最后的ACK可以送达 确保当前连接的所有报文都已过期 六、应用层 为操作系统或网络应用程序提供 访问网络服务 的接口数据传输基本单位为报文 主要协议 FTP（文件传送协议） Telnet（远程登录协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议） HTTP协议（Hyper Text Transfer Protocol） 6.1 DNS Domain Name System，域名系统C/S，UDP，端口53解决IP地址复杂难以记忆的问题，存储并完成自己所管辖范围内主机的 域名 到 IP 地址的映射。IP —> DNS服务 —> 便于记忆的域名 域名 由点、字母和数字组成，分为顶级域（com，cn，net，gov，org）、二级域（baidu,taobao,qq,alibaba）、三级域（www）(12-2-0852) 域名解析的顺序 浏览器缓存 找本机的hosts文件 路由缓存 找DNS服务器（本地域名、顶级域名、根域名）->迭代解析、递归查询 6.2 DHCP协议 Dynamic Configuration Protocol，动态主机设置协议局域网协议，是应用UDP协议的应用层协议作用：为临时接入局域网的用户自动分配IP地址 6.3 FTP协议 文件传输协议控制连接（端口21）传输控制信息（连接、传输请求），以7位ASCII码的格式。整个会话期间一直打开 6.4 HTTP协议 HyperText Transfer Protocol，超文本传输协议TCP，端口80可靠的数据传输协议，浏览器向服务器发收报文前，先建立TCP连接，HTTP使用TCP连接方式（HTTP自身无连接） HTTP请求报文方式 GET：请求指定的页面信息，并返回实体主体 POST：向指定资源提交数据进行处理请求 DELETE：请求服务器删除指定的页面 HEAD：请求读取URL标识的信息的首部，只返回报文头 OPETION：请求一些选项的信息 PUT：在指明的URL下存储一个文档 操作方式 数据位置 明文密文 数据安全 长度限制 应用场景 GET HTTP包头 明文 不安全 长度较小 查询数据 POST HTTP正文 可明可密 安全 支持较大数据传输 修改数据 存储器层次结构 缓存，Redis 主存，Memcached 辅存，内存SSD 6.5 HTTPS协议 HTTPS(Secure)是安全的HTTP协议，端口号443基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护 参考资料 https://blog.csdn.net/Royalic/article/details/119985591 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2023-12-10 10:30:49 "},"about_Other/Gitbook的安装部署.html":{"url":"about_Other/Gitbook的安装部署.html","title":"Gitbook 的安装部署","keywords":"","body":"参考资料 部署教程：https://www.mapull.com/gitbook/comscore/使用指南：https://zha0cai.github.io/gitbookPublic/gitbook-guide/关于插件：https://blog.csdn.net/qq_43514847/article/details/86598399关于公式：https://blog.csdn.net/qq_42898299/article/details/106779945http://www.zhaowenyu.com/gitbook-doc/default-files/book-json.html部署：https://dvel.me/posts/deploy-blog-in-cloudflare-pages/ 安装 nodejs 下载地址：https://nodejs.org/en/download/releases安装配置指南：https://blog.csdn.net/zhouyan8603/article/details/109039732 卸载 nodejsC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs 找到 nodejs，进行 uninstall删除对应目录下的文件删除 c 盘用户下的缓存删除环境变量 简单配置 查看版本node -v npm -v 将缓存和仓库建在其他盘，比如 d 盘需要在 node.exe 所在目录下创建文件夹 node_global 和 node_cache再执行npm config set prefix \"D:\\nodejs\\node_global\" 和 npm config set cache \"D:\\nodejs\\node_cache\" 配置镜像网站npm config set registry=http://registry.npm.taobao.org 配置环境变量增加 NODE_PATH 变量 D:\\nodejs\\node_global\\node_modules在 path 中添加如下两条 D:\\nodejs D:\\nodejs\\node_global 查看所有配置信息npm config list 测试npm install vue -g 将包下载到 global 全局目录中 安装 gitbook 推荐下载 10 或者 11 版本的 nodejs gitbook init 可能会出现的问题：https://www.cnblogs.com/eternalnight/p/15192585.htmlhttps://blog.csdn.net/qq_30033537/article/details/113738575一般来说都是没问题的，可能下载需要等待较长一段时间 部署 gitbook 可以使用以下平台：1、Gitee pages2、glitch.me3、GitHub pages4、cloudflare：https://dash.cloudflare.com/2e55d48f8306baee004a3e7e40f5a8e9/pages/new/provider/github  mymail_yjj@qq.com 12345678@ 先切换路径到：D:\\mybook_ubuk 执行：gitbook init //初始化，时间可能比较久gitbook install //用于安装插件gitbook build --log=debuggitbook serve 遇到的问题https://blog.csdn.net/K_Lily/article/details/105291511修改文件 C:\\Users\\magicclannad\\.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js之后以管理员身份重启 cmd 进行 build.gitignore 放在哪里，对应的里面路径就是哪里，不要管 book.json 中的 root 可能使用到的插件这里手动下载：https://www.npmjs.com/ \"plugins\": [ \"splitter\", \"favicon\", \"insert-logo\", \"code\", \"-lunr\", \"-search\", \"search-pro\", \"back-to-top-button\", \"mathjax-pro\", \"auto-scroll-table\", \"popup\", \"tbfed-pagefooter\", \"flexible-alerts\", \"accordion\", \"zymplayer\" ], 在 book.json 中添加以上内容然后执行 gitbook install，或者使用 NPM 安装，例如 npm install gitbook-plugin-page-treeview，也可以从源码 GitHub 地址中下载，放到 node_modules 文件夹里 推送到 giteegit remote -vgit remote remove origingit remote add origin https://gitee.com/？？？/ubuk.gitgit add .git commit -m \"？？？\"git push -u origin main 关于 git 推送的文件忽略先修改 .gitignore 中的内容，再执行 git rm -r -f --cached .之后重新提交、推送即可 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-14 22:53:32 "},"about_Other/网站收集.html":{"url":"about_Other/网站收集.html","title":"网站收集","keywords":"","body":"数学 💡 链接 各种笔记 https://www.ma-xy.com 高数笔记 https://www.cnblogs.com/ixtwuko/p/advanced-mathematics.html 线代笔记 https://linalg.apachecn.org 在线编辑数学公式 https://www.latexlive.com 工具 https://mathworld.wolfram.com 实用网站 💡 链接 多功能导航 http://zoudupai.com https://docs.apachecn.org 文件转换 https://convertio.co/zh 百科 https://wiki.swarma.org/index.php 英文论文查重 https://www.quetext.com/plagiarism-checker 期刊信息 https://www.letpub.com 音乐 DL https://www.musicenc.com 听歌识曲 https://aha-music.com AI对话模型 https://www.llama2.ai 热门 AI 导航 https://www.aigc.cn 小语种学习 https://jp.tingroom.com 免费壁纸图片 https://www.pexels.com/zh-cn https://www.wallpaperhub.app 表情包 https://www.dbbqb.com 大佬博客 https://www.alsritter.icu 机场 https://cc.dabai.in ikuuu 驾考 https://www.jiazhao.com/tiba gitbook https://ubuk.pages.dev 编程相关 💡 链接 工具箱 https://tool.oschina.net https://uutool.cn 廖雪峰学习网站 https://www.liaoxuefeng.com SQL 教程 https://sqlzoo.net/wiki/SQL_Tutorial 思否技术论坛 https://segmentfault.com 图像分割 https://github.com/open-mmlab/mmsegmentation 李宏毅 http://speech.ee.ntu.edu.tw/~tlkagk/index.html 帅地 https://www.iamshuaidi.com 刷题 https://codeforces.com 电子书 http://www.banshujiang.cn 图标下载 https://www.flaticon.com 国外课程 https://ai.stanford.edu/blog http://cs231n.stanford.edu/index.html ML 的可视化 https://github.com/Visualize-ML/Book7_Visualizations-for-Machine-Learning/tree/main 仙剑三重写 https://github.com/0x7c13/Pal3.Unity 娱乐 💡 链接 联机宝可梦 https://pokemmo.com/zh 谱子 https://wap.hqgq.com 小说 https://b.wunpu.com 八难问题小游戏 https://murhafsousli.github.io/8puzzle/#/ 风物之诗琴 https://haveyouwantto.github.io/WindsongLyre-Sim 影视 https://vip.yeyulingfeng.com https://www.freeok.vip 神奇海螺试验场 https://lab.magiconch.com Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-17 00:02:03 "},"leisure_time/":{"url":"leisure_time/","title":"休闲一下","keywords":"","body":"休闲一下 浪漫，讽刺，数学和语言的网络漫画 - 作者：兰德尔·门罗 SpaceShip - OpenGameArt.org 刷剧 - 夜雨聆风 别人整理的笔记 - huaxiaozhuan 漫画图解知识 - 混知 小念头 第一节 握拳屈膝，开好马步（二指钳羊马），重心下沉 双手张开，双耕手，双摊手，收拳 左手日字冲拳，摊平，圈手，收拳；右手类似 摊手，（圈手变护手再慢慢收回，伏手再慢慢往前）3次，圈手变护手再慢慢收回，放松拍手，撑掌，摊平，圈手，收拳；右手类似 第二节 左手按掌，右手按掌，双手后按掌，双手前按掌 双手端平，左手在上右手在下，拂手变栏手 枕手，前标，窒手，标手 压臂呼气，提臂呼气，圈手，收拳 第三节 左手推拍，横掌，圈手，收拳；右手类似 左手标摊，耕手，标摊，圈手，底掌，标摊，圈手，收拳；右手类似 左手绑手，鞭摊，托手，圈手，收拳；右手类似 左手伸出，手腕对中，右手置于左手肘关节，甩手，左右手交替做3次，日字冲拳3次，圈手，收拳 来看看AI写的小说大纲 第一章：贫民窟的孤儿 艾米的背景介绍，生活在贫民窟，左眼失明 艾米的家庭情况，生活的困苦，但他的母亲给予他力量 第二章：铜矿的艰辛 艾米开始工作在铜矿，了解工作环境的危险和不公平 他结交了一些志同道合的工友，听他们诉说贫困的故事 第三章：社会的不公 描述社会财富不均的情况，2%的富人掌握了60%的财富 艾米亲眼目睹富人的奢华生活，感到愤怒 第四章：无政府主义的种子 艾米接触到无政府主义思想，开始怀疑政府的能力和诚信。 他与一位老无政府主义者交流，学习更多关于反抗的思想。 第五章：组建抵抗团队 艾米决定组建一个小的抵抗团队，与他的工友合作。 团队计划揭露政府腐败和富人的不道德行为。 第六章：策划暴力行动 艾米的团队考虑采取暴力手段，引起社会的关注和警惕。 他们计划在富人社区制造一次流血事件，以震慑政府。 第七章：行动前的准备 描述团队的秘密准备，包括武器和计划的细节。 艾米开始感到内疚和恐惧，但他坚定地认为这是唯一的出路。 第八章：流血事件 描述流血事件的发生，引起媒体和政府的关注。 艾米的团队成功地震慑了政府和警察，但也付出了代价。 第九章：后果与反思 描述政府对抵抗团队的打压，团队成员受伤和被捕。 艾米开始反思自己的决策，考虑更和平的方式来改变社会。 第十章：新的希望 艾米寻找其他改革的途径，加入社会运动，争取公平和正义。 小说结束，留下希望和改变的可能性。 这个小说将围绕贫富差距、无政府主义、抵抗和改革等主题展开，通过艾米的故事探讨社会不公和反抗的复杂性。 每章都将深入探讨不同的议题，展示主人公艾米的成长和内心挣扎。 第十一章：新的盟友 艾米在社会运动中结识了一位有影响力的社会改革者，她鼓励他以和平方式争取变革。 他开始参与示威和社区活动，拓展了自己的视野。 第十二章：政府的回应 描述政府对抵抗活动的反应，他们试图平息示威并继续打压反对派。 艾米与其他活动家一起制定策略，保持压力。 第十三章：社会变革的曙光 社会运动逐渐取得成果，政府开始作出改变以回应民众的呼声。 艾米和其他活动家感到他们的努力有了意义。 第十四章：家庭的重逢 艾米寻找到失散多年的家人，他们重聚在社会改革的胜利下。 家庭团聚成为故事的感人高潮。 第十五章：回顾与前瞻 小说回顾了艾米的成长和社会变革的历程。 艾米决定继续参与改革工作，为更公平的社会努力。 这个小说将以社会改革的希望和艾米的成长为结尾，强调了和平抵抗和社会运动的重要性。通过故事情节，读者将能够思考社会不公和变革的复杂性，并鼓励积极参与改善社会的努力。 Copyright © all right reserved, powered by ... 2023该文档修订时间： 2024-01-11 23:54:57 "}}